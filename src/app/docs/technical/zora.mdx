# Zora Protocol Integration

> **Documentation Note**: This guide reflects Zora Protocol documentation as of February 6, 2024. For the most current information, please refer to the [official Zora documentation](https://docs.zora.co/). This document serves as an implementation reference for our specific use cases.

## Collector Client Operations

### 1. Getting Token Information (`getToken`)
```typescript
const { token, prepareMint, primaryMintActive, primaryMintEnd, secondaryMarketActive } = await getToken({
  tokenContract: "0x...",  // contract address
  mintType: "1155",        // "1155" | "721" | "premint"
  tokenId: 1n,             // for 1155s
  preferredSaleType?: "fixedPrice" | "erc20" | "allowlist" | "premint" | "timed"
});
```

#### Response Structure
- `token`: Contains contract details, sales config, token info
- `primaryMintActive`: Boolean indicating if primary mint is active
- `primaryMintEnd`: Optional timestamp for mint end
- `secondaryMarketActive`: Boolean for secondary market status
- `prepareMint`: Function to prepare mint transaction (if primary mint active)

### 2. Getting Contract Tokens (`getTokensOfContract`)
```typescript
const { tokens, contract } = await getTokensOfContract({
  tokenContract: "0x...",
  preferredSaleType?: "fixedPrice" | "erc20" | "allowlist" | "premint" | "timed"
});
```
Returns array of all tokens in a contract with their mint status.

### 3. Minting Process
```typescript
// 1. Prepare mint parameters
const { parameters, costs, erc20Approval } = prepareMint({
  minterAccount: "0x...",
  quantityToMint: 3n,
  mintComment?: string,
  mintReferral?: string,
  mintRecipient?: string
});

// 2. Handle ERC20 approval if needed
if (erc20Approval) {
  // Execute approval transaction first
}

// 3. Execute mint transaction
// parameters ready for wallet client
```

## Creator Client Operations

### 1. Creating New 1155 Contract & Token

```typescript
const { parameters, contractAddress } = await create1155({
  contract: {
    name: "ContractName",
    uri: "ipfs://contract-metadata.json",
  },
  token: {
    tokenMetadataURI: "ipfs://token-metadata.json",
    salesConfig: {
      // Secondary Market Configuration
      erc20Name?: "Token Name",      // Optional: defaults to contract name
      erc20Symbol?: "TKN",           // Optional: derived from name if not provided
      saleStart: 0n,                 // 0 = immediate start
      marketCountdown: 86400n,       // 24 hours in seconds
      minimumMintsForCountdown: 1111n
    }
  },
  account: creatorAddress,
  publicClient
});
```

### 2. ERC20 Token Sales Configuration

```typescript
const { parameters } = await create1155({
  contract: {
    name: "ContractName",
    uri: "ipfs://contract-metadata.json",
  },
  token: {
    tokenMetadataURI: "ipfs://token-metadata.json",
    salesConfig: {
      type: "erc20Mint",
      currency: "0x...",  // ERC20 token address
      pricePerToken: 1000000000000000000n,  // Price in ERC20 decimals
      saleStart: 0n,
      saleEnd: 1895873160n
    }
  },
  account: creatorAddress,
  publicClient
});
```

### 3. Split Payment Configuration

```typescript
// 1. Configure Split Recipients
const splitsConfig = {
  recipients: [
    {
      address: "0x...",
      percentAllocation: 70,
    },
    {
      address: "0x...",
      percentAllocation: 30,
    }
  ],
  distributorFeePercent: 0
};

// 2. Create Split Contract (if doesn't exist)
const predicted = await splitsClient.predictImmutableSplitAddress(splitsConfig);
if (!predicted.splitExists) {
  const { data, address } = await splitsClient.callData.createSplit(splitsConfig);
  // Execute split creation transaction
}

// 3. Create 1155 with Split Recipient
const { parameters } = await create1155({
  contract: contractConfig,
  token: {
    tokenMetadataURI: "ipfs://token-metadata.json",
    payoutRecipient: predicted.splitAddress
  },
  account: creatorAddress,
  publicClient
});
```

### Key Creation Considerations

1. **Secondary Market Setup**
   - Zero ETH price enables secondary market
   - Configurable countdown and minimum mints
   - Automatic ERC20 token creation for trading

2. **ERC20 Sales**
   - Requires specific `salesConfig.type = "erc20Mint"`
   - Must specify currency address and price
   - No secondary market available for ERC20 sales

3. **Split Payments**
   - Must be set during creation
   - Not supported with premints
   - Requires two transactions (split creation + token creation)
   - Uses 0xSplits protocol under the hood

4. **Price Configuration Impact**
   - Non-zero ETH price disables secondary market
   - ERC20 pricing disables secondary market
   - Zero ETH price enables full Zora market features

## Pricing Models

### 1. ERC20 Fixed Price Sale
- Token is priced in an ERC20 token (e.g., USDC)
- Identified by `salesConfig.saleType === "erc20"`
- Requires token approval before minting
- Example from API:
```json
"salesConfig": {
  "saleType": "erc20",
  "pricePerToken": "1000000",
  "currency": "0x833589fcd6edb6e08f4c7c32d4f71b54bda02913",  // USDC contract
  "saleEnd": "1895873160",
  "saleStart": "1722554784"
}
```

### 2. ETH Fixed Price Sale
- Token is priced in ETH (non-zero amount)
- No secondary market functionality
- Direct mint without approvals

### 3. Zero ETH with Secondary Market
- Token is priced at 0 ETH
- Enables Zora's secondary market functionality
- Features:
  - Market countdown
  - Minimum mints requirement
  - Secondary trading pool

## Implementation Notes

### API Response Structure
- Primary sale info comes from `salesConfig` object
- Secondary market info available only for zero-ETH tokens
- Need to handle both ERC20 and ETH pricing models in UI

### Key Considerations
1. Check `salesConfig.saleType` to determine pricing model
2. For ERC20, need to handle token approval before minting
3. Secondary market features only available for zero-ETH tokens
4. Always check `primaryMintActive` before attempting mint
5. Handle both preparation and execution of transactions separately

## Secondary Market Operations

### Prerequisites
1. Token must use ZoraTimedSaleStrategy
2. Primary mint period must be ended
3. Secondary market must be launched
4. Token must have been created with zero ETH price

### 1. Getting Secondary Market Info
```typescript
const secondaryInfo = await collectorClient.getSecondaryInfo({
  contract: "0x...",
  tokenId: 4n
});

// Available Secondary Info
interface SecondaryInfo {
  secondaryActivated: boolean;     // If market is live
  pool: `0x${string}`;            // Uniswap pool address
  erc20z: `0x${string}`;          // Trading token address
  name: string;                    // ERC20z token name
  symbol: string;                  // ERC20z token symbol
  saleStart: bigint;              // Mint start time
  saleEnd?: bigint;               // Set after countdown starts
  marketCountdown?: bigint;        // Time until market launch
  minimumMintsForCountdown?: bigint; // Required mints for countdown
  mintCount: bigint;              // Total mints so far
}
```

### 2. Buying on Secondary Market
```typescript
const { parameters, price, error } = await buy1155OnSecondary({
  contract: "0x...",
  tokenId: 1n,
  quantity: 3n,
  account: buyerAddress,
  slippage: 0.005,  // Optional: 0.5% default
  recipient?: "0x...", // Optional: defaults to account
  comment?: "Buying tokens", // Optional
  publicClient
});

if (error) {
  console.error("Market error:", error);
  return;
}

// Price info available
console.log("Per token (wei):", price.wei.perToken);
console.log("Total (wei):", price.wei.total);

// Execute buy transaction
await writeContract(parameters);
```

### 3. Selling on Secondary Market
```typescript
const { parameters, price, error } = await sell1155OnSecondary({
  contract: "0x...",
  tokenId: 1n,
  quantity: 3n,
  account: sellerAddress,
  slippage: 0.005,  // Optional: 0.5% default
  recipient?: "0x...", // Optional: ETH recipient
  publicClient
});

if (error) {
  console.error("Market error:", error);
  return;
}

// Price info available in wei/sparks/USDC
const usdcPrice = await price.usdc.total;
console.log("Sale value (USDC):", usdcPrice);

// Execute sell transaction
await writeContract(parameters);
```

### Secondary Market Flow

#### Creator Perspective
1. Create token with zero ETH price
2. Configure market parameters:
   - `marketCountdown`: Time window after minimum mints
   - `minimumMintsForCountdown`: Mints needed to start countdown
   - `erc20Name/Symbol`: Optional custom token naming

#### Collector Perspective
1. Check if secondary market is active:
   ```typescript
   const { secondaryMarketActive } = await getToken({...});
   const secondaryInfo = secondaryMarketActive ? 
     await getSecondaryInfo({...}) : null;
   ```
2. For buying:
   - Ensure sufficient ETH balance
   - Account for slippage
   - Handle transaction failure cases
3. For selling:
   - Verify token ownership
   - Set appropriate slippage
   - Consider gas costs

### Price Quoting
All market operations return a `QuotePrice` object:
```typescript
interface QuotePrice {
  wei: {
    perToken: bigint;
    total: bigint;
  };
  sparks: {
    perToken: bigint;
    total: bigint;
  };
  usdc: {
    perToken: Promise<number>;
    total: Promise<number>;
  };
}
```

### Error Handling
Common error cases to handle:
1. Market not active
2. Insufficient liquidity
3. Price impact too high
4. Token ownership/approval issues
5. Balance insufficient
6. Network/gas issues

## Links & References
- [Zora getToken Documentation](https://docs.zora.co/protocol-sdk/collect/getToken)
- [Zora getTokensOfContract Documentation](https://docs.zora.co/protocol-sdk/collect/getTokensOfContract)
- [Zora Mint Documentation](https://docs.zora.co/protocol-sdk/collect/mint)

## Questions to Resolve
1. How does the secondary market pricing work?
2. What are the implications of switching between pricing models?
3. How do we handle token approvals efficiently?
4. What are the best practices for handling mint failures?

---
Note: This documentation covers the core Zora protocol integration details. It will be updated as we implement and discover more functionality. 