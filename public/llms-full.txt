This file is a merged representation of the entire codebase, combined into a single document by Repomix.

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

# Directory Structure
```
public/
  assets/
    icons/
      arbitrum.svg
      base.svg
      basescan.svg
      celo.svg
      ethereum.svg
      opensea.svg
      optimism.svg
      polygon.svg
      rarible.svg
      upload.svg
src/
  abi/
    CreatorCoin
    SitusFactory.json
    SitusOG.json
    SitusResolver.json
    Zora1155proxy.json
    ZoraCoin.json
    ZoraCoinV4.json
    ZoraERC20Minter.json
  app/
    (accounts)/
      [account]/
        hold/
          page.tsx
        presence/
          page.tsx
        tend/
          page.tsx
        layout.tsx
        page.tsx
      agents/
        page.tsx
      all/
        page.tsx
      create/
        page.tsx
      mine/
        page.tsx
    admin/
      exports/
        page.tsx
      sync/
        page.tsx
      layout.tsx
      page.tsx
    api/
      0x/
        route.ts
      accounts/
        [account]/
          route.ts
        stats/
          route.ts
        route.ts
      admin/
        export/
          route.ts
        sync/
          route.ts
      alchemy/
        fungible/
          route.ts
        nonfungible/
          route.ts
      currencies/
        route.ts
      ensure/
        route.ts
      eth-price/
        route.ts
      general/
        route.ts
      groups/
        route.ts
      metadata/
        [contract]/
          [tokenId]/
            route.ts
      moralis/
        contract-sales/
          route.ts
        price-floor/
          route.ts
      pools/
        route.ts
      proceeds/
        route.ts
      search/
        route.ts
      specific/
        route.ts
      syndicates/
        route.ts
      utilities/
        image/
          route.ts
        spam/
          route.ts
    binder/
      natural-asset/
        [name]/
          page.tsx
      page.tsx
    docs/
      ensurance/
        page.mdx
      faq/
        page.mdx
      fundamentals/
        page.mdx
      natural-capital/
        page.mdx
      protocol/
        page.mdx
      technical/
        zora/
          coins.mdx
          page.mdx
        page.mdx
      tldr/
        page.mdx
      layout.tsx
      page.mdx
    ensure/
      page.tsx
    exposure/
      page.tsx
    general/
      [contract]/
        page.tsx
      page.tsx
    groups/
      [group]/
        [view]/
          page.tsx
        all/
          page.tsx
        create/
          page.tsx
        mine/
          page.tsx
        page.tsx
      page.tsx
    markets/
      page.tsx
    natural-capital/
      flows/
        page.tsx
      stocks/
        page.tsx
      layout.tsx
      metadata.ts
      page.tsx
      SearchContext.tsx
    operator/
      portfolio/
        page.tsx
    pools/
      page.tsx
    proceeds/
      [contract]/
        page.tsx
      page.tsx
    specific/
      [contract]/
        [tokenId]/
          manage/
            page.tsx
          page.tsx
      create/
        page.tsx
      page.tsx
    syndicates/
      [name]/
        page.tsx
      page.tsx
    fonts.ts
    globals.css
    layout.tsx
    not-found.tsx
    page.tsx
  components/
    analytics/
      WebAnalytics.tsx
    layout/
      verifications/
        AccountVerification.tsx
        GeneralCertificateVerification.tsx
        GroupVerification.tsx
        NftLinks.tsx
        OperatorVerification.tsx
        SpecificCertificateVerification.tsx
        VerificationSection.tsx
      AccountNavigation.tsx
      AnnouncementBanner.tsx
      ConnectOperator.tsx
      DeclarativeHero.tsx
      DeclarativeSection.tsx
      EnsureButtonsGeneral.tsx
      EnsureButtonsSpecific.tsx
      footer.tsx
      FooterNavigation.tsx
      header.tsx
      HeaderLogo.tsx
      HeaderSearch.tsx
      PageHeader.tsx
      SubNavigation.tsx
      TokenBalanceDisplay.tsx
      TokenPriceDisplay.tsx
      UtilityLinks.tsx
    ui/
      button.tsx
      card.tsx
      dialog.tsx
      dropdown-menu.tsx
      input.tsx
      select.tsx
      skeleton.tsx
      tooltip.tsx
      typewriter-effect.tsx
      typewriter-input.tsx
    ErrorBoundary.tsx
  config/
    admin.ts
    chains.ts
    routes.ts
    tokenbound.ts
    zora.ts
  hooks/
    useDebounce.ts
    useEnsureData.ts
    useIsAdmin.ts
  lib/
    database/
      admin/
        export.ts
      certificates/
        general.ts
        specific.ts
      config/
        currencies.ts
      accounts.ts
      groups.ts
      metadata.ts
      pools.ts
      proceeds.ts
    tokens/
      constants.ts
      formatting.ts
      index.ts
      types.ts
    alchemy.ts
    docs-search.ts
    ensurance.ts
    share.ts
    tokenbound.ts
    types.ts
    utils.ts
  modules/
    0x/
      executeSwap.ts
    account-modules/
      chat/
        index.tsx
      impact/
        index.tsx
      overview/
        index.tsx
      place/
        index.tsx
      portfolio/
        components/
          Card.tsx
          PortfolioGrid.tsx
          PortfolioList.tsx
        hooks/
          usePortfolioData.ts
        utils/
          getPriceFloor.ts
          getSalesData.ts
          getTokenImage.ts
        index.tsx
        types.ts
      reputation/
        index.tsx
      index.tsx
    accounts/
      AccountHeader.tsx
      AccountImage.tsx
      AccountsGrid.tsx
      AccountStats.tsx
      context.tsx
      SingleAccountImage.tsx
      SwarmAccountImage.tsx
    admin/
      sync/
        service.ts
        types.ts
    assets/
      AssetSearch.tsx
    ensure/
      buttons/
        accounts/
          index.ts
          operator.ts
          tokenbound.ts
        hooks/
          useOperations.ts
        modals/
          burn.tsx
          buy.tsx
          send.tsx
          swap.tsx
        operations/
          erc1155.ts
          erc20.ts
          erc721.ts
          index.ts
          native.ts
          types.ts
        utils/
          formatting.ts
          images.ts
          index.ts
          input.ts
          notifications.ts
          permit2.ts
          tooltips.ts
        EnsureButtons.tsx
        EnsureButtonsDetails.tsx
        index.ts
        types.ts
      EnsureGrid.tsx
      EnsureMagnet.tsx
      ensurePhrases.ts
      EnsureTooltip.tsx
      MagnetSearch.tsx
    exposure/
      assetMapping.ts
      data.tsx
      ExposureSankey.tsx
    general/
      service/
        hooks.ts
        index.ts
        types.ts
      Details.tsx
      GeneralGrid.tsx
      GeneralList.tsx
      GeneralMarketSummary.tsx
    groups/
      GroupGrid.tsx
      GroupInfo.tsx
      GroupLinks.tsx
      GroupSelector.tsx
      GroupStats.tsx
    home-page/
      cta/
        CTA.tsx
      ensure/
        Ensure.tsx
      proof/
        Proof.tsx
      risk-to-resilience/
        RiskToResilience.tsx
      solution/
        Solution.tsx
      truth/
        Truth.tsx
    media/
      CustomAudioPlayer.tsx
    metadata/
      ImageGenerator.ts
    natural-capital/
      NaturalCapitalGrid.tsx
    proceeds/
      components/
        viewer/
          ProceedsBubbles.tsx
          ProceedsNode.tsx
          ProceedsViewer.tsx
        Proceeds.tsx
        TotalProceedsBar.tsx
      index.ts
    rewards/
      RewardsLink.tsx
    shared/
      ChainDropdown.tsx
      HomeSwarm.tsx
    specific/
      callSale.ts
      callSaleInitial.ts
      collect.ts
      config.ts
      create.ts
      manage.ts
      SpecificAsset.tsx
      SpecificGrid.tsx
      SpecificList.tsx
      SpecificMarketSummary.tsx
      types.ts
    syndicates/
      SyndicateGrid.tsx
  providers/
    privy-provider.tsx
    splits-provider.tsx
  types/
    index.ts
  mdx-components.tsx
  middleware.ts
.cursorrules
.gitignore
CONTRIBUTING.md
LICENSE
next.config.mjs
package.json
postcss.config.js
README.md
SECURITY.md
tailwind.config.js
tsconfig.json
```

# Files

## File: public/assets/icons/arbitrum.svg
````
<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns:xodm="http://www.corel.com/coreldraw/odm/2003" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="Layer_1" x="0px" y="0px" viewBox="0 0 2500 2500" style="enable-background:new 0 0 2500 2500;" xml:space="preserve">
<style type="text/css">
	.st0{fill:none;}
	.st1{fill:#213147;}
	.st2{fill:#12AAFF;}
	.st3{fill:#9DCCED;}
	.st4{fill:#FFFFFF;}
</style>
<g id="Layer_x0020_1">
	<g id="_2405588477232">
		<rect class="st0" width="2500" height="2500"></rect>
		<g>
			<g>
				<path class="st1" d="M226,760v980c0,63,33,120,88,152l849,490c54,31,121,31,175,0l849-490c54-31,88-89,88-152V760      c0-63-33-120-88-152l-849-490c-54-31-121-31-175,0L314,608c-54,31-87,89-87,152H226z"></path>
				<g>
					<g>
						<g>
							<path class="st2" d="M1435,1440l-121,332c-3,9-3,19,0,29l208,571l241-139l-289-793C1467,1422,1442,1422,1435,1440z"></path>
						</g>
						<g>
							<path class="st2" d="M1678,882c-7-18-32-18-39,0l-121,332c-3,9-3,19,0,29l341,935l241-139L1678,883V882z"></path>
						</g>
					</g>
				</g>
				<g>
					<path class="st3" d="M1250,155c6,0,12,2,17,5l918,530c11,6,17,18,17,30v1060c0,12-7,24-17,30l-918,530c-5,3-11,5-17,5       s-12-2-17-5l-918-530c-11-6-17-18-17-30V719c0-12,7-24,17-30l918-530c5-3,11-5,17-5l0,0V155z M1250,0c-33,0-65,8-95,25L237,555       c-59,34-95,96-95,164v1060c0,68,36,130,95,164l918,530c29,17,62,25,95,25s65-8,95-25l918-530c59-34,95-96,95-164V719       c0-68-36-130-95-164L1344,25c-29-17-62-25-95-25l0,0H1250z"></path>
				</g>
				<polygon class="st1" points="642,2179 727,1947 897,2088 738,2234     "></polygon>
				<g>
					<path class="st4" d="M1172,644H939c-17,0-33,11-39,27L401,2039l241,139l550-1507c5-14-5-28-19-28L1172,644z"></path>
					<path class="st4" d="M1580,644h-233c-17,0-33,11-39,27L738,2233l241,139l620-1701c5-14-5-28-19-28V644z"></path>
				</g>
			</g>
		</g>
	</g>
</g>
</svg>
````

## File: public/assets/icons/base.svg
````
<svg width="146" height="146" viewBox="0 0 146 146" fill="none" xmlns="http://www.w3.org/2000/svg">
<circle cx="73" cy="73" r="73" fill="#0052FF"/>
<path d="M73.323 123.729C101.617 123.729 124.553 100.832 124.553 72.5875C124.553 44.343 101.617 21.4463 73.323 21.4463C46.4795 21.4463 24.4581 42.0558 22.271 68.2887H89.9859V76.8864H22.271C24.4581 103.119 46.4795 123.729 73.323 123.729Z" fill="white"/>
</svg>
````

## File: public/assets/icons/basescan.svg
````
<svg width="155" height="154" viewBox="0 0 155 154" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M32.856 73.722C32.8562 72.8665 33.0253 72.0195 33.3538 71.2295C33.6822 70.4396 34.1634 69.7223 34.7698 69.1188C35.3762 68.5154 36.0958 68.0376 36.8873 67.713C37.6789 67.3884 38.5267 67.2234 39.3822 67.2274L50.2024 67.2626C51.9276 67.2626 53.5821 67.948 54.802 69.1678C56.0218 70.3877 56.7072 72.0422 56.7072 73.7674V114.68C57.9252 114.319 59.4897 113.933 61.2015 113.53C62.3906 113.251 63.4504 112.578 64.2089 111.621C64.9674 110.663 65.38 109.478 65.3798 108.256V57.5055C65.3798 55.7802 66.065 54.1256 67.2848 52.9055C68.5047 51.6855 70.1592 50.9999 71.8845 50.9995H82.7261C84.4514 50.9999 86.1059 51.6855 87.3258 52.9055C88.5456 54.1256 89.2309 55.7802 89.2309 57.5055V104.607C89.2309 104.607 91.9454 103.509 94.5894 102.393C95.5716 101.977 96.4097 101.282 96.9993 100.393C97.5889 99.5045 97.9038 98.462 97.9047 97.3955V41.2437C97.9047 39.5187 98.5898 37.8644 99.8094 36.6446C101.029 35.4247 102.683 34.7393 104.408 34.7389H115.25C116.975 34.7389 118.63 35.4243 119.849 36.6441C121.069 37.864 121.755 39.5185 121.755 41.2437V87.4835C131.154 80.6714 140.679 72.4788 148.238 62.6272C149.335 61.1972 150.061 59.5181 150.35 57.7396C150.64 55.9611 150.485 54.1384 149.9 52.4343C146.401 42.367 140.839 33.141 133.57 25.3467C126.301 17.5524 117.484 11.3614 107.685 7.16992C97.886 2.97846 87.3197 0.878835 76.6625 1.0054C66.0053 1.13196 55.4918 3.48194 45.795 7.90493C36.0981 12.3279 27.4313 18.7265 20.3493 26.6913C13.2673 34.656 7.92599 44.0115 4.66718 54.159C1.40838 64.3066 0.303866 75.0226 1.42431 85.6215C2.54475 96.2205 5.86549 106.469 11.174 115.711C12.0988 117.305 13.4592 118.602 15.0956 119.45C16.7321 120.298 18.5764 120.661 20.4121 120.497C22.4628 120.317 25.0161 120.061 28.0518 119.705C29.3733 119.555 30.5934 118.924 31.4796 117.932C32.3658 116.941 32.8562 115.658 32.8573 114.328V73.722" fill="#0A0B0D"/>
<path d="M32.856 73.722C32.8562 72.8665 33.0253 72.0195 33.3538 71.2295C33.6822 70.4396 34.1634 69.7223 34.7698 69.1188C35.3762 68.5154 36.0958 68.0376 36.8873 67.713C37.6789 67.3884 38.5267 67.2234 39.3822 67.2274L50.2024 67.2626C51.9276 67.2626 53.5821 67.948 54.802 69.1678C56.0218 70.3877 56.7072 72.0422 56.7072 73.7674V114.68C57.9252 114.319 59.4897 113.933 61.2015 113.53C62.3906 113.251 63.4504 112.578 64.2089 111.621C64.9674 110.663 65.38 109.478 65.3798 108.256V57.5055C65.3798 55.7802 66.065 54.1256 67.2848 52.9055C68.5047 51.6855 70.1592 50.9999 71.8845 50.9995H82.7261C84.4514 50.9999 86.1059 51.6855 87.3258 52.9055C88.5456 54.1256 89.2309 55.7802 89.2309 57.5055V104.607C89.2309 104.607 91.9454 103.509 94.5894 102.393C95.5716 101.977 96.4097 101.282 96.9993 100.393C97.5889 99.5045 97.9038 98.462 97.9047 97.3955V41.2437C97.9047 39.5187 98.5898 37.8644 99.8094 36.6446C101.029 35.4247 102.683 34.7393 104.408 34.7389H115.25C116.975 34.7389 118.63 35.4243 119.849 36.6441C121.069 37.864 121.755 39.5185 121.755 41.2437V87.4835C131.154 80.6714 140.679 72.4788 148.238 62.6272C149.335 61.1972 150.061 59.5181 150.35 57.7396C150.64 55.9611 150.485 54.1384 149.9 52.4343C146.401 42.367 140.839 33.141 133.57 25.3467C126.301 17.5524 117.484 11.3614 107.685 7.16992C97.886 2.97846 87.3197 0.878835 76.6625 1.0054C66.0053 1.13196 55.4918 3.48194 45.795 7.90493C36.0981 12.3279 27.4313 18.7265 20.3493 26.6913C13.2673 34.656 7.92599 44.0115 4.66718 54.159C1.40838 64.3066 0.303866 75.0226 1.42431 85.6215C2.54475 96.2205 5.86549 106.469 11.174 115.711C12.0988 117.305 13.4592 118.602 15.0956 119.45C16.7321 120.298 18.5764 120.661 20.4121 120.497C22.4628 120.317 25.0161 120.061 28.0518 119.705C29.3733 119.555 30.5934 118.924 31.4796 117.932C32.3658 116.941 32.8562 115.658 32.8573 114.328V73.722" stroke="white"/>
<path d="M32.6191 139.343C44.047 147.657 57.5522 152.647 71.6404 153.761C85.7285 154.876 99.8504 152.071 112.443 145.658C125.036 139.244 135.61 129.471 142.993 117.421C150.376 105.371 154.282 91.5135 154.278 77.3813C154.278 75.6178 154.196 73.8732 154.079 72.1387C126.091 113.88 74.415 133.395 32.6217 139.336" fill="#C0D0DB"/>
</svg>
````

## File: public/assets/icons/celo.svg
````
<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns:xodm="http://www.corel.com/coreldraw/odm/2003" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="Layer_1" x="0px" y="0px" viewBox="0 0 2500 2500" style="enable-background:new 0 0 2500 2500;" xml:space="preserve">
<style type="text/css">
	.st0{fill-rule:evenodd;clip-rule:evenodd;fill:#FCFF52;}
	.st1{fill-rule:evenodd;clip-rule:evenodd;}
</style>
<g id="Layer_x0020_1">
	<g id="_1942792544736">
		<circle class="st0" cx="1250" cy="1250" r="1250"></circle>
		<path class="st1" d="M1949.3,546.2H550.7v1407.7h1398.7v-491.4h-232.1c-80,179.3-260.1,304.1-466.2,304.1    c-284.1,0-514.2-233.6-514.2-517.5c0-284,230.1-515.6,514.2-515.6c210.1,0,390.2,128.9,470.2,312.1h228.1V546.2z"></path>
	</g>
</g>
</svg>
````

## File: public/assets/icons/ethereum.svg
````
<?xml version="1.0" encoding="utf-8"?>
<!-- Generator: Adobe Illustrator 26.0.1, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 viewBox="0 0 327.5 533.3" style="enable-background:new 0 0 327.5 533.3;" xml:space="preserve">
<style type="text/css">
	.st0{fill:#8A92B2;}
	.st1{fill:#62688F;}
	.st2{fill:#454A75;}
</style>
<path class="st0" d="M163.7,197.2V0L0,271.6L163.7,197.2z"/>
<path class="st1" d="M163.7,368.4V197.2L0,271.6L163.7,368.4z M163.7,197.2l163.7,74.4L163.7,0V197.2z"/>
<path class="st2" d="M163.7,197.2v171.2l163.7-96.8L163.7,197.2z"/>
<path class="st0" d="M163.7,399.4L0,302.7l163.7,230.7V399.4z"/>
<path class="st1" d="M327.5,302.7l-163.8,96.7v134L327.5,302.7z"/>
</svg>
````

## File: public/assets/icons/opensea.svg
````
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg xmlns="http://www.w3.org/2000/svg" width="63.250889mm" height="63.250889mm" viewBox="0 0 63.250886 63.250888">
  <g fill="none" transform="scale(.6325)">
    <path fill="#2081e2" d="M100 50c0 27.6127-22.3873 50-50 50S0 77.6127 0 50 22.3873 0 50 0c27.6185 0 50 22.3873 50 50z"/>
    <path fill="#fff" d="m24.6679 51.6801.2157-.3391 13.007-20.3478c.1901-.2979.637-.2671.7808.0565 2.173 4.8699 4.048 10.9265 3.1696 14.6971-.375 1.5514-1.4024 3.6524-2.5583 5.5942-.1489.2826-.3133.56-.488.8271-.0822.1233-.2209.1952-.3699.1952H25.048c-.3596 0-.5702-.3904-.3801-.6832z"/>
    <path fill="#fff" d="M82.6444 55.461v3.2209c0 .1849-.113.3493-.2774.4212-1.0068.4315-4.4538 2.0137-5.887 4.0069-3.6576 5.0908-6.4521 12.37-12.6988 12.37H37.721C28.4847 75.48 21 67.9697 21 58.7024v-.2979c0-.2466.2003-.4469.4469-.4469h14.5276c.2876 0 .4982.2671.4726.5496-.1028.9452.0719 1.911.5188 2.7894.863 1.7518 2.6507 2.846 4.5822 2.846H48.74v-5.6148h-7.1097c-.3647 0-.5804-.4213-.3698-.7192.077-.1182.1644-.2414.2568-.3801.673-.9555 1.6336-2.4401 2.5891-4.1302.6524-1.1404 1.2842-2.3579 1.7928-3.5805.1028-.2209.1849-.447.2671-.6679.1387-.3904.2826-.7551.3853-1.1198.1028-.3083.1849-.6319.2671-.935.2415-1.0377.3442-2.137.3442-3.2774 0-.4469-.0205-.9144-.0616-1.3613-.0206-.488-.0822-.9761-.1439-1.4641-.0411-.4315-.1181-.8579-.2003-1.3048-.1027-.6524-.2466-1.2996-.411-1.9521l-.0565-.2465c-.1233-.447-.226-.8733-.3698-1.3202-.4059-1.4025-.8733-2.7689-1.3665-4.048-.1798-.5086-.3853-.9966-.5908-1.4846-.303-.7346-.6113-1.4024-.8938-2.0343-.1438-.2877-.2671-.5497-.3904-.8168-.1387-.3031-.2825-.6062-.4264-.8938-.1027-.2209-.2209-.4264-.3031-.6319l-.8784-1.6233c-.1233-.2209.0822-.4829.3236-.4161l5.4967 1.4897h.0154c.0102 0 .0154.0052.0205.0052l.7243.2003.7963.2261.2928.0821v-3.2671C48.74 21.2791 50.0037 20 51.5654 20c.7808 0 1.4897.3185 1.9983.8373.5085.5189.827 1.2278.827 2.0189v4.8494l.5857.1643c.0462.0155.0924.036.1335.0668.1439.1079.3493.2671.6113.4624.2055.1643.4264.3647.6935.5702.5291.4263 1.161.976 1.8545 1.6079.1849.1592.3647.3236.5291.488.8939.8322 1.8956 1.8082 2.8511 2.887.2671.3031.5291.6113.7962.9349.2671.3288.5497.6524.7962.9761.3237.4315.673.8784.9761 1.3459.1438.2209.3082.4469.4469.6678.3904.5907.7346 1.2021 1.0634 1.8134.1387.2825.2825.5907.4058.8938.3647.8168.6524 1.649.8373 2.4812.0565.1798.0976.375.1182.5497v.0411c.0616.2465.0822.5085.1027.7756.0822.8528.0411 1.7055-.1438 2.5634-.0771.3648-.1798.7089-.3031 1.0737-.1233.3493-.2466.714-.4058 1.0582-.3082.714-.673 1.4281-1.1045 2.0959-.1387.2466-.3031.5086-.4675.7552-.1798.2619-.3647.5085-.5291.75-.226.3082-.4674.6318-.714.9195-.2209.3031-.4469.6062-.6935.8733-.3442.4058-.673.7911-1.0172 1.161-.2054.2414-.4263.488-.6524.7089-.2208.2465-.4469.4674-.6524.6729-.3441.3442-.6318.6113-.8733.8322l-.565.5189c-.0822.0719-.1901.113-.3031.113h-4.3768v5.6148h5.5069c1.2329 0 2.4042-.4367 3.3494-1.2381.3236-.2825 1.7363-1.5051 3.4058-3.3493.0565-.0617.1285-.1079.2107-.1284l15.2107-4.3973c.2826-.0822.5702.1335.5702.4315z"/>
  </g>
</svg>
````

## File: public/assets/icons/optimism.svg
````
<?xml version="1.0" encoding="utf-8"?>
<!-- Generator: Adobe Illustrator 26.0.1, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 viewBox="0 0 500 500" style="enable-background:new 0 0 500 500;" xml:space="preserve">
<style type="text/css">
	.st0{fill:#FF0420;}
	.st1{fill:#FFFFFF;}
</style>
<circle class="st0" cx="250" cy="250" r="250"/>
<path class="st1" d="M177.1,316.4c-14.9,0-27.1-3.5-36.6-10.5c-9.4-7.1-14.1-17.3-14.1-30.4c0-2.8,0.3-6.1,0.9-10.1
	c1.6-9,3.9-19.8,6.9-32.5c8.5-34.4,30.5-51.6,65.9-51.6c9.6,0,18.3,1.6,25.9,4.9c7.6,3.1,13.6,7.9,18,14.3
	c4.4,6.3,6.6,13.8,6.6,22.5c0,2.6-0.3,5.9-0.9,9.9c-1.9,11.1-4.1,22-6.8,32.5c-4.4,17.1-11.9,30-22.7,38.5
	C209.5,312.3,195.1,316.4,177.1,316.4z M179.8,289.4c7,0,12.9-2.1,17.8-6.2c5-4.1,8.6-10.4,10.7-19c2.9-11.8,5.1-22,6.6-30.8
	c0.5-2.6,0.8-5.3,0.8-8.1c0-11.4-5.9-17.1-17.8-17.1c-7,0-13,2.1-18,6.2c-4.9,4.1-8.4,10.4-10.5,19c-2.3,8.4-4.5,18.6-6.8,30.8
	c-0.5,2.5-0.8,5.1-0.8,7.9C161.7,283.7,167.8,289.4,179.8,289.4z"/>
<path class="st1" d="M259.3,314.6c-1.4,0-2.4-0.4-3.2-1.3c-0.6-1-0.8-2.1-0.6-3.4l25.9-122c0.2-1.4,0.9-2.5,2.1-3.4
	c1.1-0.9,2.3-1.3,3.6-1.3H337c13.9,0,25,2.9,33.4,8.6c8.5,5.8,12.8,14.1,12.8,25c0,3.1-0.4,6.4-1.1,9.8c-3.1,14.4-9.4,25-19,31.9
	c-9.4,6.9-22.3,10.3-38.7,10.3h-25.3l-8.6,41.1c-0.3,1.4-0.9,2.5-2.1,3.4c-1.1,0.9-2.3,1.3-3.6,1.3H259.3z M325.7,242.9
	c5.3,0,9.8-1.4,13.7-4.3c4-2.9,6.6-7,7.9-12.4c0.4-2.1,0.6-4,0.6-5.6c0-3.6-1.1-6.4-3.2-8.3c-2.1-2-5.8-3-10.9-3h-22.5l-7.1,33.6
	H325.7z"/>
</svg>
````

## File: public/assets/icons/polygon.svg
````
<?xml version="1.0" encoding="utf-8"?>
<!-- Generator: Adobe Illustrator 24.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 viewBox="0 0 178 161" style="enable-background:new 0 0 178 161;" xml:space="preserve">
<style type="text/css">
	.st0{fill:#6C00F6;}
</style>
<path class="st0" d="M66.8,54.7l-16.7-9.7L0,74.1v58l50.1,29l50.1-29V41.9L128,25.8l27.8,16.1v32.2L128,90.2l-16.7-9.7v25.8
	l16.7,9.7l50.1-29V29L128,0L77.9,29v90.2l-27.8,16.1l-27.8-16.1V86.9l27.8-16.1l16.7,9.7V54.7z"/>
</svg>
````

## File: public/assets/icons/rarible.svg
````
<svg fill="none" height="48" viewBox="0 0 49 48" width="49" xmlns="http://www.w3.org/2000/svg"><path d="m.0966797 10.4931c0-5.79516 4.7127903-10.4931 10.5263203-10.4931h26.9474c5.8135 0 10.5263 4.69794 10.5263 10.4931v26.8625c0 5.7952-4.7128 10.4931-10.5263 10.4931h-26.9474c-5.81353 0-10.5263203-4.6979-10.5263203-10.4931z" fill="#feda03"/><path clip-rule="evenodd" d="m36.1418 20.0308c0 2.2953-1.341 3.437-2.8481 3.8336 1.8038.5407 3.1092 2.0189 3.1092 4.3622v4.3022h-6.883v-4.0859c0-1.2498-.7358-1.7545-1.9937-1.7545h-8.1647v5.8404h-6.883v-17.2087h16.3531c4.106 0 7.3102.8892 7.3102 4.7107zm-16.7772.0972h9.305v.0008c.0139-.0005.0279-.0008.0419-.0008.6398 0 1.1585.5252 1.1585 1.1732 0 .6479-.5187 1.1731-1.1585 1.1731-.014 0-.028-.0002-.0419-.0007v.0007h-9.305z" fill="#000" fill-rule="evenodd"/></svg>
````

## File: public/assets/icons/upload.svg
````
<?xml version="1.0" encoding="utf-8"?><!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg width="800px" height="800px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M4.25 5C4.25 3.48122 5.48122 2.25 7 2.25H14.9868C15.5506 2.25 16.0798 2.52157 16.4085 2.97955L19.4217 7.17745C19.6352 7.47488 19.75 7.83178 19.75 8.1979V19C19.75 20.5188 18.5188 21.75 17 21.75H7C5.48122 21.75 4.25 20.5188 4.25 19V5ZM7 3.75C6.30964 3.75 5.75 4.30964 5.75 5V19C5.75 19.6904 6.30964 20.25 7 20.25H17C17.6904 20.25 18.25 19.6904 18.25 19V8.89705H15C14.5858 8.89705 14.25 8.56126 14.25 8.14705V3.75H7Z" fill="#000000"/>
<path d="M15.0857 13.2185C14.8269 13.542 14.355 13.5944 14.0315 13.3357L12.7501 12.3105V15.75C12.7501 16.1642 12.4143 16.5 12.0001 16.5C11.5858 16.5 11.2501 16.1642 11.2501 15.75V12.3104L9.96855 13.3357C9.6451 13.5944 9.17313 13.542 8.91438 13.2185C8.65562 12.8951 8.70806 12.4231 9.03151 12.1643L11.5288 10.1665C11.6561 10.0636 11.8177 10.0015 11.9937 10C11.9958 10 11.9979 10 12.0001 10L12.0025 10C12.1816 10.0006 12.3459 10.0639 12.4746 10.1692L14.9685 12.1643C15.292 12.4231 15.3444 12.8951 15.0857 13.2185Z" fill="#000000"/>
</svg>
````

## File: src/abi/CreatorCoin
````
[{"inputs":[{"internalType":"address","name":"_protocolRewardRecipient","type":"address"},{"internalType":"address","name":"_protocolRewards","type":"address"},{"internalType":"contract IPoolManager","name":"_poolManager","type":"address"},{"internalType":"address","name":"_airlock","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[],"name":"AddressZero","type":"error"},{"inputs":[],"name":"AlreadyOwner","type":"error"},{"inputs":[],"name":"CannotMintZeroLiquidity","type":"error"},{"inputs":[],"name":"DopplerPoolMustHaveMoreThan2DiscoveryPositions","type":"error"},{"inputs":[],"name":"ECDSAInvalidSignature","type":"error"},{"inputs":[{"internalType":"uint256","name":"length","type":"uint256"}],"name":"ECDSAInvalidSignatureLength","type":"error"},{"inputs":[{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"ECDSAInvalidSignatureS","type":"error"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"allowance","type":"uint256"},{"internalType":"uint256","name":"needed","type":"uint256"}],"name":"ERC20InsufficientAllowance","type":"error"},{"inputs":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"uint256","name":"balance","type":"uint256"},{"internalType":"uint256","name":"needed","type":"uint256"}],"name":"ERC20InsufficientBalance","type":"error"},{"inputs":[{"internalType":"address","name":"approver","type":"address"}],"name":"ERC20InvalidApprover","type":"error"},{"inputs":[{"internalType":"address","name":"receiver","type":"address"}],"name":"ERC20InvalidReceiver","type":"error"},{"inputs":[{"internalType":"address","name":"sender","type":"address"}],"name":"ERC20InvalidSender","type":"error"},{"inputs":[{"internalType":"address","name":"spender","type":"address"}],"name":"ERC20InvalidSpender","type":"error"},{"inputs":[],"name":"ERC20TransferAmountMismatch","type":"error"},{"inputs":[{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"ERC2612ExpiredSignature","type":"error"},{"inputs":[{"internalType":"address","name":"signer","type":"address"},{"internalType":"address","name":"owner","type":"address"}],"name":"ERC2612InvalidSigner","type":"error"},{"inputs":[],"name":"EthAmountMismatch","type":"error"},{"inputs":[],"name":"EthAmountTooSmall","type":"error"},{"inputs":[],"name":"EthTransferFailed","type":"error"},{"inputs":[],"name":"EthTransferInvalid","type":"error"},{"inputs":[],"name":"InitialOrderSizeTooLarge","type":"error"},{"inputs":[],"name":"InsufficientFunds","type":"error"},{"inputs":[],"name":"InsufficientLiquidity","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"currentNonce","type":"uint256"}],"name":"InvalidAccountNonce","type":"error"},{"inputs":[],"name":"InvalidCurrency","type":"error"},{"inputs":[],"name":"InvalidCurrencyLowerTick","type":"error"},{"inputs":[],"name":"InvalidInitialization","type":"error"},{"inputs":[],"name":"InvalidMarketType","type":"error"},{"inputs":[],"name":"InvalidPoolVersion","type":"error"},{"inputs":[{"internalType":"int24","name":"tickLower","type":"int24"},{"internalType":"int24","name":"tickUpper","type":"int24"}],"name":"InvalidTickRangeMisordered","type":"error"},{"inputs":[],"name":"InvalidWethLowerTick","type":"error"},{"inputs":[],"name":"LegacyPoolMustHaveOneDiscoveryPosition","type":"error"},{"inputs":[],"name":"MarketAlreadyGraduated","type":"error"},{"inputs":[],"name":"MarketNotGraduated","type":"error"},{"inputs":[{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"uint256","name":"limit","type":"uint256"}],"name":"MaxShareToBeSoldExceeded","type":"error"},{"inputs":[],"name":"NameIsRequired","type":"error"},{"inputs":[],"name":"NotInitializing","type":"error"},{"inputs":[],"name":"NotOwner","type":"error"},{"inputs":[],"name":"NumDiscoveryPositionsOutOfRange","type":"error"},{"inputs":[],"name":"OneOwnerRequired","type":"error"},{"inputs":[],"name":"OnlyOwner","type":"error"},{"inputs":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"address","name":"pool","type":"address"}],"name":"OnlyPool","type":"error"},{"inputs":[],"name":"OnlyWeth","type":"error"},{"inputs":[],"name":"OwnerCannotBeAddressZero","type":"error"},{"inputs":[],"name":"ReentrancyGuardReentrantCall","type":"error"},{"inputs":[],"name":"SlippageBoundsExceeded","type":"error"},{"inputs":[],"name":"UseRevokeOwnershipToRemoveSelf","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"buyer","type":"address"},{"indexed":true,"internalType":"address","name":"recipient","type":"address"},{"indexed":true,"internalType":"address","name":"tradeReferrer","type":"address"},{"indexed":false,"internalType":"uint256","name":"coinsPurchased","type":"uint256"},{"indexed":false,"internalType":"address","name":"currency","type":"address"},{"indexed":false,"internalType":"uint256","name":"amountFee","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amountSold","type":"uint256"}],"name":"CoinBuy","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"payoutRecipient","type":"address"},{"indexed":true,"internalType":"address","name":"platformReferrer","type":"address"},{"indexed":false,"internalType":"address","name":"protocolRewardRecipient","type":"address"},{"indexed":false,"internalType":"address","name":"currency","type":"address"},{"components":[{"internalType":"uint256","name":"totalAmountCurrency","type":"uint256"},{"internalType":"uint256","name":"totalAmountCoin","type":"uint256"},{"internalType":"uint256","name":"creatorPayoutAmountCurrency","type":"uint256"},{"internalType":"uint256","name":"creatorPayoutAmountCoin","type":"uint256"},{"internalType":"uint256","name":"platformReferrerAmountCurrency","type":"uint256"},{"internalType":"uint256","name":"platformReferrerAmountCoin","type":"uint256"},{"internalType":"uint256","name":"protocolAmountCurrency","type":"uint256"},{"internalType":"uint256","name":"protocolAmountCoin","type":"uint256"}],"indexed":false,"internalType":"struct ICoin.MarketRewards","name":"marketRewards","type":"tuple"}],"name":"CoinMarketRewards","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"caller","type":"address"},{"indexed":true,"internalType":"address","name":"prevRecipient","type":"address"},{"indexed":true,"internalType":"address","name":"newRecipient","type":"address"}],"name":"CoinPayoutRecipientUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"seller","type":"address"},{"indexed":true,"internalType":"address","name":"recipient","type":"address"},{"indexed":true,"internalType":"address","name":"tradeReferrer","type":"address"},{"indexed":false,"internalType":"uint256","name":"coinsSold","type":"uint256"},{"indexed":false,"internalType":"address","name":"currency","type":"address"},{"indexed":false,"internalType":"uint256","name":"amountFee","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amountPurchased","type":"uint256"}],"name":"CoinSell","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"payoutRecipient","type":"address"},{"indexed":true,"internalType":"address","name":"platformReferrer","type":"address"},{"indexed":true,"internalType":"address","name":"tradeReferrer","type":"address"},{"indexed":false,"internalType":"address","name":"protocolRewardRecipient","type":"address"},{"indexed":false,"internalType":"uint256","name":"creatorReward","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"platformReferrerReward","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"traderReferrerReward","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"protocolReward","type":"uint256"},{"indexed":false,"internalType":"address","name":"currency","type":"address"}],"name":"CoinTradeRewards","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":true,"internalType":"address","name":"recipient","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"senderBalance","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"recipientBalance","type":"uint256"}],"name":"CoinTransfer","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"caller","type":"address"},{"indexed":false,"internalType":"string","name":"newURI","type":"string"},{"indexed":false,"internalType":"string","name":"name","type":"string"}],"name":"ContractMetadataUpdated","type":"event"},{"anonymous":false,"inputs":[],"name":"ContractURIUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"recipient","type":"address"},{"indexed":false,"internalType":"uint256","name":"claimAmount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"totalClaimed","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"vestingStartTime","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"vestingEndTime","type":"uint256"}],"name":"CreatorVestingClaimed","type":"event"},{"anonymous":false,"inputs":[],"name":"EIP712DomainChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint64","name":"version","type":"uint64"}],"name":"Initialized","type":"event"},{"anonymous":false,"inputs":[{"components":[{"internalType":"Currency","name":"currency0","type":"address"},{"internalType":"Currency","name":"currency1","type":"address"},{"internalType":"uint24","name":"fee","type":"uint24"},{"internalType":"int24","name":"tickSpacing","type":"int24"},{"internalType":"contract IHooks","name":"hooks","type":"address"}],"indexed":false,"internalType":"struct PoolKey","name":"fromPoolKey","type":"tuple"},{"indexed":false,"internalType":"bytes32","name":"fromPoolKeyHash","type":"bytes32"},{"components":[{"internalType":"Currency","name":"currency0","type":"address"},{"internalType":"Currency","name":"currency1","type":"address"},{"internalType":"uint24","name":"fee","type":"uint24"},{"internalType":"int24","name":"tickSpacing","type":"int24"},{"internalType":"contract IHooks","name":"hooks","type":"address"}],"indexed":false,"internalType":"struct PoolKey","name":"toPoolKey","type":"tuple"},{"indexed":false,"internalType":"bytes32","name":"toPoolKeyHash","type":"bytes32"}],"name":"LiquidityMigrated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"caller","type":"address"},{"indexed":false,"internalType":"string","name":"newName","type":"string"},{"indexed":false,"internalType":"string","name":"newSymbol","type":"string"}],"name":"NameAndSymbolUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"caller","type":"address"},{"indexed":true,"internalType":"address","name":"prevOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnerUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[],"name":"DOMAIN_SEPARATOR","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"addOwner","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address[]","name":"accounts","type":"address[]"}],"name":"addOwners","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"airlock","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"burn","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"claimVesting","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"contractURI","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"contractVersion","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"currency","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"dopplerFeeRecipient","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"eip712Domain","outputs":[{"internalType":"bytes1","name":"fields","type":"bytes1"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"version","type":"string"},{"internalType":"uint256","name":"chainId","type":"uint256"},{"internalType":"address","name":"verifyingContract","type":"address"},{"internalType":"bytes32","name":"salt","type":"bytes32"},{"internalType":"uint256[]","name":"extensions","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getClaimableAmount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IDeployedCoinVersionLookup","name":"coinVersionLookup","type":"address"}],"name":"getPayoutSwapPath","outputs":[{"components":[{"components":[{"internalType":"Currency","name":"intermediateCurrency","type":"address"},{"internalType":"uint24","name":"fee","type":"uint24"},{"internalType":"int24","name":"tickSpacing","type":"int24"},{"internalType":"contract IHooks","name":"hooks","type":"address"},{"internalType":"bytes","name":"hookData","type":"bytes"}],"internalType":"struct PathKey[]","name":"path","type":"tuple[]"},{"internalType":"Currency","name":"currencyIn","type":"address"}],"internalType":"struct IHasSwapPath.PayoutSwapPath","name":"payoutSwapPath","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getPoolConfiguration","outputs":[{"components":[{"internalType":"uint8","name":"version","type":"uint8"},{"internalType":"uint16","name":"numPositions","type":"uint16"},{"internalType":"uint24","name":"fee","type":"uint24"},{"internalType":"int24","name":"tickSpacing","type":"int24"},{"internalType":"uint16[]","name":"numDiscoveryPositions","type":"uint16[]"},{"internalType":"int24[]","name":"tickLower","type":"int24[]"},{"internalType":"int24[]","name":"tickUpper","type":"int24[]"},{"internalType":"uint256[]","name":"maxDiscoverySupplyShare","type":"uint256[]"}],"internalType":"struct PoolConfiguration","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getPoolKey","outputs":[{"components":[{"internalType":"Currency","name":"currency0","type":"address"},{"internalType":"Currency","name":"currency1","type":"address"},{"internalType":"uint24","name":"fee","type":"uint24"},{"internalType":"int24","name":"tickSpacing","type":"int24"},{"internalType":"contract IHooks","name":"hooks","type":"address"}],"internalType":"struct PoolKey","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"hooks","outputs":[{"internalType":"contract IHooks","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"payoutRecipient_","type":"address"},{"internalType":"address[]","name":"owners_","type":"address[]"},{"internalType":"string","name":"tokenURI_","type":"string"},{"internalType":"string","name":"name_","type":"string"},{"internalType":"string","name":"symbol_","type":"string"},{"internalType":"address","name":"platformReferrer_","type":"address"},{"internalType":"address","name":"currency_","type":"address"},{"components":[{"internalType":"Currency","name":"currency0","type":"address"},{"internalType":"Currency","name":"currency1","type":"address"},{"internalType":"uint24","name":"fee","type":"uint24"},{"internalType":"int24","name":"tickSpacing","type":"int24"},{"internalType":"contract IHooks","name":"hooks","type":"address"}],"internalType":"struct PoolKey","name":"poolKey_","type":"tuple"},{"internalType":"uint160","name":"sqrtPriceX96","type":"uint160"},{"components":[{"internalType":"uint8","name":"version","type":"uint8"},{"internalType":"uint16","name":"numPositions","type":"uint16"},{"internalType":"uint24","name":"fee","type":"uint24"},{"internalType":"int24","name":"tickSpacing","type":"int24"},{"internalType":"uint16[]","name":"numDiscoveryPositions","type":"uint16[]"},{"internalType":"int24[]","name":"tickLower","type":"int24[]"},{"internalType":"int24[]","name":"tickUpper","type":"int24[]"},{"internalType":"uint256[]","name":"maxDiscoverySupplyShare","type":"uint256[]"}],"internalType":"struct PoolConfiguration","name":"poolConfiguration_","type":"tuple"}],"name":"initialize","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"isOwner","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"newHook","type":"address"},{"internalType":"bytes","name":"additionalData","type":"bytes"}],"name":"migrateLiquidity","outputs":[{"components":[{"internalType":"Currency","name":"currency0","type":"address"},{"internalType":"Currency","name":"currency1","type":"address"},{"internalType":"uint24","name":"fee","type":"uint24"},{"internalType":"int24","name":"tickSpacing","type":"int24"},{"internalType":"contract IHooks","name":"hooks","type":"address"}],"internalType":"struct PoolKey","name":"newPoolKey","type":"tuple"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"nonces","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owners","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"payoutRecipient","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"uint8","name":"v","type":"uint8"},{"internalType":"bytes32","name":"r","type":"bytes32"},{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"permit","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"platformReferrer","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"poolManager","outputs":[{"internalType":"contract IPoolManager","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"protocolRewardRecipient","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"protocolRewards","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"removeOwner","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address[]","name":"accounts","type":"address[]"}],"name":"removeOwners","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"revokeOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"string","name":"newURI","type":"string"}],"name":"setContractURI","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"string","name":"newName","type":"string"},{"internalType":"string","name":"newSymbol","type":"string"}],"name":"setNameAndSymbol","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newPayoutRecipient","type":"address"}],"name":"setPayoutRecipient","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"tokenURI","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalClaimed","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"vestingEndTime","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"vestingStartTime","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}]
````

## File: src/abi/SitusFactory.json
````json
[{"inputs":[{"internalType":"uint256","name":"_price","type":"uint256"},{"internalType":"address","name":"_forbiddenTlds","type":"address"},{"internalType":"address","name":"_metadataAddress","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[],"name":"Disabled","type":"error"},{"inputs":[],"name":"ExistsOrForbidden","type":"error"},{"inputs":[],"name":"MustHaveNoSpaces","type":"error"},{"inputs":[],"name":"MustHaveOneDot","type":"error"},{"inputs":[],"name":"MustStartWithDot","type":"error"},{"inputs":[],"name":"PaymentFailed","type":"error"},{"inputs":[],"name":"TLDTooLong","type":"error"},{"inputs":[],"name":"TLDTooShort","type":"error"},{"inputs":[],"name":"ValueBelowPrice","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint256","name":"tldPrice","type":"uint256"}],"name":"ChangeTldPrice","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":false,"internalType":"string","name":"tldName","type":"string"},{"indexed":false,"internalType":"address","name":"tldAddress","type":"address"}],"name":"TldCreated","type":"event"},{"inputs":[],"name":"buyingEnabled","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_forbiddenTlds","type":"address"}],"name":"changeForbiddenTldsAddress","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_mAddr","type":"address"}],"name":"changeMetadataAddress","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_maxLength","type":"uint256"}],"name":"changeNameMaxLength","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_price","type":"uint256"}],"name":"changePrice","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_royalty","type":"uint256"}],"name":"changeRoyalty","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"string","name":"_name","type":"string"},{"internalType":"string","name":"_symbol","type":"string"},{"internalType":"address","name":"_tldOwner","type":"address"},{"internalType":"uint256","name":"_domainPrice","type":"uint256"},{"internalType":"bool","name":"_buyingEnabled","type":"bool"}],"name":"createTld","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"forbiddenTlds","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getTldsArray","outputs":[{"internalType":"string[]","name":"","type":"string[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"metadataAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"nameMaxLength","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"string","name":"_name","type":"string"},{"internalType":"string","name":"_symbol","type":"string"},{"internalType":"address","name":"_tldOwner","type":"address"},{"internalType":"uint256","name":"_domainPrice","type":"uint256"},{"internalType":"bool","name":"_buyingEnabled","type":"bool"}],"name":"ownerCreateTld","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"price","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"royalty","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"string","name":"","type":"string"}],"name":"tldNamesAddresses","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"tlds","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"toggleBuyingTlds","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"}]
````

## File: src/abi/SitusOG.json
````json
[{"inputs":[{"internalType":"string","name":"_name","type":"string"},{"internalType":"string","name":"_symbol","type":"string"},{"internalType":"address","name":"_tldOwner","type":"address"},{"internalType":"uint256","name":"_domainPrice","type":"uint256"},{"internalType":"bool","name":"_buyingEnabled","type":"bool"},{"internalType":"uint256","name":"_royalty","type":"uint256"},{"internalType":"address","name":"_factoryAddress","type":"address"},{"internalType":"address","name":"_metadataAddress","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"approved","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"operator","type":"address"},{"indexed":false,"internalType":"bool","name":"approved","type":"bool"}],"name":"ApprovalForAll","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"}],"name":"DataChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"string","name":"defaultDomain","type":"string"}],"name":"DefaultDomainChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"string","name":"fullDomainName","type":"string"}],"name":"DomainBurned","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"bool","name":"domainBuyingToggle","type":"bool"}],"name":"DomainBuyingToggle","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":false,"internalType":"string","name":"fullDomainName","type":"string"}],"name":"DomainCreated","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"user","type":"address"}],"name":"MintingDisabledForever","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint256","name":"referralFee","type":"uint256"}],"name":"ReferralFeeChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint256","name":"tldPrice","type":"uint256"}],"name":"TldPriceChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint256","name":"tldRoyalty","type":"uint256"}],"name":"TldRoyaltyChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"approve","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"string","name":"_domainName","type":"string"}],"name":"burn","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"buyingDisabledForever","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"buyingEnabled","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_metadataAddress","type":"address"}],"name":"changeMetadataAddress","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_minter","type":"address"}],"name":"changeMinter","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_maxLength","type":"uint256"}],"name":"changeNameMaxLength","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_price","type":"uint256"}],"name":"changePrice","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_referral","type":"uint256"}],"name":"changeReferralFee","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_royalty","type":"uint256"}],"name":"changeRoyalty","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_newReceiver","type":"address"}],"name":"changeRoyaltyFeeReceiver","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_newUpdater","type":"address"}],"name":"changeRoyaltyFeeUpdater","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"defaultNames","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"disableBuyingForever","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"domainIdsNames","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"string","name":"","type":"string"}],"name":"domains","outputs":[{"internalType":"string","name":"name","type":"string"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"address","name":"holder","type":"address"},{"internalType":"string","name":"data","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"string","name":"_domainName","type":"string"},{"internalType":"string","name":"_data","type":"string"}],"name":"editData","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"string","name":"_domainName","type":"string"}],"name":"editDefaultDomain","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"factoryAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"freezeMetadata","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"getApproved","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"string","name":"_domainName","type":"string"}],"name":"getDomainData","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"string","name":"_domainName","type":"string"}],"name":"getDomainHolder","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"idCounter","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"operator","type":"address"}],"name":"isApprovedForAll","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"metadataAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"metadataFrozen","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"string","name":"_domainName","type":"string"},{"internalType":"address","name":"_domainHolder","type":"address"},{"internalType":"address","name":"_referrer","type":"address"}],"name":"mint","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"minter","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"nameMaxLength","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"ownerOf","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"price","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"referral","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"royalty","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"royaltyFeeReceiver","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"royaltyFeeUpdater","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"safeTransferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"bytes","name":"_data","type":"bytes"}],"name":"safeTransferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"operator","type":"address"},{"internalType":"bool","name":"approved","type":"bool"}],"name":"setApprovalForAll","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"toggleBuyingDomains","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_tokenId","type":"uint256"}],"name":"tokenURI","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"transferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"}]
````

## File: src/abi/SitusResolver.json
````json
[{"inputs":[],"name":"NotDomainOwner","type":"error"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"string","name":"dName","type":"string"},{"indexed":false,"internalType":"string","name":"dTld","type":"string"}],"name":"CustomDefaultDomainSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"address","name":"tAddr","type":"address"}],"name":"DeprecatedTldAdded","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"address","name":"tAddr","type":"address"}],"name":"DeprecatedTldRemoved","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"address","name":"fAddr","type":"address"}],"name":"FactoryAddressAdded","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"inputs":[{"internalType":"address","name":"_deprecatedTldAddress","type":"address"}],"name":"addDeprecatedTldAddress","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_factoryAddress","type":"address"}],"name":"addFactoryAddress","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"uint256","name":"","type":"uint256"}],"name":"customDefaultDomain","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"factories","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_addr","type":"address"},{"internalType":"string","name":"_tld","type":"string"}],"name":"getDefaultDomain","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_addr","type":"address"}],"name":"getDefaultDomains","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"string","name":"_domainName","type":"string"},{"internalType":"string","name":"_tld","type":"string"}],"name":"getDomainData","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"string","name":"_domainName","type":"string"},{"internalType":"string","name":"_tld","type":"string"}],"name":"getDomainHolder","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"string","name":"_domainName","type":"string"},{"internalType":"string","name":"_tld","type":"string"}],"name":"getDomainTokenUri","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getFactoriesArray","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_addr","type":"address"}],"name":"getFirstDefaultDomain","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"string","name":"_tldName","type":"string"}],"name":"getTldAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"string","name":"_tldName","type":"string"}],"name":"getTldFactoryAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getTlds","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"isTldDeprecated","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_deprecatedTldAddress","type":"address"}],"name":"removeDeprecatedTldAddress","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_addrIndex","type":"uint256"}],"name":"removeFactoryAddress","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"string","name":"_domainName","type":"string"},{"internalType":"string","name":"_tld","type":"string"}],"name":"setCustomDefaultDomain","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"}]
````

## File: src/abi/Zora1155proxy.json
````json
[{"inputs":[{"internalType":"address","name":"_mintFeeRecipient","type":"address"},{"internalType":"address","name":"_upgradeGate","type":"address"},{"internalType":"address","name":"_protocolRewards","type":"address"},{"internalType":"address","name":"_timedSaleStrategy","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[],"name":"ADDRESS_DELEGATECALL_TO_NON_CONTRACT","type":"error"},{"inputs":[],"name":"ADDRESS_LOW_LEVEL_CALL_FAILED","type":"error"},{"inputs":[{"internalType":"address","name":"operator","type":"address"},{"internalType":"address","name":"user","type":"address"}],"name":"Burn_NotOwnerOrApproved","type":"error"},{"inputs":[],"name":"CREATOR_FUNDS_RECIPIENT_NOT_SET","type":"error"},{"inputs":[{"internalType":"bytes","name":"reason","type":"bytes"}],"name":"CallFailed","type":"error"},{"inputs":[],"name":"Call_TokenIdMismatch","type":"error"},{"inputs":[],"name":"CallerNotZoraCreator1155","type":"error"},{"inputs":[],"name":"CanOnlyReduceMaxSupply","type":"error"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"quantity","type":"uint256"},{"internalType":"uint256","name":"totalMinted","type":"uint256"},{"internalType":"uint256","name":"maxSupply","type":"uint256"}],"name":"CannotMintMoreTokens","type":"error"},{"inputs":[],"name":"CannotReduceMaxSupplyBelowMinted","type":"error"},{"inputs":[{"internalType":"address","name":"proposedAddress","type":"address"}],"name":"Config_TransferHookNotSupported","type":"error"},{"inputs":[],"name":"ERC1155_ACCOUNTS_AND_IDS_LENGTH_MISMATCH","type":"error"},{"inputs":[],"name":"ERC1155_ADDRESS_ZERO_IS_NOT_A_VALID_OWNER","type":"error"},{"inputs":[],"name":"ERC1155_BURN_AMOUNT_EXCEEDS_BALANCE","type":"error"},{"inputs":[],"name":"ERC1155_BURN_FROM_ZERO_ADDRESS","type":"error"},{"inputs":[],"name":"ERC1155_CALLER_IS_NOT_TOKEN_OWNER_OR_APPROVED","type":"error"},{"inputs":[],"name":"ERC1155_ERC1155RECEIVER_REJECTED_TOKENS","type":"error"},{"inputs":[],"name":"ERC1155_IDS_AND_AMOUNTS_LENGTH_MISMATCH","type":"error"},{"inputs":[],"name":"ERC1155_INSUFFICIENT_BALANCE_FOR_TRANSFER","type":"error"},{"inputs":[],"name":"ERC1155_MINT_TO_ZERO_ADDRESS","type":"error"},{"inputs":[],"name":"ERC1155_MINT_TO_ZERO_ADDRESS","type":"error"},{"inputs":[],"name":"ERC1155_SETTING_APPROVAL_FOR_SELF","type":"error"},{"inputs":[],"name":"ERC1155_TRANSFER_TO_NON_ERC1155RECEIVER_IMPLEMENTER","type":"error"},{"inputs":[],"name":"ERC1155_TRANSFER_TO_ZERO_ADDRESS","type":"error"},{"inputs":[],"name":"ERC1967_NEW_IMPL_NOT_CONTRACT","type":"error"},{"inputs":[],"name":"ERC1967_NEW_IMPL_NOT_UUPS","type":"error"},{"inputs":[],"name":"ERC1967_UNSUPPORTED_PROXIABLEUUID","type":"error"},{"inputs":[{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"ETHWithdrawFailed","type":"error"},{"inputs":[],"name":"FUNCTION_MUST_BE_CALLED_THROUGH_ACTIVE_PROXY","type":"error"},{"inputs":[],"name":"FUNCTION_MUST_BE_CALLED_THROUGH_DELEGATECALL","type":"error"},{"inputs":[],"name":"FirstMinterAddressZero","type":"error"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"uint256","name":"contractValue","type":"uint256"}],"name":"FundsWithdrawInsolvent","type":"error"},{"inputs":[],"name":"INITIALIZABLE_CONTRACT_ALREADY_INITIALIZED","type":"error"},{"inputs":[],"name":"INITIALIZABLE_CONTRACT_IS_NOT_INITIALIZING","type":"error"},{"inputs":[],"name":"INVALID_ADDRESS_ZERO","type":"error"},{"inputs":[],"name":"INVALID_ETH_AMOUNT","type":"error"},{"inputs":[{"internalType":"address","name":"mintTo","type":"address"},{"internalType":"bytes32[]","name":"merkleProof","type":"bytes32[]"},{"internalType":"bytes32","name":"merkleRoot","type":"bytes32"}],"name":"InvalidMerkleProof","type":"error"},{"inputs":[],"name":"InvalidMintSchedule","type":"error"},{"inputs":[],"name":"InvalidMintSchedule","type":"error"},{"inputs":[],"name":"InvalidPremintVersion","type":"error"},{"inputs":[],"name":"InvalidSignature","type":"error"},{"inputs":[],"name":"InvalidSignatureVersion","type":"error"},{"inputs":[{"internalType":"bytes4","name":"magicValue","type":"bytes4"}],"name":"InvalidSigner","type":"error"},{"inputs":[],"name":"MintNotYetStarted","type":"error"},{"inputs":[],"name":"Mint_InsolventSaleTransfer","type":"error"},{"inputs":[],"name":"Mint_InvalidMintArrayLength","type":"error"},{"inputs":[],"name":"Mint_TokenIDMintNotAllowed","type":"error"},{"inputs":[],"name":"Mint_UnknownCommand","type":"error"},{"inputs":[],"name":"Mint_ValueTransferFail","type":"error"},{"inputs":[],"name":"MinterContractAlreadyExists","type":"error"},{"inputs":[],"name":"MinterContractDoesNotExist","type":"error"},{"inputs":[],"name":"NewOwnerNeedsToBeAdmin","type":"error"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"NoRendererForToken","type":"error"},{"inputs":[],"name":"NonEthRedemption","type":"error"},{"inputs":[],"name":"ONLY_CREATE_REFERRAL","type":"error"},{"inputs":[],"name":"OnlyAllowedForRegisteredMinter","type":"error"},{"inputs":[],"name":"OnlyAllowedForTimedSaleStrategy","type":"error"},{"inputs":[],"name":"OnlyTransfersFromZoraMints","type":"error"},{"inputs":[],"name":"PremintDeleted","type":"error"},{"inputs":[{"internalType":"address","name":"caller","type":"address"},{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"ProtocolRewardsWithdrawFailed","type":"error"},{"inputs":[{"internalType":"address","name":"renderer","type":"address"}],"name":"RendererNotValid","type":"error"},{"inputs":[],"name":"Renderer_NotValidRendererContract","type":"error"},{"inputs":[],"name":"SaleEnded","type":"error"},{"inputs":[],"name":"SaleHasNotStarted","type":"error"},{"inputs":[{"internalType":"address","name":"targetContract","type":"address"}],"name":"Sale_CannotCallNonSalesContract","type":"error"},{"inputs":[{"internalType":"uint256","name":"expected","type":"uint256"},{"internalType":"uint256","name":"actual","type":"uint256"}],"name":"TokenIdMismatch","type":"error"},{"inputs":[],"name":"UUPS_UPGRADEABLE_MUST_NOT_BE_CALLED_THROUGH_DELEGATECALL","type":"error"},{"inputs":[{"internalType":"address","name":"user","type":"address"},{"internalType":"uint256","name":"limit","type":"uint256"},{"internalType":"uint256","name":"requestedAmount","type":"uint256"}],"name":"UserExceedsMintLimit","type":"error"},{"inputs":[{"internalType":"address","name":"user","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"role","type":"uint256"}],"name":"UserMissingRoleForToken","type":"error"},{"inputs":[],"name":"WrongValueSent","type":"error"},{"inputs":[],"name":"premintSignerContractFailedToRecoverSigner","type":"error"},{"inputs":[],"name":"premintSignerContractNotAContract","type":"error"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"previousAdmin","type":"address"},{"indexed":false,"internalType":"address","name":"newAdmin","type":"address"}],"name":"AdminChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"operator","type":"address"},{"indexed":false,"internalType":"bool","name":"approved","type":"bool"}],"name":"ApprovalForAll","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"beacon","type":"address"}],"name":"BeaconUpgraded","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"updater","type":"address"},{"indexed":true,"internalType":"enum IZoraCreator1155.ConfigUpdate","name":"updateType","type":"uint8"},{"components":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"uint96","name":"__gap1","type":"uint96"},{"internalType":"address payable","name":"fundsRecipient","type":"address"},{"internalType":"uint96","name":"__gap2","type":"uint96"},{"internalType":"contract ITransferHookReceiver","name":"transferHook","type":"address"},{"internalType":"uint96","name":"__gap3","type":"uint96"}],"indexed":false,"internalType":"struct IZoraCreator1155TypesV1.ContractConfig","name":"newConfig","type":"tuple"}],"name":"ConfigUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"updater","type":"address"},{"indexed":false,"internalType":"string","name":"uri","type":"string"},{"indexed":false,"internalType":"string","name":"name","type":"string"}],"name":"ContractMetadataUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"contract IRenderer1155","name":"renderer","type":"address"}],"name":"ContractRendererUpdated","type":"event"},{"anonymous":false,"inputs":[],"name":"ContractURIUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"bytes32","name":"structHash","type":"bytes32"},{"indexed":false,"internalType":"string","name":"domainName","type":"string"},{"indexed":false,"internalType":"string","name":"version","type":"string"},{"indexed":false,"internalType":"address","name":"creator","type":"address"},{"indexed":false,"internalType":"bytes","name":"signature","type":"bytes"}],"name":"CreatorAttribution","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint8","name":"version","type":"uint8"}],"name":"Initialized","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"lastOwner","type":"address"},{"indexed":false,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":true,"internalType":"address","name":"minter","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"quantity","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Purchased","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"},{"indexed":true,"internalType":"address","name":"renderer","type":"address"},{"indexed":true,"internalType":"address","name":"user","type":"address"}],"name":"RendererUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"},{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"string","name":"newURI","type":"string"},{"indexed":false,"internalType":"uint256","name":"maxSupply","type":"uint256"}],"name":"SetupNewToken","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"operator","type":"address"},{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256[]","name":"ids","type":"uint256[]"},{"indexed":false,"internalType":"uint256[]","name":"values","type":"uint256[]"}],"name":"TransferBatch","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"operator","type":"address"},{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"id","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"TransferSingle","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"string","name":"value","type":"string"},{"indexed":true,"internalType":"uint256","name":"id","type":"uint256"}],"name":"URI","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"},{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":true,"internalType":"uint256","name":"permissions","type":"uint256"}],"name":"UpdatedPermissions","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"},{"indexed":true,"internalType":"address","name":"user","type":"address"},{"components":[{"internalType":"uint32","name":"royaltyMintSchedule","type":"uint32"},{"internalType":"uint32","name":"royaltyBPS","type":"uint32"},{"internalType":"address","name":"royaltyRecipient","type":"address"}],"indexed":false,"internalType":"struct ICreatorRoyaltiesControl.RoyaltyConfiguration","name":"configuration","type":"tuple"}],"name":"UpdatedRoyalties","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"},{"components":[{"internalType":"string","name":"uri","type":"string"},{"internalType":"uint256","name":"maxSupply","type":"uint256"},{"internalType":"uint256","name":"totalMinted","type":"uint256"}],"indexed":false,"internalType":"struct IZoraCreator1155TypesV1.TokenData","name":"tokenData","type":"tuple"}],"name":"UpdatedToken","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"implementation","type":"address"}],"name":"Upgraded","type":"event"},{"inputs":[],"name":"CONTRACT_BASE_ID","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"PERMISSION_BIT_ADMIN","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"PERMISSION_BIT_FUNDS_MANAGER","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"PERMISSION_BIT_METADATA","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"PERMISSION_BIT_MINTER","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"PERMISSION_BIT_SALES","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"address","name":"user","type":"address"},{"internalType":"uint256","name":"permissionBits","type":"uint256"}],"name":"addPermission","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"quantity","type":"uint256"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"adminMint","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"lastTokenId","type":"uint256"}],"name":"assumeLastTokenIdMatches","outputs":[],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"id","type":"uint256"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address[]","name":"accounts","type":"address[]"},{"internalType":"uint256[]","name":"ids","type":"uint256[]"}],"name":"balanceOfBatch","outputs":[{"internalType":"uint256[]","name":"batchBalances","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"uint256[]","name":"tokenIds","type":"uint256[]"},{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"name":"burnBatch","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"callRenderer","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"contract IMinter1155","name":"salesConfig","type":"address"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"callSale","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"mintPrice","type":"uint256"},{"internalType":"uint256","name":"quantity","type":"uint256"}],"name":"computeTotalReward","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"config","outputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"uint96","name":"__gap1","type":"uint96"},{"internalType":"address payable","name":"fundsRecipient","type":"address"},{"internalType":"uint96","name":"__gap2","type":"uint96"},{"internalType":"contract ITransferHookReceiver","name":"transferHook","type":"address"},{"internalType":"uint96","name":"__gap3","type":"uint96"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"contractName","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"contractURI","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"contractVersion","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"createReferrals","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"customRenderers","outputs":[{"internalType":"contract IRenderer1155","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"premintConfig","type":"bytes"},{"internalType":"bytes32","name":"premintVersion","type":"bytes32"},{"internalType":"bytes","name":"signature","type":"bytes"},{"internalType":"address","name":"firstMinter","type":"address"},{"internalType":"address","name":"premintSignerContract","type":"address"}],"name":"delegateSetupNewToken","outputs":[{"internalType":"uint256","name":"newTokenId","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint32","name":"","type":"uint32"}],"name":"delegatedTokenId","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"firstMinters","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"getCreatorRewardRecipient","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"getCustomRenderer","outputs":[{"internalType":"contract IRenderer1155","name":"customRenderer","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"getRoyalties","outputs":[{"components":[{"internalType":"uint32","name":"royaltyMintSchedule","type":"uint32"},{"internalType":"uint32","name":"royaltyBPS","type":"uint32"},{"internalType":"address","name":"royaltyRecipient","type":"address"}],"internalType":"struct ICreatorRoyaltiesControl.RoyaltyConfiguration","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"getTokenInfo","outputs":[{"components":[{"internalType":"string","name":"uri","type":"string"},{"internalType":"uint256","name":"maxSupply","type":"uint256"},{"internalType":"uint256","name":"totalMinted","type":"uint256"}],"internalType":"struct IZoraCreator1155TypesV1.TokenData","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"implementation","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"string","name":"contractName","type":"string"},{"internalType":"string","name":"newContractURI","type":"string"},{"components":[{"internalType":"uint32","name":"royaltyMintSchedule","type":"uint32"},{"internalType":"uint32","name":"royaltyBPS","type":"uint32"},{"internalType":"address","name":"royaltyRecipient","type":"address"}],"internalType":"struct ICreatorRoyaltiesControl.RoyaltyConfiguration","name":"defaultRoyaltyConfiguration","type":"tuple"},{"internalType":"address payable","name":"defaultAdmin","type":"address"},{"internalType":"bytes[]","name":"setupActions","type":"bytes[]"}],"name":"initialize","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"role","type":"uint256"}],"name":"isAdminOrRole","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"address","name":"operator","type":"address"}],"name":"isApprovedForAll","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"metadataRendererContract","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IMinter1155","name":"minter","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"quantity","type":"uint256"},{"internalType":"address[]","name":"rewardsRecipients","type":"address[]"},{"internalType":"bytes","name":"minterArguments","type":"bytes"}],"name":"mint","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"mintFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"data","type":"bytes[]"}],"name":"multicall","outputs":[{"internalType":"bytes[]","name":"results","type":"bytes[]"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"nextTokenId","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"},{"internalType":"address","name":"","type":"address"}],"name":"permissions","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"proxiableUUID","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"newMaxSupply","type":"uint256"}],"name":"reduceSupply","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"address","name":"user","type":"address"},{"internalType":"uint256","name":"permissionBits","type":"uint256"}],"name":"removePermission","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"royalties","outputs":[{"internalType":"uint32","name":"royaltyMintSchedule","type":"uint32"},{"internalType":"uint32","name":"royaltyBPS","type":"uint32"},{"internalType":"address","name":"royaltyRecipient","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"salePrice","type":"uint256"}],"name":"royaltyInfo","outputs":[{"internalType":"address","name":"receiver","type":"address"},{"internalType":"uint256","name":"royaltyAmount","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256[]","name":"ids","type":"uint256[]"},{"internalType":"uint256[]","name":"amounts","type":"uint256[]"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"safeBatchTransferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"id","type":"uint256"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"safeTransferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"operator","type":"address"},{"internalType":"bool","name":"approved","type":"bool"}],"name":"setApprovalForAll","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address payable","name":"fundsRecipient","type":"address"}],"name":"setFundsRecipient","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"setOwner","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"contract IRenderer1155","name":"renderer","type":"address"}],"name":"setTokenMetadataRenderer","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"contract ITransferHookReceiver","name":"transferHook","type":"address"}],"name":"setTransferHook","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"string","name":"newURI","type":"string"},{"internalType":"uint256","name":"maxSupply","type":"uint256"}],"name":"setupNewToken","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"string","name":"newURI","type":"string"},{"internalType":"uint256","name":"maxSupply","type":"uint256"},{"internalType":"address","name":"createReferral","type":"address"}],"name":"setupNewTokenWithCreateReferral","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"supportedPremintSignatureVersions","outputs":[{"internalType":"string[]","name":"","type":"string[]"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"string","name":"_newURI","type":"string"},{"internalType":"string","name":"_newName","type":"string"}],"name":"updateContractMetadata","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"address","name":"recipient","type":"address"}],"name":"updateCreateReferral","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"},{"components":[{"internalType":"uint32","name":"royaltyMintSchedule","type":"uint32"},{"internalType":"uint32","name":"royaltyBPS","type":"uint32"},{"internalType":"address","name":"royaltyRecipient","type":"address"}],"internalType":"struct ICreatorRoyaltiesControl.RoyaltyConfiguration","name":"newConfiguration","type":"tuple"}],"name":"updateRoyaltiesForToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"string","name":"_newURI","type":"string"}],"name":"updateTokenURI","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newImplementation","type":"address"}],"name":"upgradeTo","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newImplementation","type":"address"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"upgradeToAndCall","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"uri","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"withdraw","outputs":[],"stateMutability":"nonpayable","type":"function"},{"stateMutability":"payable","type":"receive"}]
````

## File: src/abi/ZoraCoin.json
````json
[{"inputs":[{"internalType":"address","name":"_protocolRewardRecipient","type":"address"},{"internalType":"address","name":"_protocolRewards","type":"address"},{"internalType":"address","name":"_weth","type":"address"},{"internalType":"address","name":"_nonfungiblePositionManager","type":"address"},{"internalType":"address","name":"_swapRouter","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[{"internalType":"address","name":"target","type":"address"}],"name":"AddressEmptyCode","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"AddressInsufficientBalance","type":"error"},{"inputs":[],"name":"AddressZero","type":"error"},{"inputs":[],"name":"AlreadyOwner","type":"error"},{"inputs":[],"name":"ECDSAInvalidSignature","type":"error"},{"inputs":[{"internalType":"uint256","name":"length","type":"uint256"}],"name":"ECDSAInvalidSignatureLength","type":"error"},{"inputs":[{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"ECDSAInvalidSignatureS","type":"error"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"allowance","type":"uint256"},{"internalType":"uint256","name":"needed","type":"uint256"}],"name":"ERC20InsufficientAllowance","type":"error"},{"inputs":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"uint256","name":"balance","type":"uint256"},{"internalType":"uint256","name":"needed","type":"uint256"}],"name":"ERC20InsufficientBalance","type":"error"},{"inputs":[{"internalType":"address","name":"approver","type":"address"}],"name":"ERC20InvalidApprover","type":"error"},{"inputs":[{"internalType":"address","name":"receiver","type":"address"}],"name":"ERC20InvalidReceiver","type":"error"},{"inputs":[{"internalType":"address","name":"sender","type":"address"}],"name":"ERC20InvalidSender","type":"error"},{"inputs":[{"internalType":"address","name":"spender","type":"address"}],"name":"ERC20InvalidSpender","type":"error"},{"inputs":[],"name":"ERC20TransferAmountMismatch","type":"error"},{"inputs":[{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"ERC2612ExpiredSignature","type":"error"},{"inputs":[{"internalType":"address","name":"signer","type":"address"},{"internalType":"address","name":"owner","type":"address"}],"name":"ERC2612InvalidSigner","type":"error"},{"inputs":[],"name":"EthAmountMismatch","type":"error"},{"inputs":[],"name":"EthAmountTooSmall","type":"error"},{"inputs":[],"name":"EthTransferFailed","type":"error"},{"inputs":[],"name":"EthTransferInvalid","type":"error"},{"inputs":[],"name":"FailedInnerCall","type":"error"},{"inputs":[],"name":"InitialOrderSizeTooLarge","type":"error"},{"inputs":[],"name":"InsufficientFunds","type":"error"},{"inputs":[],"name":"InsufficientLiquidity","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"currentNonce","type":"uint256"}],"name":"InvalidAccountNonce","type":"error"},{"inputs":[],"name":"InvalidCurrencyLowerTick","type":"error"},{"inputs":[],"name":"InvalidInitialization","type":"error"},{"inputs":[],"name":"InvalidMarketType","type":"error"},{"inputs":[],"name":"InvalidWethLowerTick","type":"error"},{"inputs":[],"name":"MarketAlreadyGraduated","type":"error"},{"inputs":[],"name":"MarketNotGraduated","type":"error"},{"inputs":[],"name":"NotInitializing","type":"error"},{"inputs":[],"name":"NotOwner","type":"error"},{"inputs":[],"name":"OneOwnerRequired","type":"error"},{"inputs":[],"name":"OnlyOwner","type":"error"},{"inputs":[],"name":"OnlyPool","type":"error"},{"inputs":[],"name":"OnlyWeth","type":"error"},{"inputs":[],"name":"OwnerCannotBeAddressZero","type":"error"},{"inputs":[],"name":"ReentrancyGuardReentrantCall","type":"error"},{"inputs":[{"internalType":"address","name":"token","type":"address"}],"name":"SafeERC20FailedOperation","type":"error"},{"inputs":[],"name":"SlippageBoundsExceeded","type":"error"},{"inputs":[],"name":"UseRevokeOwnershipToRemoveSelf","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"buyer","type":"address"},{"indexed":true,"internalType":"address","name":"recipient","type":"address"},{"indexed":true,"internalType":"address","name":"tradeReferrer","type":"address"},{"indexed":false,"internalType":"uint256","name":"coinsPurchased","type":"uint256"},{"indexed":false,"internalType":"address","name":"currency","type":"address"},{"indexed":false,"internalType":"uint256","name":"amountFee","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amountSold","type":"uint256"}],"name":"CoinBuy","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"payoutRecipient","type":"address"},{"indexed":true,"internalType":"address","name":"platformReferrer","type":"address"},{"indexed":false,"internalType":"address","name":"protocolRewardRecipient","type":"address"},{"indexed":false,"internalType":"address","name":"currency","type":"address"},{"components":[{"internalType":"uint256","name":"totalAmountCurrency","type":"uint256"},{"internalType":"uint256","name":"totalAmountCoin","type":"uint256"},{"internalType":"uint256","name":"creatorPayoutAmountCurrency","type":"uint256"},{"internalType":"uint256","name":"creatorPayoutAmountCoin","type":"uint256"},{"internalType":"uint256","name":"platformReferrerAmountCurrency","type":"uint256"},{"internalType":"uint256","name":"platformReferrerAmountCoin","type":"uint256"},{"internalType":"uint256","name":"protocolAmountCurrency","type":"uint256"},{"internalType":"uint256","name":"protocolAmountCoin","type":"uint256"}],"indexed":false,"internalType":"struct ICoin.MarketRewards","name":"marketRewards","type":"tuple"}],"name":"CoinMarketRewards","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"caller","type":"address"},{"indexed":true,"internalType":"address","name":"prevRecipient","type":"address"},{"indexed":true,"internalType":"address","name":"newRecipient","type":"address"}],"name":"CoinPayoutRecipientUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"seller","type":"address"},{"indexed":true,"internalType":"address","name":"recipient","type":"address"},{"indexed":true,"internalType":"address","name":"tradeReferrer","type":"address"},{"indexed":false,"internalType":"uint256","name":"coinsSold","type":"uint256"},{"indexed":false,"internalType":"address","name":"currency","type":"address"},{"indexed":false,"internalType":"uint256","name":"amountFee","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amountPurchased","type":"uint256"}],"name":"CoinSell","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"payoutRecipient","type":"address"},{"indexed":true,"internalType":"address","name":"platformReferrer","type":"address"},{"indexed":true,"internalType":"address","name":"tradeReferrer","type":"address"},{"indexed":false,"internalType":"address","name":"protocolRewardRecipient","type":"address"},{"indexed":false,"internalType":"uint256","name":"creatorReward","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"platformReferrerReward","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"traderReferrerReward","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"protocolReward","type":"uint256"},{"indexed":false,"internalType":"address","name":"currency","type":"address"}],"name":"CoinTradeRewards","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":true,"internalType":"address","name":"recipient","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"senderBalance","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"recipientBalance","type":"uint256"}],"name":"CoinTransfer","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"caller","type":"address"},{"indexed":false,"internalType":"string","name":"newURI","type":"string"},{"indexed":false,"internalType":"string","name":"name","type":"string"}],"name":"ContractMetadataUpdated","type":"event"},{"anonymous":false,"inputs":[],"name":"ContractURIUpdated","type":"event"},{"anonymous":false,"inputs":[],"name":"EIP712DomainChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint64","name":"version","type":"uint64"}],"name":"Initialized","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"caller","type":"address"},{"indexed":true,"internalType":"address","name":"prevOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnerUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[],"name":"DOMAIN_SEPARATOR","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"MAX_TOTAL_SUPPLY","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"MIN_ORDER_SIZE","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"PLATFORM_REFERRER_FEE_BPS","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"PROTOCOL_FEE_BPS","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"TOKEN_CREATOR_FEE_BPS","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"TOTAL_FEE_BPS","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"TRADE_REFERRER_FEE_BPS","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"WETH","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"addOwner","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address[]","name":"accounts","type":"address[]"}],"name":"addOwners","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"burn","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"orderSize","type":"uint256"},{"internalType":"uint256","name":"minAmountOut","type":"uint256"},{"internalType":"uint160","name":"sqrtPriceLimitX96","type":"uint160"},{"internalType":"address","name":"tradeReferrer","type":"address"}],"name":"buy","outputs":[{"internalType":"uint256","name":"","type":"uint256"},{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"bool","name":"pushEthRewards","type":"bool"}],"name":"claimSecondaryRewards","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"contractURI","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"contractVersion","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"currency","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"eip712Domain","outputs":[{"internalType":"bytes1","name":"fields","type":"bytes1"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"version","type":"string"},{"internalType":"uint256","name":"chainId","type":"uint256"},{"internalType":"address","name":"verifyingContract","type":"address"},{"internalType":"bytes32","name":"salt","type":"bytes32"},{"internalType":"uint256[]","name":"extensions","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"payoutRecipient_","type":"address"},{"internalType":"address[]","name":"owners_","type":"address[]"},{"internalType":"string","name":"tokenURI_","type":"string"},{"internalType":"string","name":"name_","type":"string"},{"internalType":"string","name":"symbol_","type":"string"},{"internalType":"address","name":"platformReferrer_","type":"address"},{"internalType":"address","name":"currency_","type":"address"},{"internalType":"int24","name":"tickLower_","type":"int24"}],"name":"initialize","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"isOwner","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"lpTokenId","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"nonces","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"nonfungiblePositionManager","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"address","name":"","type":"address"},{"internalType":"uint256","name":"","type":"uint256"},{"internalType":"bytes","name":"","type":"bytes"}],"name":"onERC721Received","outputs":[{"internalType":"bytes4","name":"","type":"bytes4"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owners","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"payoutRecipient","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"uint8","name":"v","type":"uint8"},{"internalType":"bytes32","name":"r","type":"bytes32"},{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"permit","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"platformReferrer","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"poolAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"protocolRewardRecipient","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"protocolRewards","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"removeOwner","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address[]","name":"accounts","type":"address[]"}],"name":"removeOwners","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"revokeOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"orderSize","type":"uint256"},{"internalType":"uint256","name":"minAmountOut","type":"uint256"},{"internalType":"uint160","name":"sqrtPriceLimitX96","type":"uint160"},{"internalType":"address","name":"tradeReferrer","type":"address"}],"name":"sell","outputs":[{"internalType":"uint256","name":"","type":"uint256"},{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"string","name":"newURI","type":"string"}],"name":"setContractURI","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newPayoutRecipient","type":"address"}],"name":"setPayoutRecipient","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"swapRouter","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"tokenURI","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"int256","name":"amount0Delta","type":"int256"},{"internalType":"int256","name":"amount1Delta","type":"int256"},{"internalType":"bytes","name":"","type":"bytes"}],"name":"uniswapV3SwapCallback","outputs":[],"stateMutability":"nonpayable","type":"function"},{"stateMutability":"payable","type":"receive"}]
````

## File: src/abi/ZoraCoinV4.json
````json
[{"inputs":[{"internalType":"address","name":"protocolRewardRecipient_","type":"address"},{"internalType":"address","name":"protocolRewards_","type":"address"},{"internalType":"contract IPoolManager","name":"poolManager_","type":"address"},{"internalType":"address","name":"airlock_","type":"address"},{"internalType":"contract IHooks","name":"hooks_","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[],"name":"AddressZero","type":"error"},{"inputs":[],"name":"AlreadyOwner","type":"error"},{"inputs":[],"name":"CannotMintZeroLiquidity","type":"error"},{"inputs":[],"name":"DopplerPoolMustHaveMoreThan2DiscoveryPositions","type":"error"},{"inputs":[],"name":"ECDSAInvalidSignature","type":"error"},{"inputs":[{"internalType":"uint256","name":"length","type":"uint256"}],"name":"ECDSAInvalidSignatureLength","type":"error"},{"inputs":[{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"ECDSAInvalidSignatureS","type":"error"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"allowance","type":"uint256"},{"internalType":"uint256","name":"needed","type":"uint256"}],"name":"ERC20InsufficientAllowance","type":"error"},{"inputs":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"uint256","name":"balance","type":"uint256"},{"internalType":"uint256","name":"needed","type":"uint256"}],"name":"ERC20InsufficientBalance","type":"error"},{"inputs":[{"internalType":"address","name":"approver","type":"address"}],"name":"ERC20InvalidApprover","type":"error"},{"inputs":[{"internalType":"address","name":"receiver","type":"address"}],"name":"ERC20InvalidReceiver","type":"error"},{"inputs":[{"internalType":"address","name":"sender","type":"address"}],"name":"ERC20InvalidSender","type":"error"},{"inputs":[{"internalType":"address","name":"spender","type":"address"}],"name":"ERC20InvalidSpender","type":"error"},{"inputs":[],"name":"ERC20TransferAmountMismatch","type":"error"},{"inputs":[{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"ERC2612ExpiredSignature","type":"error"},{"inputs":[{"internalType":"address","name":"signer","type":"address"},{"internalType":"address","name":"owner","type":"address"}],"name":"ERC2612InvalidSigner","type":"error"},{"inputs":[],"name":"EthAmountMismatch","type":"error"},{"inputs":[],"name":"EthAmountTooSmall","type":"error"},{"inputs":[],"name":"EthTransferFailed","type":"error"},{"inputs":[],"name":"EthTransferInvalid","type":"error"},{"inputs":[],"name":"InitialOrderSizeTooLarge","type":"error"},{"inputs":[],"name":"InsufficientFunds","type":"error"},{"inputs":[],"name":"InsufficientLiquidity","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"currentNonce","type":"uint256"}],"name":"InvalidAccountNonce","type":"error"},{"inputs":[],"name":"InvalidCurrencyLowerTick","type":"error"},{"inputs":[],"name":"InvalidInitialization","type":"error"},{"inputs":[],"name":"InvalidMarketType","type":"error"},{"inputs":[],"name":"InvalidPoolVersion","type":"error"},{"inputs":[{"internalType":"int24","name":"tickLower","type":"int24"},{"internalType":"int24","name":"tickUpper","type":"int24"}],"name":"InvalidTickRangeMisordered","type":"error"},{"inputs":[],"name":"InvalidWethLowerTick","type":"error"},{"inputs":[],"name":"LegacyPoolMustHaveOneDiscoveryPosition","type":"error"},{"inputs":[],"name":"MarketAlreadyGraduated","type":"error"},{"inputs":[],"name":"MarketNotGraduated","type":"error"},{"inputs":[{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"uint256","name":"limit","type":"uint256"}],"name":"MaxShareToBeSoldExceeded","type":"error"},{"inputs":[],"name":"NotInitializing","type":"error"},{"inputs":[],"name":"NotOwner","type":"error"},{"inputs":[],"name":"NumDiscoveryPositionsOutOfRange","type":"error"},{"inputs":[],"name":"OneOwnerRequired","type":"error"},{"inputs":[],"name":"OnlyOwner","type":"error"},{"inputs":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"address","name":"pool","type":"address"}],"name":"OnlyPool","type":"error"},{"inputs":[],"name":"OnlyWeth","type":"error"},{"inputs":[],"name":"OwnerCannotBeAddressZero","type":"error"},{"inputs":[],"name":"ReentrancyGuardReentrantCall","type":"error"},{"inputs":[],"name":"SlippageBoundsExceeded","type":"error"},{"inputs":[],"name":"UseRevokeOwnershipToRemoveSelf","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"buyer","type":"address"},{"indexed":true,"internalType":"address","name":"recipient","type":"address"},{"indexed":true,"internalType":"address","name":"tradeReferrer","type":"address"},{"indexed":false,"internalType":"uint256","name":"coinsPurchased","type":"uint256"},{"indexed":false,"internalType":"address","name":"currency","type":"address"},{"indexed":false,"internalType":"uint256","name":"amountFee","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amountSold","type":"uint256"}],"name":"CoinBuy","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"payoutRecipient","type":"address"},{"indexed":true,"internalType":"address","name":"platformReferrer","type":"address"},{"indexed":false,"internalType":"address","name":"protocolRewardRecipient","type":"address"},{"indexed":false,"internalType":"address","name":"currency","type":"address"},{"components":[{"internalType":"uint256","name":"totalAmountCurrency","type":"uint256"},{"internalType":"uint256","name":"totalAmountCoin","type":"uint256"},{"internalType":"uint256","name":"creatorPayoutAmountCurrency","type":"uint256"},{"internalType":"uint256","name":"creatorPayoutAmountCoin","type":"uint256"},{"internalType":"uint256","name":"platformReferrerAmountCurrency","type":"uint256"},{"internalType":"uint256","name":"platformReferrerAmountCoin","type":"uint256"},{"internalType":"uint256","name":"protocolAmountCurrency","type":"uint256"},{"internalType":"uint256","name":"protocolAmountCoin","type":"uint256"}],"indexed":false,"internalType":"struct ICoin.MarketRewards","name":"marketRewards","type":"tuple"}],"name":"CoinMarketRewards","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"caller","type":"address"},{"indexed":true,"internalType":"address","name":"prevRecipient","type":"address"},{"indexed":true,"internalType":"address","name":"newRecipient","type":"address"}],"name":"CoinPayoutRecipientUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"seller","type":"address"},{"indexed":true,"internalType":"address","name":"recipient","type":"address"},{"indexed":true,"internalType":"address","name":"tradeReferrer","type":"address"},{"indexed":false,"internalType":"uint256","name":"coinsSold","type":"uint256"},{"indexed":false,"internalType":"address","name":"currency","type":"address"},{"indexed":false,"internalType":"uint256","name":"amountFee","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amountPurchased","type":"uint256"}],"name":"CoinSell","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"payoutRecipient","type":"address"},{"indexed":true,"internalType":"address","name":"platformReferrer","type":"address"},{"indexed":true,"internalType":"address","name":"tradeReferrer","type":"address"},{"indexed":false,"internalType":"address","name":"protocolRewardRecipient","type":"address"},{"indexed":false,"internalType":"uint256","name":"creatorReward","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"platformReferrerReward","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"traderReferrerReward","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"protocolReward","type":"uint256"},{"indexed":false,"internalType":"address","name":"currency","type":"address"}],"name":"CoinTradeRewards","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":true,"internalType":"address","name":"recipient","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"senderBalance","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"recipientBalance","type":"uint256"}],"name":"CoinTransfer","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"caller","type":"address"},{"indexed":false,"internalType":"string","name":"newURI","type":"string"},{"indexed":false,"internalType":"string","name":"name","type":"string"}],"name":"ContractMetadataUpdated","type":"event"},{"anonymous":false,"inputs":[],"name":"ContractURIUpdated","type":"event"},{"anonymous":false,"inputs":[],"name":"EIP712DomainChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint64","name":"version","type":"uint64"}],"name":"Initialized","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"caller","type":"address"},{"indexed":true,"internalType":"address","name":"prevOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnerUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[],"name":"DOMAIN_SEPARATOR","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"addOwner","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address[]","name":"accounts","type":"address[]"}],"name":"addOwners","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"airlock","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"burn","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"contractURI","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"contractVersion","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"currency","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"dopplerFeeRecipient","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"eip712Domain","outputs":[{"internalType":"bytes1","name":"fields","type":"bytes1"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"version","type":"string"},{"internalType":"uint256","name":"chainId","type":"uint256"},{"internalType":"address","name":"verifyingContract","type":"address"},{"internalType":"bytes32","name":"salt","type":"bytes32"},{"internalType":"uint256[]","name":"extensions","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IDeployedCoinVersionLookup","name":"coinVersionLookup","type":"address"}],"name":"getPayoutSwapPath","outputs":[{"components":[{"components":[{"internalType":"Currency","name":"intermediateCurrency","type":"address"},{"internalType":"uint24","name":"fee","type":"uint24"},{"internalType":"int24","name":"tickSpacing","type":"int24"},{"internalType":"contract IHooks","name":"hooks","type":"address"},{"internalType":"bytes","name":"hookData","type":"bytes"}],"internalType":"struct PathKey[]","name":"path","type":"tuple[]"},{"internalType":"Currency","name":"currencyIn","type":"address"}],"internalType":"struct IHasSwapPath.PayoutSwapPath","name":"payoutSwapPath","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getPoolConfiguration","outputs":[{"components":[{"internalType":"uint8","name":"version","type":"uint8"},{"internalType":"uint16","name":"numPositions","type":"uint16"},{"internalType":"uint24","name":"fee","type":"uint24"},{"internalType":"int24","name":"tickSpacing","type":"int24"},{"internalType":"uint16[]","name":"numDiscoveryPositions","type":"uint16[]"},{"internalType":"int24[]","name":"tickLower","type":"int24[]"},{"internalType":"int24[]","name":"tickUpper","type":"int24[]"},{"internalType":"uint256[]","name":"maxDiscoverySupplyShare","type":"uint256[]"}],"internalType":"struct PoolConfiguration","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getPoolKey","outputs":[{"components":[{"internalType":"Currency","name":"currency0","type":"address"},{"internalType":"Currency","name":"currency1","type":"address"},{"internalType":"uint24","name":"fee","type":"uint24"},{"internalType":"int24","name":"tickSpacing","type":"int24"},{"internalType":"contract IHooks","name":"hooks","type":"address"}],"internalType":"struct PoolKey","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"hooks","outputs":[{"internalType":"contract IHooks","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"payoutRecipient_","type":"address"},{"internalType":"address[]","name":"owners_","type":"address[]"},{"internalType":"string","name":"tokenURI_","type":"string"},{"internalType":"string","name":"name_","type":"string"},{"internalType":"string","name":"symbol_","type":"string"},{"internalType":"address","name":"platformReferrer_","type":"address"},{"internalType":"address","name":"currency_","type":"address"},{"components":[{"internalType":"Currency","name":"currency0","type":"address"},{"internalType":"Currency","name":"currency1","type":"address"},{"internalType":"uint24","name":"fee","type":"uint24"},{"internalType":"int24","name":"tickSpacing","type":"int24"},{"internalType":"contract IHooks","name":"hooks","type":"address"}],"internalType":"struct PoolKey","name":"poolKey_","type":"tuple"},{"internalType":"uint160","name":"sqrtPriceX96","type":"uint160"},{"components":[{"internalType":"uint8","name":"version","type":"uint8"},{"internalType":"uint16","name":"numPositions","type":"uint16"},{"internalType":"uint24","name":"fee","type":"uint24"},{"internalType":"int24","name":"tickSpacing","type":"int24"},{"internalType":"uint16[]","name":"numDiscoveryPositions","type":"uint16[]"},{"internalType":"int24[]","name":"tickLower","type":"int24[]"},{"internalType":"int24[]","name":"tickUpper","type":"int24[]"},{"internalType":"uint256[]","name":"maxDiscoverySupplyShare","type":"uint256[]"}],"internalType":"struct PoolConfiguration","name":"poolConfiguration_","type":"tuple"}],"name":"initialize","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"isOwner","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"nonces","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owners","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"payoutRecipient","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"uint8","name":"v","type":"uint8"},{"internalType":"bytes32","name":"r","type":"bytes32"},{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"permit","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"platformReferrer","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"poolManager","outputs":[{"internalType":"contract IPoolManager","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"protocolRewardRecipient","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"protocolRewards","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"removeOwner","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address[]","name":"accounts","type":"address[]"}],"name":"removeOwners","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"revokeOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"string","name":"newURI","type":"string"}],"name":"setContractURI","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newPayoutRecipient","type":"address"}],"name":"setPayoutRecipient","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"tokenURI","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"}]
````

## File: src/abi/ZoraERC20Minter.json
````json
[{"inputs":[],"name":"AddressZero","type":"error"},{"inputs":[],"name":"AlreadyInitialized","type":"error"},{"inputs":[],"name":"ERC20TransferSlippage","type":"error"},{"inputs":[],"name":"InvalidCurrency","type":"error"},{"inputs":[],"name":"OnlyZoraRewardsRecipient","type":"error"},{"inputs":[],"name":"PricePerTokenTooLow","type":"error"},{"inputs":[],"name":"RequestMintInvalidUseMint","type":"error"},{"inputs":[],"name":"SaleEnded","type":"error"},{"inputs":[],"name":"SaleHasNotStarted","type":"error"},{"inputs":[{"internalType":"address","name":"user","type":"address"},{"internalType":"uint256","name":"limit","type":"uint256"},{"internalType":"uint256","name":"requestedAmount","type":"uint256"}],"name":"UserExceedsMintLimit","type":"error"},{"inputs":[],"name":"WrongValueSent","type":"error"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"rewardPercentage","type":"uint256"}],"name":"ERC20MinterInitialized","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"createReferral","type":"address"},{"indexed":true,"internalType":"address","name":"mintReferral","type":"address"},{"indexed":true,"internalType":"address","name":"firstMinter","type":"address"},{"indexed":false,"internalType":"address","name":"zora","type":"address"},{"indexed":false,"internalType":"address","name":"collection","type":"address"},{"indexed":false,"internalType":"address","name":"currency","type":"address"},{"indexed":false,"internalType":"uint256","name":"tokenId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"createReferralReward","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"mintReferralReward","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"firstMinterReward","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"zoraReward","type":"uint256"}],"name":"ERC20RewardsDeposit","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":true,"internalType":"address","name":"tokenContract","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"quantity","type":"uint256"},{"indexed":false,"internalType":"string","name":"comment","type":"string"}],"name":"MintComment","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"mediaContract","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"},{"components":[{"internalType":"uint64","name":"saleStart","type":"uint64"},{"internalType":"uint64","name":"saleEnd","type":"uint64"},{"internalType":"uint64","name":"maxTokensPerAddress","type":"uint64"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"address","name":"fundsRecipient","type":"address"},{"internalType":"address","name":"currency","type":"address"}],"indexed":false,"internalType":"struct IERC20Minter.SalesConfig","name":"salesConfig","type":"tuple"}],"name":"SaleSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"prevRecipient","type":"address"},{"indexed":true,"internalType":"address","name":"newRecipient","type":"address"}],"name":"ZoraRewardsRecipientSet","type":"event"},{"inputs":[{"internalType":"uint256","name":"totalReward","type":"uint256"}],"name":"computePaidMintRewards","outputs":[{"components":[{"internalType":"uint256","name":"createReferralReward","type":"uint256"},{"internalType":"uint256","name":"mintReferralReward","type":"uint256"},{"internalType":"uint256","name":"zoraReward","type":"uint256"},{"internalType":"uint256","name":"firstMinterReward","type":"uint256"}],"internalType":"struct IERC20Minter.RewardsSettings","name":"","type":"tuple"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint256","name":"totalReward","type":"uint256"},{"internalType":"uint256","name":"rewardPct","type":"uint256"}],"name":"computeReward","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint256","name":"totalValue","type":"uint256"}],"name":"computeTotalReward","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"contractName","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"contractURI","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"contractVersion","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"address","name":"tokenContract","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"getCreateReferral","outputs":[{"internalType":"address","name":"createReferral","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"tokenContract","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"getFirstMinter","outputs":[{"internalType":"address","name":"firstMinter","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"tokenContract","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"address","name":"wallet","type":"address"}],"name":"getMintedPerWallet","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_zoraRewardRecipientAddress","type":"address"}],"name":"initialize","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"mintTo","type":"address"},{"internalType":"uint256","name":"quantity","type":"uint256"},{"internalType":"address","name":"tokenAddress","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"totalValue","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"address","name":"mintReferral","type":"address"},{"internalType":"string","name":"comment","type":"string"}],"name":"mint","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"uint256","name":"","type":"uint256"},{"internalType":"uint256","name":"","type":"uint256"},{"internalType":"uint256","name":"","type":"uint256"},{"internalType":"bytes","name":"","type":"bytes"}],"name":"requestMint","outputs":[{"components":[{"components":[{"internalType":"enum ICreatorCommands.CreatorActions","name":"method","type":"uint8"},{"internalType":"bytes","name":"args","type":"bytes"}],"internalType":"struct ICreatorCommands.Command[]","name":"commands","type":"tuple[]"},{"internalType":"uint256","name":"at","type":"uint256"}],"internalType":"struct ICreatorCommands.CommandSet","name":"","type":"tuple"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"resetSale","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"tokenContract","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"sale","outputs":[{"components":[{"internalType":"uint64","name":"saleStart","type":"uint64"},{"internalType":"uint64","name":"saleEnd","type":"uint64"},{"internalType":"uint64","name":"maxTokensPerAddress","type":"uint64"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"address","name":"fundsRecipient","type":"address"},{"internalType":"address","name":"currency","type":"address"}],"internalType":"struct IERC20Minter.SalesConfig","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"},{"components":[{"internalType":"uint64","name":"saleStart","type":"uint64"},{"internalType":"uint64","name":"saleEnd","type":"uint64"},{"internalType":"uint64","name":"maxTokensPerAddress","type":"uint64"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"address","name":"fundsRecipient","type":"address"},{"internalType":"address","name":"currency","type":"address"}],"internalType":"struct IERC20Minter.SalesConfig","name":"salesConfig","type":"tuple"}],"name":"setSale","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"recipient","type":"address"}],"name":"setZoraRewardsRecipient","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"totalRewardPct","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"zoraRewardRecipientAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"}]
````

## File: src/app/(accounts)/[account]/hold/page.tsx
````typescript
'use client'

import Portfolio from '@/modules/account-modules/portfolio'
import { useAccount } from '@/modules/accounts/context'
import VerificationSection from '@/components/layout/verifications/VerificationSection'

interface HoldPageProps {
  params: {
    account: string
  }
}

export default function HoldPage({ params }: HoldPageProps) {
  const { accountData, isOwner, isDeployed } = useAccount()

  // Handle loading state
  if (!accountData?.tba_address) {
    return (
      <div className="bg-[#111] rounded-xl p-4">
        <div className="text-gray-400">Loading...</div>
      </div>
    )
  }

  return (
    <div className="space-y-6">
      <Portfolio 
        address={accountData.tba_address} 
        context="tokenbound"
        isOwner={isOwner}
        isDeployed={isDeployed}
      />
      <VerificationSection 
        type="account" 
        name={params.account} 
        group={params.account.split('.')[1]} 
      />
    </div>
  )
}
````

## File: src/app/(accounts)/[account]/presence/page.tsx
````typescript
'use client'

import { PlaceTab, ImpactTab, ReputationTab } from '@/modules/account-modules'
import TabbedModules from '@/modules/account-modules'
import { useAccount } from '@/modules/accounts/context'
import VerificationSection from '@/components/layout/verifications/VerificationSection'

interface PresencePageProps {
  params: {
    account: string
  }
}

export default function PresencePage({ params }: PresencePageProps) {
  const { accountData, isOwner } = useAccount()

  // Handle loading state
  if (!accountData?.tba_address) {
    return (
      <div className="bg-[#111] rounded-xl p-4">
        <div className="text-gray-400">Loading...</div>
      </div>
    )
  }

  const tabs = [
    {
      value: 'place',
      label: 'Place',
      component: PlaceTab,
      showChainDropdown: false
    },
    {
      value: 'impact',
      label: 'Impact',
      component: ImpactTab,
      showChainDropdown: false
    },
    {
      value: 'reputation',
      label: 'Reputation',
      component: ReputationTab,
      showChainDropdown: false
    }
  ]

  return (
    <div className="space-y-6">
      <TabbedModules 
        tabs={tabs}
        address={accountData.tba_address}
        isOwner={isOwner}
        label="PRESENCE"
      />
      <VerificationSection 
        type="account" 
        name={params.account} 
        group={params.account.split('.')[1]} 
      />
    </div>
  )
}
````

## File: src/app/(accounts)/[account]/tend/page.tsx
````typescript
'use client'

import VerificationSection from '@/components/layout/verifications/VerificationSection'
import { useAccount } from '@/modules/accounts/context'
import GeneralGrid from '@/modules/general/GeneralGrid'

interface TendPageProps {
  params: {
    account: string
  }
}

export default function TendPage({ params }: TendPageProps) {
  const { accountData, isOwner } = useAccount()

  // Handle loading state
  if (!accountData?.tba_address) {
    return (
      <div className="bg-[#111] rounded-xl p-4">
        <div className="text-gray-400">Loading...</div>
      </div>
    )
  }

  // Extract account name without suffix
  const accountName = params.account.split('.')[0]
  const groupName = params.account.split('.')[1]

  return (
    <div className="space-y-6">
      <div className="bg-gray-900/30 rounded-lg p-4">
        <h3 className="text-xl font-medium text-gray-200">
          Collecting and swapping these assets and currencies funds and ensures {params.account}'s work
        </h3>
      </div>
      <GeneralGrid 
        accountContext={{
          name: accountName,
          specific_asset_id: accountData.specific_asset_id
        }}
      />
      <VerificationSection 
        type="account" 
        name={params.account} 
        group={groupName} 
      />
    </div>
  )
}
````

## File: src/app/(accounts)/[account]/layout.tsx
````typescript
import { notFound } from 'next/navigation'
import AccountHeader from '@/modules/accounts/AccountHeader'
import { AccountNavigation } from '@/components/layout/AccountNavigation'
import { AccountProvider } from '@/modules/accounts/context'
import { accounts } from '@/lib/database/accounts'

interface AccountLayoutProps {
  children: React.ReactNode
  params: {
    account: string
  }
}

export default async function AccountLayout({ children, params }: AccountLayoutProps) {
  const accountData = await accounts.getByFullName(params.account)

  if (!accountData) {
    notFound()
  }
  
  return (
    <AccountProvider accountData={accountData}>
      <div className="container mx-auto px-4 py-8">
        <AccountHeader 
          accountName={accountData.full_account_name}
          tokenId={accountData.token_id}
          tbaAddress={accountData.tba_address}
          groupName={accountData.group_name}
          isAgent={accountData.is_agent}
          isPool={accountData.group_name === 'ensurance' && params.account !== 'situs.ensurance'}
          {...(accountData.group_name === 'ensurance' && params.account !== 'situs.ensurance' ? { displayName: accountData.display_name } : {})}
        />
        <AccountNavigation accountName={params.account} />
        <main className="mt-8">
          {children}
        </main>
      </div>
    </AccountProvider>
  )
}
````

## File: src/app/(accounts)/[account]/page.tsx
````typescript
'use client'

import { useAccount } from '@/modules/accounts/context'
import VerificationSection from '@/components/layout/verifications/VerificationSection'
import GeneralGrid from '@/modules/general/GeneralGrid'
import PortfolioList from '@/modules/account-modules/portfolio/components/PortfolioList'
import Link from 'next/link'
import { ArrowRight } from 'lucide-react'
import { usePortfolioData } from '@/modules/account-modules/portfolio/hooks/usePortfolioData'

interface AccountPageProps {
  params: {
    account: string
  }
}

export default function AccountPage({ params }: AccountPageProps) {
  const { accountData, isOwner, isDeployed } = useAccount()
  const accountName = params.account.split('.')[0]
  const groupName = params.account.split('.')[1]
  const { tokens: portfolioTokens, isLoading: loadingPortfolio } = usePortfolioData(accountData?.tba_address || '')

  // Handle loading state
  if (!accountData?.tba_address) {
    return (
      <div className="bg-[#111] rounded-xl p-4">
        <div className="text-gray-400">Loading...</div>
      </div>
    )
  }

  return (
    <div className="min-h-screen flex flex-col">
      <div className="flex-1 mb-4">
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
          {/* TEND Column */}
          <div className="bg-gray-900/30 rounded-lg p-4">
            <div className="flex items-center justify-between mb-4">
              <div className="text-xl font-medium text-gray-200">
                TEND
              </div>
              <Link 
                href={`/${params.account}/tend`}
                className="text-sm text-gray-400 hover:text-white flex items-center gap-1"
              >
                View all <ArrowRight className="w-4 h-4" />
              </Link>
            </div>
            <div className="text-sm text-gray-400 mb-4">
              Collecting and swapping these assets and currencies funds and ensures {params.account}'s work
            </div>
            <GeneralGrid 
              accountContext={{
                name: accountName,
                specific_asset_id: accountData.specific_asset_id
              }}
              isOverview={true}
              hideMarketData={true}
            />
            <div className="mt-4 pt-4 border-t border-gray-800">
              <Link 
                href={`/${params.account}/tend`}
                className="text-sm text-gray-400 hover:text-white flex items-center justify-center gap-1"
              >
                View all certificates <ArrowRight className="w-4 h-4" />
              </Link>
            </div>
          </div>

          {/* HOLD Column */}
          <div className="bg-gray-900/30 rounded-lg p-4">
            <div className="flex items-center justify-between mb-4">
              <div className="text-xl font-medium text-gray-200">
                HOLD
              </div>
              <Link 
                href={`/${params.account}/hold`}
                className="text-sm text-gray-400 hover:text-white flex items-center gap-1"
              >
                View all <ArrowRight className="w-4 h-4" />
              </Link>
            </div>
            <div className="text-sm text-gray-400 mb-4">
              Assets and currencies that {params.account} holds and manages
            </div>
            {loadingPortfolio ? (
              <div className="text-center py-8">
                <div className="text-gray-500">Loading portfolio...</div>
              </div>
            ) : (
              <>
                <PortfolioList 
                  tokens={portfolioTokens}
                  isOverview={true}
                  address={accountData.tba_address}
                  context="tokenbound"
                  account={params.account}
                  isOwner={isOwner}
                  isDeployed={isDeployed}
                />
                <div className="mt-4 pt-4 border-t border-gray-800">
                  <Link 
                    href={`/${params.account}/hold`}
                    className="text-sm text-gray-400 hover:text-white flex items-center justify-center gap-1"
                  >
                    View all assets <ArrowRight className="w-4 h-4" />
                  </Link>
                </div>
              </>
            )}
          </div>
        </div>
      </div>
      <VerificationSection 
        type="account" 
        name={params.account} 
        group={groupName} 
      />
    </div>
  )
}
````

## File: src/app/(accounts)/agents/page.tsx
````typescript
'use client'

import { useState } from 'react'
import AccountsGrid from '@/modules/accounts/AccountsGrid'
import { PageHeader } from '@/components/layout/PageHeader'

export default function AgentsPage() {
  const [searchQuery, setSearchQuery] = useState('')

  return (
    <div className="min-h-screen flex flex-col">
      <div className="container mx-auto px-4 py-8 flex-1">
        <div className="space-y-4">
          <PageHeader
            title="ensurance agents"
            searchQuery={searchQuery}
            setSearchQuery={setSearchQuery}
            searchPlaceholder="Search agents..."
          />
          <AccountsGrid searchQuery={searchQuery} isAgent={true} />
        </div>
      </div>
    </div>
  )
}
````

## File: src/app/(accounts)/all/page.tsx
````typescript
'use client'

import { useState } from 'react'
import AccountsGrid from '@/modules/accounts/AccountsGrid'
import { PageHeader } from '@/components/layout/PageHeader'

export default function AllAccountsPage() {
  const [searchQuery, setSearchQuery] = useState('')

  return (
    <div className="min-h-screen flex flex-col">
      <div className="container mx-auto px-4 py-8 flex-1">
        <div className="space-y-4">
          <PageHeader
            title="all accounts"
            searchQuery={searchQuery}
            setSearchQuery={setSearchQuery}
          />
          <AccountsGrid searchQuery={searchQuery} />
        </div>
      </div>
    </div>
  )
}
````

## File: src/app/(accounts)/create/page.tsx
````typescript
'use client'

import Image from 'next/image'
import { PageHeader } from '@/components/layout/PageHeader'

export default function CreateAccountPage() {
  return (
    <div className="min-h-screen flex flex-col">
      <div className="container mx-auto px-4 py-8 flex-1">
        <div className="space-y-4">
          <PageHeader
            title="create agent account"
            showSearch={false}
          />
          <div className="flex items-center justify-center py-12">
            <div className="w-20 h-20 flex-shrink-0 mr-6">
              <Image
                src="/groups/orbs/ensurance-orb.png"
                alt="Ensurance orb"
                width={80}
                height={80}
                className="rounded-full"
              />
            </div>
            <div>
              <p className="text-xl font-mono text-white-400 mb-4">
                Create your own account...
              </p>
              <p className="text-gray-500 font-mono">
                Account creation is coming soon.{' '}
                <a 
                  href="https://x.com/ensurance_app" 
                  target="_blank" 
                  rel="noopener noreferrer"
                  className="text-blue-400 hover:text-blue-300 transition-colors"
                >
                  follow updates here
                </a>
                .
              </p>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}
````

## File: src/app/(accounts)/mine/page.tsx
````typescript
'use client'

import { useState } from 'react'
import { usePrivy } from '@privy-io/react-auth'
import AccountsGrid from '@/modules/accounts/AccountsGrid'
import { PageHeader } from '@/components/layout/PageHeader'

export default function MinePage() {
  const [searchQuery, setSearchQuery] = useState('')
  const { user, ready, authenticated } = usePrivy()
  const walletAddress = user?.wallet?.address

  // If not ready or not connected, show appropriate message
  if (!ready) {
    return (
      <div className="min-h-screen flex flex-col">
        <div className="flex-1 flex flex-col items-center justify-center p-8">
          <p className="text-xl text-center mb-4">Loading...</p>
          <p className="text-gray-500 text-center">Please wait...</p>
        </div>  
      </div>
    )
  }

  if (!authenticated || !walletAddress) {
    return (
      <div className="min-h-screen flex flex-col">
        <div className="flex-1 flex flex-col items-center justify-center p-8">
          <p className="text-xl text-center mb-4">👋 Connect your wallet</p>
          <p className="text-gray-500 text-center">
            Connect your wallet to view your accounts and manage your assets
          </p>
        </div>
      </div>
    )
  }

  return (
    <div className="min-h-screen flex flex-col">
      <div className="container mx-auto px-4 py-8 flex-1">
        <div className="space-y-4">
          <PageHeader
            title="my agent accounts"
            searchQuery={searchQuery}
            setSearchQuery={setSearchQuery}
          />
          <AccountsGrid 
            searchQuery={searchQuery}
            walletAddress={walletAddress}
          />
        </div>
      </div>
    </div>
  )
}
````

## File: src/app/admin/exports/page.tsx
````typescript
'use client'

export const dynamic = 'force-dynamic'

import { useState, useEffect } from 'react'
import { isAppAdmin } from '@/config/admin'
import { usePrivy } from '@privy-io/react-auth'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"

interface TableInfo {
  table_name: string;
  columns: string[];
  primary_key: string;
}

export default function ExportsPage() {
  const { user } = usePrivy()
  const [tables, setTables] = useState<TableInfo[]>([])
  const [selectedTable, setSelectedTable] = useState<string>('')
  const [selectedColumns, setSelectedColumns] = useState<string[]>([])
  const [loading, setLoading] = useState(false)

  useEffect(() => {
    // Fetch available tables
    const fetchTables = async () => {
      const response = await fetch('/api/admin/export', {
        headers: {
          'x-address': user?.wallet?.address || ''
        }
      })
      const data = await response.json()
      setTables(data)
    }

    if (user?.wallet?.address) {
      fetchTables()
    }
  }, [user?.wallet?.address])

  // When table is selected, automatically include its primary key
  useEffect(() => {
    if (selectedTable) {
      const tableInfo = tables.find(t => t.table_name === selectedTable)
      if (tableInfo) {
        setSelectedColumns([tableInfo.primary_key])
      }
    }
  }, [selectedTable, tables])

  const handleExport = async () => {
    if (!selectedTable || selectedColumns.length === 0) return
    
    setLoading(true)
    try {
      const response = await fetch('/api/admin/export', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-address': user?.wallet?.address || ''
        },
        body: JSON.stringify({
          table: selectedTable,
          columns: selectedColumns,
        }),
      })
      
      if (!response.ok) throw new Error('Export failed')
      
      const blob = await response.blob()
      const url = window.URL.createObjectURL(blob)
      const a = document.createElement('a')
      a.href = url
      a.download = `${selectedTable}-export.csv`
      document.body.appendChild(a)
      a.click()
      window.URL.revokeObjectURL(url)
      document.body.removeChild(a)
    } catch (error) {
      console.error('Export error:', error)
      alert('Export failed. Please try again.')
    } finally {
      setLoading(false)
    }
  }

  // Only show page to admins
  if (!isAppAdmin(user?.wallet?.address)) {
    return <div className="p-8">Access denied</div>
  }

  const selectedTableInfo = selectedTable ? tables.find(t => t.table_name === selectedTable) : null

  return (
    <div className="container mx-auto p-8">
      <h1 className="text-2xl font-bold mb-6">Database Exports</h1>
      
      <div className="space-y-6">
        {/* Table Selection */}
        <div>
          <label className="block text-sm font-medium mb-2 text-white">Select Table</label>
          <Select
            value={selectedTable}
            onValueChange={(value) => {
              setSelectedTable(value)
              // Primary key will be auto-selected by useEffect
              setSelectedColumns([])
            }}
          >
            <SelectTrigger className="w-full bg-gray-900 text-white border-gray-700">
              <SelectValue placeholder="Choose a table..." />
            </SelectTrigger>
            <SelectContent className="bg-gray-900 border-gray-700">
              {tables.map(table => (
                <SelectItem 
                  key={table.table_name} 
                  value={table.table_name}
                  className="text-white hover:bg-gray-800"
                >
                  {table.table_name}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        </div>

        {/* Column Selection */}
        {selectedTable && selectedTableInfo && (
          <div>
            <label className="block text-sm font-medium mb-2 text-white">Select Columns</label>
            <div className="space-y-2 bg-gray-900 p-4 rounded-md border border-gray-700">
              {selectedTableInfo.columns.map(column => (
                <label 
                  key={column} 
                  className={`flex items-center ${column === selectedTableInfo.primary_key ? 'text-blue-400' : 'text-gray-200 hover:text-white'}`}
                >
                  <input
                    type="checkbox"
                    className="mr-2 accent-blue-500"
                    checked={selectedColumns.includes(column)}
                    disabled={column === selectedTableInfo.primary_key}
                    onChange={(e) => {
                      if (e.target.checked) {
                        setSelectedColumns([...selectedColumns, column])
                      } else {
                        setSelectedColumns(selectedColumns.filter(c => c !== column))
                      }
                    }}
                  />
                  {column}
                  {column === selectedTableInfo.primary_key && (
                    <span className="ml-2 text-xs text-blue-400">(Primary Key - Always included)</span>
                  )}
                </label>
              ))}
            </div>
          </div>
        )}

        {/* Export Button */}
        <button
          className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50"
          onClick={handleExport}
          disabled={loading || !selectedTable || selectedColumns.length === 0}
        >
          {loading ? 'Exporting...' : 'Export to CSV'}
        </button>
      </div>
    </div>
  )
}
````

## File: src/app/admin/sync/page.tsx
````typescript
'use client'

export const dynamic = 'force-dynamic'

import { useState, useEffect } from 'react'
import { usePrivy } from '@privy-io/react-auth'
import { isAppAdmin } from '@/config/admin'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import type { SyncEntity, SyncOperationResult } from '@/modules/admin/sync/types'

export default function SyncPage() {
  const { user } = usePrivy()
  const [syncing, setSyncing] = useState(false)
  const [selectedEntity, setSelectedEntity] = useState<SyncEntity>('groups')
  const [selectedGroup, setSelectedGroup] = useState<string>('all')
  const [tokenId, setTokenId] = useState('')
  const [emptyOnly, setEmptyOnly] = useState(false)
  const [batchProcess, setBatchProcess] = useState(false)
  const [result, setResult] = useState<SyncOperationResult | null>(null)
  const [error, setError] = useState<string | null>(null)
  const [groups, setGroups] = useState<any[]>([])
  const [loadingGroups, setLoadingGroups] = useState(false)

  const handleSync = async (marketData: boolean = false, batchProcess: boolean = false) => {
    if (!user?.wallet?.address) return
    
    setError(null)
    setSyncing(true)
    
    try {
      // Build sync options
      const options = {
        entity: selectedEntity,
        ...(selectedGroup !== 'all' && { group_name: selectedGroup }),
        ...(tokenId && { token_id: parseInt(tokenId) }),
        ...(selectedEntity === 'general_certificates' && { 
          empty_only: emptyOnly,
          market_data: marketData,
          batch_process: batchProcess
        })
      }

      const response = await fetch('/api/admin/sync', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-address': user.wallet.address
        },
        body: JSON.stringify(options)
      })

      if (!response.ok) {
        const error = await response.json()
        throw new Error(error.error || 'Sync failed')
      }

      const data = await response.json()
      setResult(data)
    } catch (err: any) {
      console.error('Sync error:', err)
      setError(err.message)
    } finally {
      setSyncing(false)
    }
  }

  // Fetch active groups from database
  useEffect(() => {
    const fetchGroups = async () => {
      if (!user?.wallet?.address) return

      setLoadingGroups(true)
      try {
        const response = await fetch('/api/groups')
        if (!response.ok) {
          throw new Error('Failed to fetch groups')
        }

        const data = await response.json()
        setGroups(data)
      } catch (err) {
        console.error('Error fetching groups:', err)
      } finally {
        setLoadingGroups(false)
      }
    }

    fetchGroups()
  }, [user?.wallet?.address])

  // Only show page to admins
  if (!isAppAdmin(user?.wallet?.address)) {
    return <div className="p-8">Access denied</div>
  }

  return (
    <div className="container mx-auto p-8">
      <h1 className="text-2xl font-bold mb-6">Admin Sync</h1>
      
      <div className="space-y-6">
        {/* Entity Selection */}
        <div>
          <label className="block text-sm font-medium mb-2 text-white">Entity Type</label>
          <Select
            value={selectedEntity}
            onValueChange={(value) => {
              setSelectedEntity(value as SyncEntity)
              setSelectedGroup('all')
              setTokenId('')
              setEmptyOnly(false)
              setBatchProcess(false)
            }}
          >
            <SelectTrigger className="w-full bg-gray-900 text-white border-gray-700">
              <SelectValue placeholder="Select entity type" />
            </SelectTrigger>
            <SelectContent className="bg-gray-900 border-gray-700">
              <SelectItem value="groups">Groups</SelectItem>
              <SelectItem value="accounts">Accounts</SelectItem>
              <SelectItem value="general_certificates">General Certificates</SelectItem>
            </SelectContent>
          </Select>
        </div>

        {/* Group Selection - only show for accounts */}
        {selectedEntity === 'accounts' && (
          <div>
            <label className="block text-sm font-medium mb-2 text-white">Group</label>
            <Select
              value={selectedGroup}
              onValueChange={setSelectedGroup}
              disabled={loadingGroups}
            >
              <SelectTrigger 
                className="w-full bg-gray-900 text-white border-gray-700"
              >
                <SelectValue placeholder="Select group" />
              </SelectTrigger>
              <SelectContent className="bg-gray-900 border-gray-700">
                <SelectItem value="all">All Groups</SelectItem>
                {groups.map((group) => (
                  <SelectItem key={group.group_name} value={group.group_name}>
                    {group.group_name}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
        )}

        {/* Token ID Input - only show for accounts */}
        {selectedEntity === 'accounts' && (
          <div>
            <label className="block text-sm font-medium mb-2 text-white">Token ID (Optional)</label>
            <input
              type="number"
              value={tokenId}
              onChange={(e) => setTokenId(e.target.value)}
              className="w-full p-2 rounded bg-gray-800 text-white border border-gray-700"
              placeholder="Enter token ID"
            />
          </div>
        )}

        {/* Empty Only Checkbox - only show for general certificates */}
        {selectedEntity === 'general_certificates' && (
          <div className="flex items-center space-x-2">
            <input
              type="checkbox"
              id="emptyOnly"
              checked={emptyOnly}
              onChange={(e) => setEmptyOnly(e.target.checked)}
              className="rounded border-gray-700"
            />
            <label htmlFor="emptyOnly" className="text-sm font-medium text-white">
              Only sync certificates with missing data
            </label>
          </div>
        )}

        {/* Sync Buttons */}
        <div className="space-y-4">
          {selectedEntity === 'general_certificates' ? (
            <>
              <button
                onClick={() => handleSync(false)}
                disabled={syncing || !user?.wallet?.address}
                className="w-full bg-blue-600 text-white py-2 px-4 rounded hover:bg-blue-700 disabled:bg-gray-700 disabled:text-gray-400 transition-colors"
              >
                {syncing ? 'Syncing...' : 'Sync Contract Data'}
              </button>
              <div className="grid grid-cols-2 gap-4">
                <button
                  onClick={() => handleSync(true, false)}
                  disabled={syncing || !user?.wallet?.address}
                  className="w-full bg-purple-600 text-white py-2 px-4 rounded hover:bg-purple-700 disabled:bg-gray-700 disabled:text-gray-400 transition-colors"
                >
                  {syncing ? 'Syncing...' : 'Sync Market Data'}
                </button>
                <button
                  onClick={() => handleSync(true, true)}
                  disabled={syncing || !user?.wallet?.address}
                  className="w-full bg-green-600 text-white py-2 px-4 rounded hover:bg-green-700 disabled:bg-gray-700 disabled:text-gray-400 transition-colors"
                >
                  {syncing ? 'Syncing...' : 'Batch Sync Market Data'}
                </button>
              </div>
            </>
          ) : (
            <button
              onClick={() => handleSync(false)}
              disabled={syncing || !user?.wallet?.address}
              className="w-full bg-blue-600 text-white py-2 px-4 rounded hover:bg-blue-700 disabled:bg-gray-700 disabled:text-gray-400 transition-colors"
            >
              {syncing ? 'Syncing...' : 'Start Sync'}
            </button>
          )}
        </div>

        {/* Error Display */}
        {error && (
          <div className="p-4 bg-red-900/50 border border-red-700 text-red-400 rounded">
            {error}
          </div>
        )}

        {/* Results Display */}
        {result && (
          <div className="mt-6 space-y-4">
            <h2 className="text-xl font-semibold">Sync Results</h2>
            
            {/* Stats */}
            <div className="grid grid-cols-3 gap-4">
              <div className="p-4 border border-gray-700 rounded bg-gray-900/50">
                <div className="text-2xl font-bold">{result.stats.total}</div>
                <div className="text-sm text-gray-400">Total</div>
              </div>
              <div className="p-4 border border-green-700 rounded bg-green-900/50">
                <div className="text-2xl font-bold text-green-400">{result.stats.success}</div>
                <div className="text-sm text-gray-400">Success</div>
              </div>
              <div className="p-4 border border-red-700 rounded bg-red-900/50">
                <div className="text-2xl font-bold text-red-400">{result.stats.failed}</div>
                <div className="text-sm text-gray-400">Failed</div>
              </div>
            </div>

            {/* Detailed Results */}
            <div className="mt-4">
              <h3 className="text-lg font-semibold mb-2">Details</h3>
              <div className="border border-gray-700 rounded bg-gray-900/50 p-4 overflow-auto max-h-96">
                <pre className="text-sm text-gray-300">
                  {JSON.stringify(result.results, null, 2)}
                </pre>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  )
}
````

## File: src/app/admin/layout.tsx
````typescript
import Link from 'next/link'

export default function AdminLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <div className="min-h-screen">
      <nav className="bg-background-light dark:bg-background-dark border-b border-gray-200 dark:border-gray-800">
        <div className="container mx-auto px-4">
          <div className="flex items-center h-16">
            <Link 
              href="/admin"
              className="text-lg font-semibold"
            >
              Admin
            </Link>
            
            <div className="ml-8 space-x-4">
              <Link 
                href="/admin/sync"
                className="text-sm hover:text-blue-500"
              >
                Sync
              </Link>
              <Link 
                href="/admin/exports"
                className="text-sm hover:text-blue-500"
              >
                Exports
              </Link>
            </div>
          </div>
        </div>
      </nav>
      
      <main>
        {children}
      </main>
    </div>
  )
}
````

## File: src/app/admin/page.tsx
````typescript
'use client'

import { Card } from '@/components/ui/card'
import { usePrivy } from '@privy-io/react-auth'
import Link from 'next/link'

export default function AdminPage() {
  const { user } = usePrivy()

  if (!user?.wallet?.address) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <p className="text-lg">Please connect your wallet to access admin features.</p>
      </div>
    )
  }

  const adminLinks = [
    {
      title: 'Sync',
      description: 'Synchronize data between blockchain and database',
      href: '/admin/sync',
    },
    {
      title: 'Exports',
      description: 'Export data and generate reports',
      href: '/admin/exports',
    },
  ]

  return (
    <div className="container mx-auto py-8">
      <h1 className="text-3xl font-bold mb-8">Admin Dashboard</h1>
      
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {adminLinks.map((link) => (
          <Link href={link.href} key={link.href}>
            <Card className="p-6 hover:bg-gray-800 transition-colors cursor-pointer">
              <h2 className="text-xl font-semibold mb-2 text-white">{link.title}</h2>
              <p className="text-gray-400">{link.description}</p>
            </Card>
          </Link>
        ))}
      </div>
    </div>
  )
}
````

## File: src/app/api/0x/route.ts
````typescript
import { NextResponse } from 'next/server';
import { createClientV2 } from '@0x/swap-ts-sdk';

if (!process.env.ZEROX_API_KEY) {
  throw new Error('ZEROX_API_KEY is not configured');
}

// Create the 0x API client
const client = createClientV2({
  apiKey: process.env.ZEROX_API_KEY
});

// Define types for the quote response
type QuoteResponse = {
  sellToken: string;
  buyToken: string;
  sellAmount?: string;
  buyAmount?: string;
  allowanceTarget?: string;
  price?: string;
  estimatedGas?: string;
  gas?: string;
  gasPrice?: string;
  data?: string;
  to?: string;
  value?: string;
  // Add other potential fields
  sources?: Array<{ name: string; proportion: string }>;
  fees?: {
    integratorFee?: { amount: string; type: string; token: string; } | null;
    zeroExFee?: { amount: string; type: string; token: string; } | null;
  };
  // Special fields for "no liquidity" response
  zid?: string;
  liquidityAvailable?: boolean;
  // Transaction information - 0x v2 API returns this nested
  transaction?: {
    to?: string;
    data?: string;
    value?: string;
    gas?: string;
    gasPrice?: string;
  };
  // Permit2 data
  permit2?: {
    type?: string;
    hash?: string;
    eip712?: {
      types: Record<string, Array<{ name: string; type: string }>>;
      domain: Record<string, any>;
      primaryType: string;
      message: Record<string, any>;
    };
  };
};

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const action = searchParams.get('action');
  
  try {
    if (action === 'quote') {
      const sellToken = searchParams.get('sellToken');
      const buyToken = searchParams.get('buyToken');
      const sellAmount = searchParams.get('sellAmount');
      const taker = searchParams.get('taker');
      const slippageBps = searchParams.get('slippageBps') || '200'; // Default 2% slippage
      const swapFeeBps = searchParams.get('swapFeeBps') || '100';  // Default 1% fee

      if (!sellToken || !buyToken || !sellAmount || !taker) {
        return NextResponse.json({ 
          error: 'Missing required parameters',
          details: {
            sellToken: !sellToken ? 'missing' : 'present',
            buyToken: !buyToken ? 'missing' : 'present',
            sellAmount: !sellAmount ? 'missing' : 'present',
            taker: !taker ? 'missing' : 'present'
          }
        }, { status: 400 });
      }

      // Log the incoming parameters
      console.log('Quote request parameters:', {
        chainId: 8453, // Base network
        sellToken,
        buyToken,
        sellAmount,
        taker,
        swapFeeRecipient: '0xa187F8CBdd36D63967c33f5BD4dD4B9ECA51270e',
        swapFeeBps,
        slippageBps
      });

      try {
        // Always include all fee parameters together
        const quoteParams = {
          chainId: 8453, // Base network
          sellToken,
          buyToken,
          sellAmount,
          taker,
          swapFeeRecipient: '0xa187F8CBdd36D63967c33f5BD4dD4B9ECA51270e',
          swapFeeBps: Number(swapFeeBps),
          swapFeeToken: buyToken,
          slippageBps: Number(slippageBps),
          // Exclude problematic sources if needed
          // excludedSources: 'Kyber,Balancer'
        };

        console.log('Requesting permit2 quote with parameters:', quoteParams);
        
        // Get quote from 0x API
        const quote = await client.swap.permit2.getQuote.query(quoteParams, {
          signal: AbortSignal.timeout(10000)
        }) as QuoteResponse;
        
        // In the 0x v2 API, the transaction object should already be properly formatted
        // We shouldn't need to manipulate it, just pass it along as-is
        
        // Verify permit2 data is present for token swaps (not needed for ETH swaps)
        const isNativeEth = sellToken.toLowerCase() === '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee'.toLowerCase();
        if (!isNativeEth && !quote.permit2?.eip712) {
          console.warn('Quote returned without permit2 data for token swap:', {
            sellToken,
            buyToken,
            hasPermit2: !!quote.permit2,
            hasEip712: !!quote.permit2?.eip712
          });
        }
        
        // IMPORTANT: For token swaps, ensure allowanceTarget is properly set
        // This is critical to avoid approving the wrong contract
        if (!isNativeEth && !quote.allowanceTarget && quote.permit2?.type === 'Permit2') {
          console.warn('Quote missing allowanceTarget for token swap, adding canonical Permit2 address');
          // Use canonical Permit2 address if allowanceTarget is missing
          quote.allowanceTarget = '0x000000000022D473030F116dDEE9F6B43aC78BA3';
        }
        
        // Make sure transaction data is present
        if (!quote.transaction || !quote.transaction.to || !quote.transaction.data) {
          console.error('Quote missing expected transaction data:', quote);
          return NextResponse.json({
            error: "Invalid quote response from 0x API",
            details: {
              message: "Missing transaction object in quote response",
              code: "INVALID_RESPONSE"
            }
          }, { status: 500 });
        }
        
        // For debugging purposes, log the important parts of the response
        console.log('Permit2 quote successful:', {
          buyAmount: quote.buyAmount,
          sellAmount: quote.sellAmount,
          gas: quote.transaction?.gas || quote.gas || quote.estimatedGas, 
          to: quote.transaction.to,
          data: quote.transaction.data ? quote.transaction.data.slice(0, 40) + '...' : null,
          allowanceTarget: quote.allowanceTarget,
          chainId: quoteParams.chainId,
          network: 'Base',
          hasPermit2: !!quote.permit2,
          permit2Type: quote.permit2?.type || 'none',
          hasEip712: !!quote.permit2?.eip712
        });

        // Return the response as-is from the 0x API
        return NextResponse.json(quote);
      } catch (sdkError: any) {
        // Enhanced error logging for v2 API responses
        console.error('0x v2 SDK Error:', {
          message: sdkError.message,
          data: sdkError.data,
          shape: sdkError.shape,
          meta: sdkError.meta,
          request: {
            sellToken,
            buyToken,
            sellAmount,
            taker
          }
        });
        
        // Handle the TRPC error format
        let errorCode = 'UNKNOWN_ERROR';
        let errorMessage = sdkError.message || 'Failed to get quote from 0x API';
        
        // Parse API error message
        if (sdkError.message) {
          if (sdkError.message.includes('insufficient liquidity')) {
            errorCode = 'INSUFFICIENT_LIQUIDITY';
          } else if (sdkError.message.includes('invalid token')) {
            errorCode = 'INVALID_TOKEN';
          } else if (sdkError.message.includes('balance')) {
            errorCode = 'INSUFFICIENT_BALANCE';
          }
        }
        
        // Structure error response to match v2 API format
        const errorResponse = {
          error: errorMessage,
          details: {
            message: errorMessage,
            data: sdkError.data || {},
            validationErrors: [],
            code: errorCode
          }
        };

        return NextResponse.json(errorResponse, { status: 400 });
      }
    }
    
    return NextResponse.json({ 
      error: 'Invalid action',
      details: { action }
    }, { status: 400 });
  } catch (error) {
    console.error('0x API error:', error);
    return NextResponse.json(
      { 
        error: error instanceof Error ? error.message : 'Failed to fetch from 0x API',
        details: error instanceof Error ? error.stack : undefined,
        url: request.url
      },
      { status: 500 }
    );
  }
}
````

## File: src/app/api/accounts/[account]/route.ts
````typescript
import { NextResponse } from 'next/server';
import { accounts } from '@/lib/database/accounts';

export async function GET(
    request: Request,
    { params }: { params: { account: string } }
) {
    try {
        console.log('API Route - Fetching account:', params.account);
        const account = await accounts.getByFullName(params.account);
        console.log('API Route - Raw account data:', account);
        
        if (!account) {
            return NextResponse.json(
                { error: 'Account not found', full_account_name: params.account },
                { status: 404 }
            );
        }
        
        return NextResponse.json(account);
    } catch (error) {
        console.error('Error fetching account:', error);
        return NextResponse.json(
            { 
                error: 'Failed to fetch account', 
                details: error instanceof Error ? error.message : 'Unknown error'
            },
            { status: 500 }
        );
    }
}
````

## File: src/app/api/accounts/stats/route.ts
````typescript
import { NextResponse } from 'next/server';
import { sql } from '@vercel/postgres';

export async function POST(request: Request) {
    try {
        const { account_name, stats } = await request.json();
        
        console.log('Updating stats for account:', account_name, 'with data:', stats);
        
        if (!account_name || !stats) {
            return NextResponse.json({ error: 'Missing required fields' }, { status: 400 });
        }

        const groupName = account_name.split('.')[1];
        
        // Only attempt to update stats for .ensurance accounts for now
        if (groupName !== 'ensurance') {
            return NextResponse.json({ 
                message: 'Stats updates only supported for .ensurance accounts currently',
                account: null
            });
        }

        const tableName = `members.accounts_${groupName}`;
        console.log('Using table:', tableName);

        // Update the stats in the database
        const query = `
            UPDATE members.accounts_${groupName}
            SET 
                total_currency_value = $1,
                total_assets = $2,
                ensured_assets = $3,
                stats_last_updated = $4
            WHERE full_account_name = $5
            RETURNING *
        `;

        console.log('Executing query with values:', [
            stats.total_currency_value,
            stats.total_assets,
            stats.ensured_assets,
            stats.stats_last_updated,
            account_name
        ]);

        const result = await sql.query(query, [
            stats.total_currency_value,
            stats.total_assets,
            stats.ensured_assets,
            stats.stats_last_updated,
            account_name
        ]);

        console.log('Query result:', result.rows[0]);

        if (result.rowCount === 0) {
            console.log('No rows updated - account not found:', account_name);
            return NextResponse.json({ error: 'Account not found' }, { status: 404 });
        }

        return NextResponse.json({ 
            message: 'Stats updated successfully',
            account: result.rows[0]
        });

    } catch (error) {
        console.error('Error updating account stats:', error);
        return NextResponse.json({ error: 'Failed to update stats' }, { status: 500 });
    }
}
````

## File: src/app/api/accounts/route.ts
````typescript
import { NextResponse } from 'next/server';
import { accounts } from '@/lib/database/accounts';

// Force dynamic route to ensure fresh data
export const dynamic = 'force-dynamic';

// Cache successful responses for 1 minute
export const revalidate = 60;

// Separate caches for all accounts and group-specific accounts
const CACHE_DURATION = 60 * 1000; // 1 minute
const cache = {
    all: {
        data: null as any,
        timestamp: 0
    },
    byGroup: new Map<string, { data: any, timestamp: number }>()
};

async function getAccountsWithCache(group?: string) {
    const now = Date.now();

    // If group specified, use group-specific cache and getByGroup
    if (group) {
        const groupCache = cache.byGroup.get(group);
        if (groupCache && (now - groupCache.timestamp) < CACHE_DURATION) {
            return groupCache.data;
        }
        
        const data = await accounts.getByGroup(group);
        cache.byGroup.set(group, {
            data,
            timestamp: now
        });
        return data;
    }

    // Otherwise use all accounts cache and getAll
    if (cache.all.data && (now - cache.all.timestamp) < CACHE_DURATION) {
        return cache.all.data;
    }

    const data = await accounts.getAll();
    cache.all = {
        data,
        timestamp: now
    };
    return data;
}

export async function GET(request: Request) {
    try {
        // Parse group from URL
        const { searchParams } = new URL(request.url);
        const group = searchParams.get('group');
        
        const accountData = await getAccountsWithCache(group || undefined);
        
        return NextResponse.json(accountData, {
            headers: {
                'Cache-Control': 'public, s-maxage=60, stale-while-revalidate=300'
            }
        });
    } catch (error) {
        console.error('Error fetching accounts:', error);
        return NextResponse.json(
            { error: 'Failed to fetch accounts' },
            { status: 500 }
        );
    }
}
````

## File: src/app/api/admin/export/route.ts
````typescript
import { NextRequest, NextResponse } from 'next/server'
import { headers } from 'next/headers'
import { isAppAdmin } from '@/config/admin'
import { exportTableData, getExportableTables } from '@/lib/database/admin/export'

export const dynamic = 'force-dynamic'

// Get available tables and their columns
export async function GET(request: Request) {
  try {
    // Check admin access
    const headersList = headers()
    const address = headersList.get('x-address') || undefined
    if (!isAppAdmin(address)) {
      return new NextResponse('Unauthorized', { status: 401 })
    }

    // Get tables info
    const tables = await getExportableTables()
    return NextResponse.json(tables)

  } catch (error) {
    console.error('Get tables error:', error)
    return new NextResponse('Failed to get tables', { status: 500 })
  }
}

// Export table data
export async function POST(request: NextRequest) {
  try {
    // Check admin access
    const headersList = headers()
    const address = headersList.get('x-address') || undefined
    if (!isAppAdmin(address)) {
      return new NextResponse('Unauthorized', { status: 401 })
    }

    // Get request data
    const body = await request.json()
    const { table, columns } = body

    if (!table || !columns || !Array.isArray(columns)) {
      return new NextResponse('Invalid request', { status: 400 })
    }

    // Get data
    const data = await exportTableData(table, columns)

    // Convert to CSV
    const csv = convertToCSV(data)

    // Return CSV file
    return new NextResponse(csv, {
      headers: {
        'Content-Type': 'text/csv',
        'Content-Disposition': `attachment; filename="${table}-export.csv"`
      }
    })

  } catch (error: any) {
    console.error('Export error:', error)
    return new NextResponse(error.message || 'Export failed', { status: 500 })
  }
}

function convertToCSV(data: any[]): string {
  if (data.length === 0) return ''
  
  const headers = Object.keys(data[0])
  const rows = [
    headers.join(','),
    ...data.map(row => 
      headers.map(header => {
        const value = row[header]
        // Handle special cases and escaping
        if (value === null || value === undefined) return ''
        if (typeof value === 'string') return `"${value.replace(/"/g, '""')}"`
        return value
      }).join(',')
    )
  ]
  
  return rows.join('\n')
}
````

## File: src/app/api/admin/sync/route.ts
````typescript
import { NextRequest, NextResponse } from 'next/server';
import { headers } from 'next/headers';
import { isAppAdmin } from '@/config/admin';
import { sync } from '@/modules/admin/sync/service';
import type { SyncEntity } from '@/modules/admin/sync/types';

export const dynamic = 'force-dynamic';

// Sync data from onchain to database
export async function POST(request: NextRequest) {
  try {
    // Check admin access
    const headersList = headers();
    const address = headersList.get('x-address') || undefined;
    if (!isAppAdmin(address)) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Get request data
    const body = await request.json();
    const { entity, group_name, token_id, empty_only, market_data, batch_process } = body;

    if (!entity) {
      return NextResponse.json({ error: 'Invalid request - entity required' }, { status: 400 });
    }

    console.log('Sync request:', { entity, group_name, token_id, empty_only, market_data, batch_process });

    // Run sync operation
    const result = await sync(entity as SyncEntity, { 
      group_name, 
      token_id, 
      empty_only,
      market_data,
      batch_process
    });
    return NextResponse.json(result);

  } catch (error: any) {
    console.error('Sync error:', error);
    return NextResponse.json({ error: error.message || 'Sync failed' }, { status: 500 });
  }
}
````

## File: src/app/api/alchemy/fungible/route.ts
````typescript
import { NextResponse } from 'next/server';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const address = searchParams.get('address');

  if (!address) {
    return NextResponse.json({ error: 'Address is required' }, { status: 400 });
  }

  if (!process.env.ALCHEMY_API_KEY) {
    console.error('ALCHEMY_API_KEY is not configured');
    return NextResponse.json({ error: 'API key not configured' }, { status: 500 });
  }

  const url = `https://api.g.alchemy.com/data/v1/${process.env.ALCHEMY_API_KEY}/assets/tokens/by-address`;
  
  try {
    console.log('Fetching from URL:', url);
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'accept': 'application/json',
        'content-type': 'application/json',
      },
      body: JSON.stringify({
        addresses: [{
          address: address,
          networks: ['base-mainnet']
        }],
        withMetadata: true,
        withPrices: true,
        includeNativeTokens: true
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('Alchemy API error:', {
        status: response.status,
        statusText: response.statusText,
        body: errorText
      });
      throw new Error(`API request failed: ${response.status} ${response.statusText}`);
    }

    const data = await response.json();
    return NextResponse.json(data);
  } catch (error) {
    console.error('Error fetching tokens:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to fetch tokens' },
      { status: 500 }
    );
  }
}
````

## File: src/app/api/alchemy/nonfungible/route.ts
````typescript
import { NextResponse } from 'next/server';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const address = searchParams.get('address');
  const contractAddresses = searchParams.get('contractAddresses')?.split(',');

  if (!address) {
    return NextResponse.json({ error: 'Address is required' }, { status: 400 });
  }

  if (!process.env.ALCHEMY_API_KEY) {
    console.error('ALCHEMY_API_KEY is not configured');
    return NextResponse.json({ error: 'API key not configured' }, { status: 500 });
  }

  if (contractAddresses && contractAddresses.length > 0) {
    try {
      console.log('Fetching NFTs for address with contract filter:', { address, contractAddresses });
      const url = new URL(`https://base-mainnet.g.alchemy.com/nft/v3/${process.env.ALCHEMY_API_KEY}/getNFTsForOwner`);
      
      url.searchParams.append('owner', address);
      contractAddresses.forEach(addr => url.searchParams.append('contractAddresses[]', addr));
      url.searchParams.append('withMetadata', 'true');

      const response = await fetch(url.toString(), {
        method: 'GET',
        headers: {
          'accept': 'application/json',
        }
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error('Alchemy API error:', {
          status: response.status,
          statusText: response.statusText,
          body: errorText
        });
        throw new Error(`API request failed: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      return NextResponse.json(data);
    } catch (error) {
      console.error('Error fetching NFTs with contract filter:', error);
      return NextResponse.json(
        { error: error instanceof Error ? error.message : 'Failed to fetch NFTs' },
        { status: 500 }
      );
    }
  }

  const url = `https://api.g.alchemy.com/data/v1/${process.env.ALCHEMY_API_KEY}/assets/nfts/by-address`;
  
  try {
    console.log('Fetching NFTs for address:', address);
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'accept': 'application/json',
        'content-type': 'application/json'
      },
      body: JSON.stringify({
        addresses: [{
          address: address,
          networks: ['base-mainnet']
        }],
        withMetadata: true
      })
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('Alchemy API error:', {
        status: response.status,
        statusText: response.statusText,
        body: errorText
      });
      throw new Error(`API request failed: ${response.status} ${response.statusText}`);
    }

    const data = await response.json();
    return NextResponse.json(data);
  } catch (error) {
    console.error('Error fetching NFTs:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to fetch NFTs' },
      { status: 500 }
    );
  }
}
````

## File: src/app/api/currencies/route.ts
````typescript
import { NextRequest, NextResponse } from 'next/server';
import { currencies } from '@/lib/database/config/currencies';

// Force dynamic route to ensure fresh data
export const dynamic = 'force-dynamic';

export async function GET(request: Request) {
  try {
    const allCurrencies = await currencies.getAll();
    return NextResponse.json(allCurrencies);
  } catch (error) {
    console.error('[Currencies API] Error:', error);
    return NextResponse.json({ 
      error: 'Failed to fetch currencies', 
      details: error instanceof Error ? error.message : String(error)
    }, { status: 500 });
  }
}

export async function POST(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const address = searchParams.get('address');

    if (!address) {
      return NextResponse.json({ error: 'Address is required' }, { status: 400 });
    }

    const currency = await currencies.getByAddress(address);
    if (!currency) {
      return NextResponse.json({ error: 'Currency not found' }, { status: 404 });
    }

    // Here you can add market data fetching if needed
    // Similar to how it's done in general/route.ts

    return NextResponse.json({ success: true });

  } catch (error) {
    console.error('[Currencies API] Error:', error);
    return NextResponse.json({ 
      error: 'Failed to refresh currency data', 
      details: error instanceof Error ? error.message : String(error)
    }, { status: 500 });
  }
}
````

## File: src/app/api/ensure/route.ts
````typescript
import { accounts } from '@/lib/database/accounts';
import { groups } from '@/lib/database/groups';
import { NextRequest, NextResponse } from 'next/server';
import { getContractTokens } from '@/modules/specific/collect';
import { CONTRACTS } from '@/modules/specific/config';

export const revalidate = 60;
export const dynamic = 'force-dynamic';

// Simple in-memory cache with stale-while-revalidate (copied from search API)
let cache = {
    groups: { data: null, timestamp: 0, isRevalidating: false },
    accounts: { data: null, timestamp: 0, isRevalidating: false },
    general: { data: null, timestamp: 0, isRevalidating: false },
    specific: { data: null, timestamp: 0, isRevalidating: false },
    syndicates: { data: null, timestamp: 0, isRevalidating: false }
};

// Separate cache for individual metadata entries (more granular)
let metadataCache: Record<string, { data: any, timestamp: number }> = {};

const CACHE_TTL = 60000; // 1 minute
const STALE_TTL = 300000; // 5 minutes

function isCacheValid(type: keyof typeof cache) {
    const cacheEntry = cache[type];
    return cacheEntry.data && (Date.now() - cacheEntry.timestamp) < CACHE_TTL;
}

async function getDataWithCache(type: keyof typeof cache, fetchFn: () => Promise<any>) {
    const cacheEntry = cache[type];
    
    // Return fresh cache
    if (isCacheValid(type)) {
        return cacheEntry.data;
    }
    
    // Return stale cache and revalidate in background
    if (cacheEntry.data && !cacheEntry.isRevalidating) {
        cacheEntry.isRevalidating = true;
        fetchFn().then(newData => {
            cache[type] = { data: newData, timestamp: Date.now(), isRevalidating: false };
        }).catch(error => {
            console.error(`Background revalidation failed for ${type}:`, error);
            cacheEntry.isRevalidating = false;
        });
        return cacheEntry.data;
    }
    
    // No cache or stale cache, fetch new data
    try {
        const newData = await fetchFn();
        cache[type] = { data: newData, timestamp: Date.now(), isRevalidating: false };
        return newData;
    } catch (error) {
        console.error(`Failed to fetch ${type}:`, error);
        return cacheEntry.data || []; // Return stale data if available, empty array if not
    }
}

export async function GET(request: NextRequest) {
    try {
        // Check if metadata is requested separately
        const includeMetadata = request.nextUrl.searchParams.get('metadata') !== 'false';
        
        // Build absolute base URL for internal fetches
        const protocol = request.headers.get('x-forwarded-proto') || 'http';
        const host = request.headers.get('host');
        const baseUrl = `${protocol}://${host}`;
        
        // Fetch all data types in parallel using the same caching as search API
        const [
            groupsData,
            accountsData,
            generalData,
            specificData,
            syndicatesData
        ] = await Promise.all([
            getDataWithCache('groups', () => groups.getAll()),
            getDataWithCache('accounts', () => accounts.getAll()),
            getDataWithCache('general', () => fetch(`${baseUrl}/api/general`).then(r => r.json())),
            getDataWithCache('specific', () => getContractTokens(CONTRACTS.specific)),
            getDataWithCache('syndicates', () => fetch(`${baseUrl}/api/syndicates`).then(r => r.json()))
        ]);

        // Transform data to match EnsureMagnet expectations
        const generalCertificates = await Promise.all(
            (generalData || [])
                .filter((cert: any) => cert && cert.contract_address)
                .map(async (cert: any) => {
                    let image_url = cert.image_url;
                    
                    // If no image_url, try to fetch from our image utility
                    if (!image_url) {
                        try {
                            const imageResponse = await fetch(`${baseUrl}/api/utilities/image?address=${cert.contract_address}&tokenType=erc20`);
                            if (imageResponse.ok) {
                                const imageData = await imageResponse.json();
                                image_url = imageData.url;
                            }
                        } catch (error) {
                            console.error(`Failed to fetch image for ${cert.contract_address}:`, error);
                        }
                    }
                    
                    return {
                        contract_address: cert.contract_address,
                        name: cert.name,
                        description: cert.description,
                        image_url: image_url || '/assets/no-image-found.png',
                        type: 'general' as const
                    };
                })
        );

        const specificCertificates = (specificData || []).map((token: any) => ({
            tokenURI: token.tokenURI,
            type: 'specific' as const
        }));

        const accountsWithType = (accountsData || []).map((account: any) => ({
            full_account_name: account.full_account_name,
            token_id: account.token_id,
            group_name: account.group_name,
            is_agent: account.is_agent,
            description: account.description,
            type: 'account' as const
        }));

        const groupsWithType = (groupsData || [])
            .filter((group: any) => group.is_active)
            .map((group: any) => ({
                group_name: group.group_name,
                name_front: group.name_front,
                tagline: group.tagline,
                description: group.description,
                type: 'group' as const
            }));

        const syndicatesWithType = (syndicatesData || []).map((syndicate: any) => ({
            name: syndicate.name,
            description: syndicate.description,
            media: syndicate.media,
            image_url: syndicate.image_url,
            type: 'syndicate' as const
        }));

        // Combine all items
        const allItems = [
            ...generalCertificates,
            ...specificCertificates,
            ...accountsWithType,
            ...groupsWithType,
            ...syndicatesWithType
        ];

        // If metadata not requested, return immediately
        if (!includeMetadata) {
            return NextResponse.json({
                items: allItems,
                tokenMetadata: {}
            });
        }

        // Fetch metadata for specific certificates using granular cache
        const tokenMetadata: Record<string, any> = {};
        if (specificCertificates.length > 0) {
            await Promise.all(
                specificCertificates.map(async (token: any) => {
                    const tokenURI = token.tokenURI;
                    
                    // Check individual metadata cache
                    const cached = metadataCache[tokenURI];
                    if (cached && (Date.now() - cached.timestamp) < CACHE_TTL) {
                        tokenMetadata[tokenURI] = cached.data;
                        return;
                    }
                    
                    try {
                        let metadata;
                        if (tokenURI.startsWith('http')) {
                            const response = await fetch(tokenURI);
                            if (response.ok) {
                                metadata = await response.json();
                            } else {
                                throw new Error('Failed to fetch metadata');
                            }
                        } else {
                            metadata = JSON.parse(tokenURI);
                        }
                        
                        // Cache individual metadata entry
                        metadataCache[tokenURI] = { data: metadata, timestamp: Date.now() };
                        tokenMetadata[tokenURI] = metadata;
                    } catch (error) {
                        console.error(`Error fetching metadata for ${tokenURI}:`, error);
                        const errorData = { error: true };
                        metadataCache[tokenURI] = { data: errorData, timestamp: Date.now() };
                        tokenMetadata[tokenURI] = errorData;
                    }
                })
            );
        }

        return NextResponse.json({
            items: allItems,
            tokenMetadata
        });

    } catch (error) {
        console.error('[Ensure API] Error:', error);
        return NextResponse.json(
            { 
                error: 'Failed to fetch ensure data',
                details: error instanceof Error ? error.message : String(error)
            },
            { status: 500 }
        );
    }
}
````

## File: src/app/api/eth-price/route.ts
````typescript
import { NextResponse } from 'next/server'

export async function GET() {
  try {
    const response = await fetch(
      'https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=usd',
      {
        headers: {
          'Accept': 'application/json',
        },
        next: { revalidate: 60 } // Cache for 60 seconds
      }
    )

    if (!response.ok) {
      throw new Error(`CoinGecko API error: ${response.status} ${response.statusText}`)
    }

    const data = await response.json()
    const price = data.ethereum?.usd

    if (!price) {
      throw new Error('Invalid price data from CoinGecko')
    }

    return NextResponse.json({
      price,
      symbol: 'eth',
      lastUpdated: Math.floor(Date.now() / 1000)
    })
  } catch (error) {
    console.error('Error fetching ETH price:', error)
    return NextResponse.json(
      { error: 'Failed to fetch ETH price' },
      { status: 500 }
    )
  }
}
````

## File: src/app/api/general/route.ts
````typescript
import { NextRequest, NextResponse } from 'next/server';
import { sql } from '@vercel/postgres';
import { getCoin } from '@zoralabs/coins-sdk';
import { base } from 'viem/chains';

// Force dynamic route to ensure fresh data
export const dynamic = 'force-dynamic';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const limit = parseInt(searchParams.get('limit') || '100');
  const page = parseInt(searchParams.get('page') || '1');
  const offset = (page - 1) * limit;

  try {
    // Get certificates from DB
    const query = `
      SELECT * FROM certificates.general
      WHERE chain = 'base'
      ORDER BY name, contract_address
      LIMIT $1 OFFSET $2
    `;
    
    const result = await sql.query(query, [limit, offset]);
    
    // Get market data for each certificate
    const certificatesWithMarketData = await Promise.all(
      result.rows.map(async (cert) => {
        try {
          // Check if market data is stale (older than 1 hour)
          const lastUpdate = cert.last_market_update ? new Date(cert.last_market_update) : null;
          const now = new Date();
          const hoursSinceUpdate = lastUpdate ? (now.getTime() - lastUpdate.getTime()) / (1000 * 60 * 60) : Infinity;
          
          // Only fetch new data if it's stale
          if (hoursSinceUpdate > 1) {
            console.log(`Market data for ${cert.contract_address} is stale (${hoursSinceUpdate.toFixed(1)} hours old), fetching fresh data...`);
            
            const response = await getCoin({
              address: cert.contract_address
            });
            
            const coin = response.data?.zora20Token;
            if (!coin) return cert;

            // Update the database with fresh data
            await sql`
              UPDATE certificates.general
              SET 
                total_volume = ${coin.totalVolume || '0'},
                volume_24h = ${coin.volume24h || '0'},
                market_cap = ${coin.marketCap || '0'},
                creator_earnings = ${JSON.stringify(coin.creatorEarnings || [])},
                unique_holders = ${coin.uniqueHolders || 0},
                last_market_update = NOW()
              WHERE contract_address = ${cert.contract_address}
            `;

            return {
              ...cert,
              total_volume: coin.totalVolume || '0',
              volume_24h: coin.volume24h || '0',
              market_cap: coin.marketCap || '0',
              creator_earnings: coin.creatorEarnings || [],
              last_market_update: new Date().toISOString()
            };
          } else {
            console.log(`Market data for ${cert.contract_address} is fresh (${hoursSinceUpdate.toFixed(1)} hours old)`);
            return cert;
          }
        } catch (error) {
          console.error(`Failed to fetch market data for ${cert.contract_address}:`, error);
          return cert;
        }
      })
    );

    return NextResponse.json(certificatesWithMarketData);

  } catch (error) {
    console.error('[General Certificates API] Error:', error);
    return NextResponse.json({ 
      error: 'Failed to fetch general certificates', 
      details: error instanceof Error ? error.message : String(error)
    }, { status: 500 });
  }
}

export async function POST(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const address = searchParams.get('address');

    if (!address) {
      return NextResponse.json({ error: 'Address is required' }, { status: 400 });
    }

    // Get market data from Zora
    const response = await getCoin({
      address: address as `0x${string}`,
      chain: base.id
    });

    if (!response?.data?.zora20Token) {
      return NextResponse.json({ error: 'No market data available' }, { status: 404 });
    }

    const coinData = response.data.zora20Token;

    // Update market data in database
    await sql`
      UPDATE certificates.general
      SET 
        total_volume = ${coinData.totalVolume || '0'},
        volume_24h = ${coinData.volume24h || '0'},
        market_cap = ${coinData.marketCap || '0'},
        creator_earnings = ${JSON.stringify(coinData.creatorEarnings || [])},
        unique_holders = ${coinData.uniqueHolders || 0},
        last_market_update = NOW()
      WHERE contract_address = ${address}
    `;

    return NextResponse.json({ success: true });

  } catch (error) {
    console.error('[General Certificates API] Error:', error);
    return NextResponse.json({ 
      error: 'Failed to refresh market data', 
      details: error instanceof Error ? error.message : String(error)
    }, { status: 500 });
  }
}
````

## File: src/app/api/groups/route.ts
````typescript
import { NextRequest, NextResponse } from 'next/server';
import { groups } from '@/lib/database/groups';

// Force dynamic route to ensure fresh data
export const dynamic = 'force-dynamic';

// Cache successful responses for 1 hour
export const revalidate = 3600;

export async function GET(request: NextRequest) {
    try {
        const { searchParams } = new URL(request.url);
        const groupName = searchParams.get('group_name');

        if (groupName) {
            const group = await groups.getByName(groupName);
            return NextResponse.json(group, {
                headers: {
                    'Cache-Control': 'public, s-maxage=3600, stale-while-revalidate=86400',
                },
            });
        }

        const allGroups = await groups.getAll();
        return NextResponse.json(allGroups, {
            headers: {
                'Cache-Control': 'public, s-maxage=3600, stale-while-revalidate=86400',
            },
        });
    } catch (error) {
        console.error('Error fetching groups:', error);
        return NextResponse.json(
            { error: 'Failed to fetch groups' },
            { status: 500 }
        );
    }
}

// POST method doesn't need caching since it's modifying data
export async function POST(request: NextRequest) {
    try {
        const data = await request.json();
        const result = await groups.create(data);
        return NextResponse.json(result);
    } catch (error) {
        return NextResponse.json(
            { error: error instanceof Error ? error.message : 'Unknown error' },
            { status: 500 }
        );
    }
}
````

## File: src/app/api/metadata/[contract]/[tokenId]/route.ts
````typescript
import { NextResponse } from 'next/server';
import { metadata } from '@/lib/database/metadata';
import { CONTRACTS } from '@/modules/specific/config';

// Force dynamic route to ensure fresh data
export const dynamic = 'force-dynamic';

// Constants for blob storage
const BLOB_BASE_URL = 'https://2rhcowhl4b5wwjk8.public.blob.vercel-storage.com';
const BLOB_DIR = 'specific-ensurance';

// Helper to get fallback image URL
const getFallbackImageUrl = () => `${BLOB_BASE_URL}/${BLOB_DIR}/0.png`;

export async function GET(
    request: Request,
    { params }: { params: { contract: string; tokenId: string } }
) {
    try {
        console.log('Metadata request for:', {
            contract: params.contract,
            tokenId: params.tokenId
        });
        
        // Check if this is a specific certificate contract
        const isSpecificContract = params.contract.toLowerCase() === CONTRACTS.specific.toLowerCase();
        
        if (isSpecificContract) {
            console.log('Handling specific certificate metadata request');
        } else {
            console.log('Handling group account metadata request');
        }
        
        const nftMetadata = await metadata.getByContractAndToken(params.contract, params.tokenId);
        
        if (nftMetadata.error) {
            console.error('Metadata error:', nftMetadata.error);
            return NextResponse.json(
                { error: nftMetadata.error },
                { status: nftMetadata.status || 500 }
            );
        }

        // If this is a specific certificate and the image is from our blob storage,
        // ensure we have a valid image URL
        if (isSpecificContract && nftMetadata.image?.startsWith(BLOB_BASE_URL)) {
            // If the image URL is for a specific token, use it
            // Otherwise, use the fallback image
            const tokenId = params.tokenId;
            if (!tokenId || tokenId === '0') {
                nftMetadata.image = getFallbackImageUrl();
                nftMetadata.animation_url = getFallbackImageUrl();
            }
        }
        
        console.log('Metadata generated:', nftMetadata);
        return NextResponse.json(nftMetadata, {
            headers: {
                'Access-Control-Allow-Origin': '*',
                'Access-Control-Allow-Methods': 'GET, OPTIONS',
                'Access-Control-Allow-Headers': 'Content-Type'
            }
        });
    } catch (error) {
        console.error('Metadata API error:', {
            contract: params.contract,
            tokenId: params.tokenId,
            error: error instanceof Error ? error.message : String(error),
            stack: error instanceof Error ? error.stack : undefined
        });
        return NextResponse.json(
            { error: error instanceof Error ? error.message : 'Failed to get metadata' },
            { 
                status: 500,
                headers: {
                    'Access-Control-Allow-Origin': '*',
                    'Access-Control-Allow-Methods': 'GET, OPTIONS',
                    'Access-Control-Allow-Headers': 'Content-Type'
                }
            }
        );
    }
}

// Handle OPTIONS request for CORS preflight
export async function OPTIONS() {
    return new NextResponse(null, {
        status: 204,
        headers: {
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Methods': 'GET, OPTIONS',
            'Access-Control-Allow-Headers': 'Content-Type'
        }
    });
}
````

## File: src/app/api/moralis/contract-sales/route.ts
````typescript
import { NextResponse } from 'next/server';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const address = searchParams.get('address');
  const days = searchParams.get('days') || '90'; // Default to 90 days if not specified

  if (!address) {
    return NextResponse.json({ error: 'Contract address is required' }, { status: 400 });
  }

  if (!process.env.MORALIS_API_KEY) {
    console.error('MORALIS_API_KEY is not configured');
    return NextResponse.json({ error: 'API key not configured' }, { status: 500 });
  }

  try {
    const url = `https://deep-index.moralis.io/api/v2.2/nft/${address}/price?chain=base&days=${days}`;
    
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'accept': 'application/json',
        'X-API-Key': process.env.MORALIS_API_KEY
      }
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('Moralis API error:', {
        status: response.status,
        statusText: response.statusText,
        body: errorText
      });
      throw new Error(`API request failed: ${response.status} ${response.statusText}`);
    }

    const data = await response.json();
    return NextResponse.json(data);
  } catch (error) {
    console.error('Error fetching contract sales:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to fetch contract sales' },
      { status: 500 }
    );
  }
}
````

## File: src/app/api/moralis/price-floor/route.ts
````typescript
import { NextResponse } from 'next/server';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const address = searchParams.get('address');

  if (!address) {
    return NextResponse.json({ error: 'Contract address is required' }, { status: 400 });
  }

  if (!process.env.MORALIS_API_KEY) {
    console.error('MORALIS_API_KEY is not configured');
    return NextResponse.json({ error: 'API key not configured' }, { status: 500 });
  }

  try {
    const url = `https://deep-index.moralis.io/api/v2.2/nft/${address}/floor-price?chain=base`;
    
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'accept': 'application/json',
        'X-API-Key': process.env.MORALIS_API_KEY
      }
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('Moralis API error:', {
        status: response.status,
        statusText: response.statusText,
        body: errorText
      });
      throw new Error(`API request failed: ${response.status} ${response.statusText}`);
    }

    const data = await response.json();
    return NextResponse.json(data);
  } catch (error) {
    console.error('Error fetching price floor:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to fetch price floor' },
      { status: 500 }
    );
  }
}
````

## File: src/app/api/pools/route.ts
````typescript
import { NextResponse } from 'next/server';
import { pools } from '@/lib/database/pools';

// Force dynamic route to ensure fresh data
export const dynamic = 'force-dynamic';

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const contractAddress = searchParams.get('contract');
    const poolTypeParam = searchParams.get('type');
    const poolType = poolTypeParam !== null ? poolTypeParam as 'uniswap' | 'balancer' | 'ensure' : undefined;
    const limitParam = searchParams.get('limit');
    const limit = limitParam !== null ? parseInt(limitParam) : undefined;
    const pageParam = searchParams.get('page');
    const page = pageParam !== null ? parseInt(pageParam) : 1;
    const offset = page ? (page - 1) * (limit || 20) : undefined;

    // If contract address is provided, get specific pool
    if (contractAddress) {
      const pool = await pools.getByContract(contractAddress);
      if (!pool) {
        return NextResponse.json({ error: 'Pool not found' }, { status: 404 });
      }
      return NextResponse.json(pool);
    }

    // Otherwise get all pools with optional filters
    const allPools = await pools.getAll({
      poolType,
      limit,
      offset
    });

    return NextResponse.json(allPools);
  } catch (error) {
    console.error('Error in pools API:', error);
    return NextResponse.json(
      { error: 'Failed to fetch pool details' },
      { status: 500 }
    );
  }
}
````

## File: src/app/api/proceeds/route.ts
````typescript
import { NextResponse } from 'next/server';
import { proceeds } from '@/lib/database/proceeds';

// Force dynamic route to ensure fresh data
export const dynamic = 'force-dynamic';

// Cache successful responses for 1 minute
export const revalidate = 60;

// Cache for names and address data
const CACHE_DURATION = 60 * 1000; // 1 minute
const cache = {
  names: {
    data: null as any,
    timestamp: 0
  },
  byAddress: new Map<string, { data: any, timestamp: number }>()
};

async function getWithCache(type: 'names' | 'address', address?: string) {
  const now = Date.now();

  // Handle names request
  if (type === 'names') {
    if (cache.names.data && (now - cache.names.timestamp) < CACHE_DURATION) {
      return cache.names.data;
    }
    
    const data = await proceeds.getNames();
    // Convert to map format for frontend compatibility
    const addressMap = data.reduce((acc, row) => {
      if (typeof row.address === 'string') {
        acc[row.address.toLowerCase()] = {
          name: row.name,
          type: row.type,
          description: row.description
        };
      }
      return acc;
    }, {} as Record<string, { name: string | null; type: string; description: string | null }>);

    cache.names = {
      data: addressMap,
      timestamp: now
    };
    return addressMap;
  }

  // Handle address request
  if (address) {
    const addressCache = cache.byAddress.get(address);
    if (addressCache && (now - addressCache.timestamp) < CACHE_DURATION) {
      return addressCache.data;
    }
    
    const data = await proceeds.getByAddress(address);
    cache.byAddress.set(address, {
      data,
      timestamp: now
    });
    return data;
  }

  throw new Error('Invalid request parameters');
}

export async function GET(request: Request) {
  try {
    // Parse query parameters
    const { searchParams } = new URL(request.url);
    const address = searchParams.get('address');
    
    // If address provided, get specific address data
    if (address) {
      const data = await getWithCache('address', address);
      return NextResponse.json(data);
    }
    
    // Otherwise return all named addresses
    const rawData = await proceeds.getNames();
    console.log('Raw data from database:', rawData);
    
    // Convert to map format for frontend compatibility
    const addressMap = rawData.reduce((acc, row) => {
      console.log('Processing row:', row);
      if (typeof row.address === 'string') {
        acc[row.address.toLowerCase()] = {
          name: row.name,
          type: row.type,
          description: row.description,
          specific_asset_id: row.specific_asset_id
        };
      }
      return acc;
    }, {} as Record<string, { 
      name: string | null; 
      type: string; 
      description: string | null;
      specific_asset_id?: number;
    }>);

    console.log('Final address map:', addressMap);
    return NextResponse.json(addressMap);

  } catch (error) {
    console.error('Error in proceeds route:', error);
    return NextResponse.json(
      { error: 'Failed to fetch proceeds data' },
      { status: 500 }
    );
  }
}
````

## File: src/app/api/search/route.ts
````typescript
import { accounts } from '@/lib/database/accounts';
import { groups } from '@/lib/database/groups';
import { searchDocs } from '@/lib/docs-search';
import { NextRequest, NextResponse } from 'next/server';
import { getContractTokens } from '@/modules/specific/collect';
import { CONTRACTS } from '@/modules/specific/config';

export const revalidate = 60;

// Simple in-memory cache with stale-while-revalidate
let cache = {
    groups: { data: null, timestamp: 0, isRevalidating: false },
    accounts: { data: null, timestamp: 0, isRevalidating: false },
    general: { data: null, timestamp: 0, isRevalidating: false },
    specific: { data: null, timestamp: 0, isRevalidating: false },
    syndicates: { data: null, timestamp: 0, isRevalidating: false },
    proceeds: { data: null, timestamp: 0, isRevalidating: false },
    exposure: { data: null, timestamp: 0, isRevalidating: false }
};

const CACHE_TTL = 60000; // 1 minute
const STALE_TTL = 300000; // 5 minutes

function isCacheValid(type: keyof typeof cache) {
    const cacheEntry = cache[type];
    return cacheEntry.data && (Date.now() - cacheEntry.timestamp) < CACHE_TTL;
}

function isCacheStale(type: keyof typeof cache) {
    const cacheEntry = cache[type];
    return cacheEntry.data && (Date.now() - cacheEntry.timestamp) > STALE_TTL;
}

async function getDataWithCache(type: keyof typeof cache, fetchFn: () => Promise<any>) {
    const cacheEntry = cache[type];
    
    // Return fresh cache
    if (isCacheValid(type)) {
        return cacheEntry.data;
    }
    
    // Return stale cache and revalidate in background
    if (cacheEntry.data && !cacheEntry.isRevalidating) {
        cacheEntry.isRevalidating = true;
        fetchFn().then(newData => {
            cache[type] = { data: newData, timestamp: Date.now(), isRevalidating: false };
        }).catch(error => {
            console.error(`Background revalidation failed for ${type}:`, error);
            cacheEntry.isRevalidating = false;
        });
        return cacheEntry.data;
    }
    
    // No cache or stale cache, fetch new data
    try {
        const newData = await fetchFn();
        cache[type] = { data: newData, timestamp: Date.now(), isRevalidating: false };
        return newData;
    } catch (error) {
        console.error(`Failed to fetch ${type}:`, error);
        return cacheEntry.data || []; // Return stale data if available, empty array if not
    }
}

export const dynamic = 'force-dynamic';

export async function GET(request: NextRequest) {
    try {
        const query = request.nextUrl.searchParams.get('q')?.toLowerCase();
        
        // Build absolute base URL for internal fetches
        const protocol = request.headers.get('x-forwarded-proto') || 'http';
        const host = request.headers.get('host');
        const baseUrl = `${protocol}://${host}`;
        
        // Define navigation items once at the top
        const navItems = [
            {
                name: 'natural capital',
                path: '/natural-capital',
                type: 'nav'
            },
            {
                name: 'markets',
                path: '/markets',
                type: 'nav'
            },
            {
                name: 'groups',
                path: '/groups',
                type: 'nav'
            },
            {
                name: 'agent accounts',
                path: '/agents',
                type: 'nav'
            },
            {
                name: 'syndicates',
                path: '/syndicates',
                type: 'nav'
            },
            {
                name: 'binder',
                path: 'https://binder.ensurance.app',
                type: 'nav'
            },
            {
                name: 'docs',
                path: '/docs',
                type: 'nav'
            }
        ];
        
        // If no query, return only nav items
        if (!query) {
            return NextResponse.json(navItems);
        }

        const searchLower = query.toLowerCase();
        
        // Filter nav items that match the search
        const matchingNavItems = navItems.filter(item => 
            item.name.toLowerCase().includes(searchLower)
        );

        // Fetch all data types in parallel using absolute URLs
        const [
            groupsData,
            accountsData,
            generalData,
            specificData,
            syndicatesData
        ] = await Promise.all([
            getDataWithCache('groups', () => groups.getSearchResults()),
            getDataWithCache('accounts', () => accounts.getSearchResults()),
            getDataWithCache('general', () => fetch(`${baseUrl}/api/general`).then(r => r.json())),
            getDataWithCache('specific', () => getContractTokens(CONTRACTS.specific)),
            getDataWithCache('syndicates', () => fetch(`${baseUrl}/api/syndicates`).then(r => r.json()))
        ]);

        // Process results in parallel with null checks (except specific, which is handled below)
        const matchingGroups = groupsData
            .filter((group: any) => 
                (group?.group_name?.toLowerCase().includes(searchLower) ||
                group?.name_front?.toLowerCase().includes(searchLower))
            )
            .map((group: any) => ({
                name: group.name_front || group.group_name,
                path: `/groups/${group.group_name.replace(/^\\\\./, '')}/all`,
                type: 'group'
            }));
        const matchingAccounts = accountsData
            .filter((account: any) => 
                account?.full_account_name?.toLowerCase().includes(searchLower)
            )
            .map((account: any) => ({
                name: account.full_account_name,
                path: `/${account.full_account_name}`,
                type: 'account',
                is_agent: account.is_agent,
                is_ensurance: account.group_name === '.ensurance' && account.full_account_name !== 'situs.ensurance',
                token_id: account.token_id,
                tba_address: account.tba_address
            }));
        const matchingGeneral = generalData
            .filter((cert: any) => 
                cert?.name?.toLowerCase().includes(searchLower) ||
                cert?.description?.toLowerCase().includes(searchLower)
            )
            .map((cert: any) => ({
                name: cert.name,
                path: `/general/${cert.contract_address}`,
                type: 'general',
                description: cert.description
            }));
        // Specific certificates: fetch and parse metadata for each token, then filter on metadata.name/description
        const matchingSpecific = [];
        for (const token of specificData) {
            let metadata = { name: '', description: '' };
            try {
                if (token.tokenURI.startsWith('http')) {
                    const response = await fetch(token.tokenURI);
                    if (response.ok) {
                        metadata = await response.json();
                    }
                } else {
                    metadata = JSON.parse(token.tokenURI);
                }
            } catch (err) {
                // fallback: skip this token if metadata can't be loaded
                continue;
            }
            if (
                metadata.name?.toLowerCase().includes(searchLower) ||
                metadata.description?.toLowerCase().includes(searchLower)
            ) {
                matchingSpecific.push({
                    name: metadata.name || 'Unnamed Token',
                    path: `/specific/${CONTRACTS.specific}/${token.tokenURI.split('/').pop()}`,
                    type: 'specific',
                    description: metadata.description || ''
                });
            }
        }
        const matchingSyndicates = syndicatesData
            .filter((syndicate: any) => 
                syndicate?.name?.toLowerCase().includes(searchLower) ||
                syndicate?.description?.toLowerCase().includes(searchLower)
            )
            .map((syndicate: any) => ({
                name: syndicate.name,
                path: `/syndicates/${syndicate.name.toLowerCase().replace(/\s+/g, '-')}`,
                type: 'syndicate',
                description: syndicate.description
            }));

        // Combine all results, putting nav items first
        const results = [
            ...matchingNavItems,
            ...matchingGroups,
            ...matchingAccounts,
            ...matchingGeneral,
            ...matchingSpecific,
            ...matchingSyndicates
        ];

        // Add docs results to the combined results
        const docsResults = searchDocs(query);
        results.push(...docsResults);

        return NextResponse.json(results);
    } catch (error) {
        console.error('[Search API] Error:', error);
        return NextResponse.json(
            { error: 'Search failed' },
            { status: 500 }
        );
    }
}
````

## File: src/app/api/specific/route.ts
````typescript
import { NextRequest, NextResponse } from 'next/server';
import { sql } from '@vercel/postgres';
import { put } from '@vercel/blob';
import { CONTRACTS } from '@/modules/specific/config';
import type { SpecificMetadata } from '@/modules/specific/types';

// Blob storage configuration
const BLOB_DIR = 'specific-ensurance';
const BLOB_BASE_URL = 'https://2rhcowhl4b5wwjk8.public.blob.vercel-storage.com';

// URL generation helpers
const getMetadataUrl = (tokenId: string) => 
  `https://ensurance.app/api/metadata/${CONTRACTS.specific}/${tokenId}`;

const getMediaUrl = (tokenId: string) => 
  `${BLOB_BASE_URL}/${BLOB_DIR}/${tokenId}.png`;

// Simple function to get image URL with fallback
const getImageUrl = (tokenId: string) => {
  // If tokenId is 0 or invalid, use fallback
  if (!tokenId || tokenId === '0') {
    return `${BLOB_BASE_URL}/${BLOB_DIR}/0.png`;
  }
  return getMediaUrl(tokenId);
};

export async function POST(request: NextRequest) {
  try {
    const formData = await request.formData();
    const file = formData.get('file') as File;
    const tokenId = formData.get('tokenId') as string;
    const metadata = JSON.parse(formData.get('metadata') as string) as {
      contract_address: string;
      name: string;
      description: string;
    };

    if (!file || !tokenId || !metadata) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      );
    }

    // Validate contract address
    if (metadata.contract_address.toLowerCase() !== CONTRACTS.specific.toLowerCase()) {
      return NextResponse.json(
        { error: 'Invalid contract address' },
        { status: 400 }
      );
    }

    // Upload file to blob storage
    const { url: mediaUrl } = await put(`${BLOB_DIR}/${tokenId}.png`, file, {
      access: 'public',
      addRandomSuffix: false,
      token: process.env.BLOB_READ_WRITE_TOKEN
    });

    // Get the image URL
    const imageUrl = getImageUrl(tokenId);

    // Prepare metadata for storage
    const specificMetadata: SpecificMetadata = {
      name: metadata.name,
      description: metadata.description,
      image: imageUrl,
      animation_url: imageUrl,
      content: {
        mime: file.type,
        uri: imageUrl
      }
    };

    // Store metadata in database
    await sql`
      INSERT INTO certificates.specific (
        token_id,
        name,
        description,
        chain,
        image,
        animation_url,
        mime_type
      ) VALUES (
        ${Number(tokenId)},
        ${specificMetadata.name},
        ${specificMetadata.description},
        'base',
        ${specificMetadata.image},
        ${specificMetadata.animation_url},
        ${specificMetadata.content?.mime || 'image/png'}
      )
    `;

    return NextResponse.json({ 
      success: true,
      mediaUrl,
      metadataUrl: getMetadataUrl(tokenId)
    });
  } catch (error) {
    console.error('Error in specific certificate creation:', error);
    return NextResponse.json(
      { error: 'Failed to create certificate' },
      { status: 500 }
    );
  }
}
````

## File: src/app/api/syndicates/route.ts
````typescript
import { NextResponse } from 'next/server';
import { sql } from '@vercel/postgres';

// Force dynamic route to ensure fresh data
export const dynamic = 'force-dynamic';

export async function GET(request: Request) {
  try {
    // Get query parameters
    const { searchParams } = new URL(request.url);
    const name = searchParams.get('name');
    const limit = searchParams.get('limit') ? parseInt(searchParams.get('limit') as string) : 20;
    const page = searchParams.get('page') ? parseInt(searchParams.get('page') as string) : 1;
    const offset = (page - 1) * limit;
    
    let whereClause = '';
    const values: any[] = [];
    
    // Add name filter if provided
    if (name) {
      whereClause = 'WHERE name = $1';
      // Convert hyphenated URL name back to spaces for DB query
      values.push(name.replace(/-/g, ' '));
    }
    
    // Build the SQL query
    const query = `
      SELECT 
        name,
        tagline,
        description,
        currency,
        media,
        image_url,
        natural_capital_stocks,
        natural_capital_flows,
        nat_cap_rate
      FROM syndicates.syndicates
      ${whereClause}
      ORDER BY name
      ${!name ? `LIMIT $${values.length + 1} OFFSET $${values.length + 2}` : ''}
    `;

    // Add pagination values if not fetching by name
    if (!name) {
      values.push(limit);
      values.push(offset);
    }
    
    // Execute the query
    const result = await sql.query(query, values);
    
    // Transform the data to match the expected format in the frontend
    const syndicates = result.rows.map(item => ({
      name: item.name,
      tagline: item.tagline,
      description: item.description,
      currency: item.currency,
      media: item.media || {},
      image_url: item.image_url,
      natural_capital_stocks: item.natural_capital_stocks || [],
      natural_capital_flows: item.natural_capital_flows || [],
      nat_cap_rate: item.nat_cap_rate || 0
    }));

    console.log('API Response:', syndicates);
    
    return NextResponse.json(syndicates);
  } catch (error) {
    console.error('Error fetching syndicates:', error);
    return NextResponse.json(
      { error: 'Failed to fetch syndicates' },
      { status: 500 }
    );
  }
}
````

## File: src/app/api/utilities/image/route.ts
````typescript
import { NextRequest, NextResponse } from 'next/server';
import { generalCertificates } from '@/lib/database/certificates/general';
import { accounts } from '@/lib/database/accounts';
import { currencies } from '@/lib/database/config/currencies';
import { createPublicClient, http } from 'viem';
import { base } from 'viem/chains';

export const dynamic = 'force-dynamic';

const convertIpfsUrl = (url: string) => {
  if (url?.startsWith('ipfs://')) {
    return url.replace('ipfs://', 'https://magic.decentralized-content.com/ipfs/')
  }
  return url
}

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const address = searchParams.get('address');
    const accountName = searchParams.get('account');
    const tokenId = searchParams.get('tokenId');
    const tokenType = searchParams.get('tokenType');

    console.log('Image API called with:', { address, accountName, tokenId, tokenType });

    if (!address && !accountName) {
      return NextResponse.json({ error: 'Address or account name is required' }, { status: 400 });
    }

    // Add caching headers
    const headers = {
      'Cache-Control': 'public, max-age=3600, s-maxage=3600, stale-while-revalidate=86400',
      'CDN-Cache-Control': 'max-age=3600',
    };

    // Create public client for contract calls
    const publicClient = createPublicClient({
      chain: base,
      transport: http()
    });

    // Handle account images
    if (accountName) {
      const parts = accountName.split('.');
      if (parts.length === 2) {
        const [tokenId, group] = parts;
        // First try the account's specific image
        const accountImageUrl = `https://2rhcowhl4b5wwjk8.public.blob.vercel-storage.com/${group}/${tokenId}.png`;
        const accountResponse = await fetch(accountImageUrl);
        if (accountResponse.ok) {
          return NextResponse.json({ url: accountImageUrl }, { headers });
        }
        // Then try group's default image
        const groupImageUrl = `https://2rhcowhl4b5wwjk8.public.blob.vercel-storage.com/${group}/0.png`;
        const groupResponse = await fetch(groupImageUrl);
        if (groupResponse.ok) {
          return NextResponse.json({ url: groupImageUrl }, { headers });
        }
        // Finally, use global default
        return NextResponse.json({ url: 'https://2rhcowhl4b5wwjk8.public.blob.vercel-storage.com/default.png' }, { headers });
      }
    }

    // Handle ETH with direct path
    if (address === '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee') {
      return NextResponse.json({ 
        url: 'https://raw.githubusercontent.com/0xsquid/assets/main/images/tokens/eth.svg'
      }, { headers });
    }

    // 1. Check currencies configuration for img_fallback first
    if (address) {
      try {
        console.log('Checking currencies config for address:', address);
        const currency = await currencies.getByAddress(address);
        if (currency?.img_fallback) {
          console.log('Found img_fallback in currencies config:', currency.img_fallback);
          const imageUrl = convertIpfsUrl(currency.img_fallback);
          return NextResponse.json({ url: imageUrl }, { headers });
        }
      } catch (error) {
        console.log('Failed to fetch currency config:', error);
      }
    }

    // 2. Check if it's one of our Zora coins
    if (address) {
      const generalCert = await generalCertificates.getByContractAddress(address);
      if (generalCert?.token_uri) {
        try {
          const metadataUrl = convertIpfsUrl(generalCert.token_uri);
          const metadataResponse = await fetch(metadataUrl);
          if (metadataResponse.ok) {
            const metadata = await metadataResponse.json();
            if (metadata?.image) {
              return NextResponse.json({ url: convertIpfsUrl(metadata.image) }, { headers });
            }
          }
        } catch (metadataError) {
          console.log('Failed to parse Zora coin metadata:', metadataError);
        }
      }

              // 3. Try contractURI for any address (moved up in priority)
        try {
          console.log('Trying contractURI for address:', address);
          const contractURI = await publicClient.readContract({
          address: address as `0x${string}`,
          abi: [
            {
              inputs: [],
              name: 'contractURI',
              outputs: [{ type: 'string' }],
              stateMutability: 'view',
              type: 'function'
            }
          ] as const,
          functionName: 'contractURI'
        });
        
        console.log('ContractURI result:', contractURI);
        
        if (contractURI) {
          try {
            const metadataUrl = convertIpfsUrl(contractURI as string);
            console.log('Attempting to fetch metadata from:', metadataUrl);
            const metadataResponse = await fetch(metadataUrl);
            console.log('Metadata response status:', metadataResponse.status);
            
            if (metadataResponse.ok) {
              const metadata = await metadataResponse.json();
              console.log('Metadata from contractURI:', metadata);
              if (metadata?.image) {
                console.log('Found image in contractURI metadata:', metadata.image);
                return NextResponse.json({ url: convertIpfsUrl(metadata.image) }, { headers });
              }
            } else {
              console.log('Failed to fetch metadata - HTTP status:', metadataResponse.status);
            }
          } catch (metadataError) {
            console.log('Failed to parse metadata from contractURI:', metadataError);
          }
        }
      } catch (error) {
        console.log('Failed to fetch contractURI:', error);
      }

      // 4. Try tokenURI for any address (for contracts that use tokenURI instead of contractURI)
      try {
        console.log('Trying tokenURI for address:', address);
        const tokenURI = await publicClient.readContract({
          address: address as `0x${string}`,
          abi: [
            {
              inputs: [],
              name: 'tokenURI',
              outputs: [{ type: 'string' }],
              stateMutability: 'view',
              type: 'function'
            }
          ] as const,
          functionName: 'tokenURI'
        });
        
        console.log('TokenURI result:', tokenURI);
        
        if (tokenURI) {
          try {
            const metadataUrl = convertIpfsUrl(tokenURI as string);
            console.log('Attempting to fetch metadata from:', metadataUrl);
            const metadataResponse = await fetch(metadataUrl);
            console.log('Metadata response status:', metadataResponse.status);
            
            if (metadataResponse.ok) {
              const metadata = await metadataResponse.json();
              console.log('Metadata from tokenURI:', metadata);
              if (metadata?.image) {
                console.log('Found image in tokenURI metadata:', metadata.image);
                return NextResponse.json({ url: convertIpfsUrl(metadata.image) }, { headers });
              }
            } else {
              console.log('Failed to fetch metadata - HTTP status:', metadataResponse.status);
            }
          } catch (metadataError) {
            console.log('Failed to parse metadata from tokenURI:', metadataError);
          }
        }
      } catch (error) {
        console.log('Failed to fetch tokenURI:', error);
      }

      // 5. For ERC721 tokens, try tokenURI
      if (tokenType === 'erc721' && tokenId && address) {
        try {
          const tokenURI = await publicClient.readContract({
            address: address as `0x${string}`,
            abi: [
              {
                inputs: [{ name: 'tokenId', type: 'uint256' }],
                name: 'tokenURI',
                outputs: [{ type: 'string' }],
                stateMutability: 'view',
                type: 'function'
              }
            ],
            functionName: 'tokenURI',
            args: [BigInt(tokenId)]
          });
          
          if (tokenURI) {
            try {
              const metadataUrl = convertIpfsUrl(tokenURI as string);
              const metadataResponse = await fetch(metadataUrl);
              if (metadataResponse.ok) {
                const metadata = await metadataResponse.json();
                if (metadata?.image) {
                  return NextResponse.json({ url: convertIpfsUrl(metadata.image) }, { headers });
                }
              }
            } catch (metadataError) {
              console.log('Failed to parse ERC721 metadata:', metadataError);
            }
          }
        } catch (error) {
          console.log('Failed to fetch tokenURI for ERC721:', error);
        }
      }

      // 6. For ERC20 tokens, try contractURI (keeping this for backward compatibility)
      if (tokenType === 'erc20' && address) {
        try {
          const contractURI = await publicClient.readContract({
            address: address as `0x${string}`,
            abi: [
              {
                inputs: [],
                name: 'contractURI',
                outputs: [{ type: 'string' }],
                stateMutability: 'view',
                type: 'function'
              }
            ],
            functionName: 'contractURI'
          });
          
          if (contractURI) {
            try {
              const metadataUrl = convertIpfsUrl(contractURI as string);
              const metadataResponse = await fetch(metadataUrl);
              if (metadataResponse.ok) {
                const metadata = await metadataResponse.json();
                if (metadata?.image) {
                  return NextResponse.json({ url: convertIpfsUrl(metadata.image) }, { headers });
                }
              }
            } catch (metadataError) {
              console.log('Failed to parse ERC20 metadata:', metadataError);
            }
          }
        } catch (error) {
          console.log('Failed to fetch contractURI for ERC20:', error);
        }
      }

      // 7. Try Squid chain-specific webp
      const chainId = '8453'; // Base chain ID
      const squidChainUrl = `https://raw.githubusercontent.com/0xsquid/assets/main/images/migration/webp/${chainId}_${address.toLowerCase()}.webp`;
      console.log('Trying Squid chain URL:', squidChainUrl);
      const squidChainResponse = await fetch(squidChainUrl);
      if (squidChainResponse.ok) {
        console.log('Found image via Squid chain');
        return NextResponse.json({ url: squidChainUrl }, { headers });
      }

      // 8. Try TrustWallet
      const trustWalletUrl = `https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/${address}/logo.png`;
      console.log('Trying TrustWallet URL:', trustWalletUrl);
      const trustWalletResponse = await fetch(trustWalletUrl);
      if (trustWalletResponse.ok) {
        console.log('Found image via TrustWallet');
        return NextResponse.json({ url: trustWalletUrl }, { headers });
      }
    }

    // 9. No image found
    console.log('No image found for address:', address);
    return NextResponse.json({ url: null }, { headers });

  } catch (error) {
    console.error('Error fetching image:', error);
    return NextResponse.json({ error: 'Failed to fetch image' }, { status: 500 });
  }
}
````

## File: src/app/api/utilities/spam/route.ts
````typescript
import { NextResponse } from 'next/server';
import { sql } from '@vercel/postgres';

export async function GET() {
  try {
    const { rows } = await sql`
      SELECT DISTINCT contract_address as address 
      FROM config.spam_contracts 
      WHERE chain = 'base'
      ORDER BY contract_address
    `;
    return NextResponse.json({ addresses: rows.map(r => r.address.toLowerCase()) });
  } catch (error) {
    console.error('Error fetching spam list:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to fetch spam list' },
      { status: 500 }
    );
  }
}
````

## File: src/app/binder/natural-asset/[name]/page.tsx
````typescript
export default function NaturalAssetPage() {
  return (
    <div className="flex flex-col items-center justify-start pt-20 pb-20 p-4 text-center">
      <h1 className="text-2xl font-bold mb-4">Natural Asset Details Coming Soon</h1>
      <p className="mb-4">Natural asset details will be available here soon. For now, please visit</p>
      <a 
        href="https://binder.ensurance.app" 
        className="text-blue-500 hover:text-blue-700 underline"
        target="_blank"
        rel="noopener noreferrer"
      >
        binder.ensurance.app
      </a>
      <p className="mt-4">to view all natural assets.</p>
    </div>
  );
}
````

## File: src/app/binder/page.tsx
````typescript
export default function BinderPage() {
  return (
    <div className="flex flex-col items-center justify-start pt-20 pb-20 p-4 text-center">
      <h1 className="text-2xl font-bold mb-4">Binder Updates Coming Soon</h1>
      <p className="mb-4">The binder functionality is currently available at</p>
      <a 
        href="https://binder.ensurance.app" 
        className="text-blue-500 hover:text-blue-700 underline"
        target="_blank"
        rel="noopener noreferrer"
      >
        binder.ensurance.app
      </a>
      <p className="mt-4">Check back here for updates!</p>
    </div>
  );
}
````

## File: src/app/docs/ensurance/page.mdx
````
# ENSURANCE
## Critical Infrastructure

Society and the economy are 100% dependent on Nature. All well-being is inextricably linked to the collective health of our planet's deeply interconnected ecological systems.

Nature, biodiversity, and people are the critical infrastructure of our world. Natural Capital Ensurance, **ensures** the protection and regeneration of this critical infrastructure. 

## Overview

Built by BASIN, Natural Capital Ensurance transforms how we value and fund nature. This resilience hyperstructure ensures the benefits nature provides to all beings.

Groups and Agents form Ensurance Syndicates and utilize Pools that fund 15 critical ecosystems & 19 vital ecosystem services crucial to all life. Certificates of Ensurance properly value natural assets, while the nature-based currency $ENSURE drives investment into the $1T biodiversity gap.

⚡ reduced risk · increased resilience · greater wellbeing ⚡

### Insurance v. Ensurance
Traditional insurance is reactive—it compensates for loss after damage occurs.

Ensurance is proactive. It protects ecosystems from day one, with a clear path to permanent protection, restoration, and ongoing stewardship funding.

### Implementation
There are two types of Ensurance:
- General Ensurance values what matters, flowing like a currency where market activity indirectly funds place, people, and purpose.
- Specific Ensurance protects what matters, anchoring as an asset to directly fund natural assets and stewardship.

### Core Purpose
Natural Capital Ensurance places valuable natural assets in permanent trust (ENTRUST), securing their benefits for all life.

Ensurance makes this possible.

## Roles & Participants

### Groups
Groups are organizations, communities, or networks formed to increase resilience and reduce risk and who are members of ENSURANCE DUNA via contracts and accounts.

Groups create Certificates of Ensurance to ensure what is important to them.

### Agents
Ensurance Agents are Accounts that are Members of Groups, representing anything the Group defines—people, places, projects, or purpose (e.g., species, impact initiatives, etc.). An Ensurance Agent can be a human operated Account or an agent (LLM) operated Account.

### Ensured
Unique to Ensurance, the Ensured is nature itself, which by definition includes humans, society and the economy. 

Ensured is further delineated  as:
- Policyholder - These are Certificate Holders. General policyholders receive protocol rewards. Specific policyholders (tied to specific real asset) receive protocol rewards and can make ecological data claims about the specific natural asset.
- Natural Asset: A specific real asset containing defined ecosystem extent, characteristics and condition that has a Policy that has been written for it.
- Additional Ensured- those who benefit as a result of Ensurance whether or not they contribute to Ensurance Polices.  e.g. species, society, economy

### Underwriter
The underwriter is responsible for evaluating and deciding the risk of ensuring specific natural assets, determining policy terms, establishing premiums, working with Ensurers, Ensurance Agents and the ENTRUST. The primary underwriter is BASIN LLC which utilizes the RealValue of Natural Capital Framework to value natural assets.

### Ensurer
The Ensurer funds the Ensurance policy, bearing the risk in exchange for Ensurance premiums paid by the Policyholders and/or the Protocol. Ensurer's are Members that are either market rate investors, philanthropic funders, or blended finance vehicles that fund the real asset cost upfront and during the policy period.

### ENTRUST
Once the Ensurance Premium has been paid in full and the Ensurance Policy has ended, the natural asset (land/ecosystem) goes into permanent trust. Trust and holding company structures vary based on asset and jurisdiction but all include land use restrictions at the title level and are managed on behalf of Nature by the Protocol.

## Mechanics & Implementation

### Certificates
Certificates of Ensurance are the core currencies and assets of Natural Capital Ensurance. Certificates represent the unique and diverse values we seek to ensure.

General Certificates can be issued by any Group to ensure what is important to them. As a currency, general certificates allow natural price discovery, proper valuation, and market fluctuations to fund natural capital.

Specific Certificates are issued based on the dollar value specific natural assets.

Specific Certificates revieve protocol rewards and holders can make prorata ecological data claims. General certificates provide access to liquidity.

All Certificates can be swapped for $ENSURE as well as for each other.

### Pools
Ensurance Pools are dedicated investment vehicles designed to manage the stocks and flows of natural capital through a structured portfolio of 33 pools—14 ecosystems and 19 ecosystem services that sustain life.

These pools blend traditional and decentralized investment management techniques to maximize assets under management (AUM) while ensuring capital is deployed effectively for the purpose of each pool—whether for conservation, restoration, resilience, or yield-driven impact.

Each Ensurance Pool functions as a specialized capital allocation mechanism, ensuring that investment flows are directed toward maintaining and enhancing the ecological and financial stability of natural capital. Pools act as an additional capital and yield source for Syndicates and Groups.

### Syndicates
Ensurance Syndicates are yield bearing vaults for very specific purposes denominated in one underlying currency.  

Syndicate examples:
- aquifer recharge in west Texas (USDC)
- hemp farms in turkey (DAI)
- Coconut Farms in the Caribbean (ENSURE)
- Beaver Habitat (ENSURE)
- Urban Heat Islands (GLO Dollar)
- solar projects in global south (EARTH)

Groups and Members can form Syndicates. Anyone can permissionlessly invest and withdrawal at any time.

### Policies
The Policy is the specifications of the natural asset, the cost, and length as determined by the Underwriter.

Policies have Ensurers, Policyholders and Premiums. Ensurers and Policyholders are covered above. 

The premium is the annual cost of the Ensurance Policy. The premium is calculated based off of the relationship between the annual RealValue, capital providers (Ensurers), and the underlying real asset cost/value. This relationship calculates cost options to put the ecosystem in permanent trust either today, 2030, 2040, or 2050. Alternatively, Ensurance Premiums can be calculated for any custom # of years including a minimum premium amount which is the lowest cost but only protects the ecosystem year by year, albeit not permanently until a formal policy is issued.

Fun fact: The term "premium" has its origins in the Latin word "praemium," which means "reward" or "prize." While premium has different meanings today, the historical definition is highly applicable to Ensurance: premiums were seen as payments for securing a service or benefit, often with a positive connotation of receiving something valuable in return. What greater value is there than nature itself? 

#### Example Policy
(Insert table image here)

### Binder
The Ensurance Binder is a record of all the real assets considered for or part of Ensurance.

Ensurance Slips.
Slips are the precursor to policies with each slip containing all the preliminary data needed for a natural asset to be considered for a formal policy.

### Proceeds
Ensurance Proceeds, modeled after natural water cycles, create a perpetual flywheel of funding throughout the system. Like water flowing from headwaters through streams and estuaries, proceeds move through:

- Instance-based distributions: Immediate funding for critical needs
- Time-based allocations: Sustained support from 3 months to 512 years
- Continuous flows: Ongoing funding for Groups, Members, and ecosystem stewardship

This natural cycle ensures resources flow where needed while maintaining the system's long-term health and resilience.

## Ensurance Examples

Natural Capital Ensurance can be seen in action in the [Ensurance Binder](https://binder.ensurance.app).

### Example: 83 acre wetland 

<div className="not-prose">
  <img src="/assets/ensurance-example.png" alt="83 acre wetland ensurance example" className="rounded-lg" />
</div>
````

## File: src/app/docs/faq/page.mdx
````
# Frequently Asked Questions

> This FAQ is regularly updated. For the latest information or to ask questions, join our public discussions on [X (Twitter)](https://x.com/ensurance_app) or [Warpcast](https://warpcast.com/~/channel/ensurance).

## Protocol Questions

### How does Ensurance fund nature & climate projects?
The protocol uses three primary funding mechanisms:

1. **Certificates of Ensurance**
   - General Ensurance (`ERC-20`): Indirect funding through market activity
   - Specific Ensurance (`ERC-1155`): Direct funding of natural assets

2. **SITUS Accounts**
   - Token-bound accounts (`ERC-6551`)
   - Represent people, places, or projects
   - Track assets, currency, and impact metrics

3. **ENSURE Currency**
   - Nature-based utility token
   - Provides liquidity between currencies and assets
   - Cross-chain via Axelar ITS

All funds flow transparently through onchain accounts with public tracking.

### What's the difference between SITUS, BASIN, and ENSURANCE?
They work together but serve different roles:

- **BASIN**: Provides frameworks and operations for natural capital valuation and protection
- **SITUS**: Onchain protocol enabling decentralized accounts, assets, and currency
- **ENSURANCE**: The combined system protecting and regenerating natural capital

## Account Questions

### How are SITUS accounts different from domains or ENS?
SITUS accounts are onchain infrastructure that:

- Function as standalone 0x wallets with unique IDs
- Have no renewal fees (one-time purchase)
- Can hold and transfer any ERC token
- Are fully controlled by the account holder
- Work on any Base L2 compatible interface
- Can integrate with ENS (optional)

### How do I manage my SITUS account?

**Creation**
- Visit any Group's CREATE page
- No limit on accounts or group memberships
- One-time purchase, no renewals

**Management**
- Transfer to other wallets
- Trade on any NFT marketplace
- Burn (permanently delete)
- Compatible with most Ethereum wallets

## Natural Capital Questions

### Is it ethical to put a price on nature?
Nature is already priced through:

- Resource extraction
- Land development
- Ecosystem services

Ensurance provides a framework to value preservation and regeneration.

### How does Ensurance relate to traditional insurance?
Ensurance complements traditional insurance by:

- Lowering premiums for insureds
- Reducing underwriting risk
- De-risking land investments
- Protecting ecosystem services

### Can Ensurance work with other credits/certificates?
Yes! Ensurance encourages:

- "Stacking" with other credits
- "Bundling" for project feasibility
- Proper reconciliation between systems
- Enhanced market opportunities

## Group Questions

### How do I create a SITUS namespace for my organization?
Any group focused on place-based resilience can apply:

1. Contact us to start the process
2. Demonstrate community alignment
3. Commit to transparent governance

*Note: All groups must support natural capital protection*
````

## File: src/app/docs/fundamentals/page.mdx
````
# Fundamentals

In the face of rapid environmental, technological, and social change, Natural Capital Ensurance reduces systemic risk and ensures resilience.  

Natural capital is the stocks of living and non-living natural phenomena that generate flows of benefits essential to all life.

Ensurance safeguards 15 stocks and 19 flows of natural capital, ensuring ecosystem function: 
- Stocks include forests, wetlands, grasslands to urban and coastal ecosystems. 
- Flows include essential resources like clean air, water, food, energy, climate stability, risk resilience, and additional cultural and ecological benefits.

Ensurance applies real asset fundamentals to proactively and perpetually fund natural assets and the people who steward them. It operates at all scales, in any location, across initiatives focused on place, purpose, or people.

## A Resilience Hyperstructure
Ensurance is designed for adaptive capacity, balancing present and future needs. It is:
- Open-source
- Composable
- Interoperable
- Modular
- Extensible
- Non-custodial
- Censorship-resistant
- Configurable

Like natural systems, the polycentric design operates through five interconnected components:
- Groups 
- Accounts/Agents
- Assets
- Currency
- Mechanisms

## Groups
Groups are organizations, communities, or networks formed to increase resilience and reduce risk.

Each Group has a unique namespace, such as .basin or .refi, with members having accounts like elk.basin or node-name-here.refi.

Every Group operates on its own onchain contract fully owned by the Group.

Groups are autonomous and control:
- How new accounts are issued
- Metadata and governance settings
- Key contract functions

At the core of every Group are Accounts, which represent individuals, entities, or agents participating in the ecosystem.

## Accounts / Agents
Accounts are the Members of Groups, representing anything the Group defines—people, places, projects, or purpose (e.g., species, impact initiatives, etc.).

Each Account has:
- A unique onchain name within its Group
- A cross-chain Ethereum wallet, enabling transactions and interactions
- The ability to hold, send, and transact using fungible (currency) and non-fungible and semi-fungible (assets) value

Agents are Accounts that integrate with ensurance.app via ElizaOS, enabling semi-autonomous actions based on predefined specifications.

## Assets
Assets are the non-fungible and semi-fungible tokens that Accounts and Agents hold and operate.

Assets can be held, sold, sent, swapped, converted, or burned.

## Currency
Currencies provide fungible value that Groups, Accounts, and Agents use to advance their mission. These currencies integrate into DeFi ecosystems, enabling mission-driven financial strategies.

### Certificates of Ensurance
Certificates of Ensurance are currencies and assets that Groups issue to fund natural assets, ecosystem services, and Group operations. They bridge traditional finance with natural capital value.

Two types of Certificates enable flexible funding approaches:

- **General Ensurance** values what matters, flowing like a currency where market activity indirectly funds place, people, and purpose.
- **Specific Ensurance** protects what matters, anchoring as an asset to directly fund natural assets and stewardship.

### $ENSURE: Nature-Based Currency
Historically, money has been backed by society's most fundamental real assets—from shells and tulip bulbs to gold and oil. 

Now, we can ensure the foundation of all wealth, the most essential real asset: functioning ecosystems full of biodiversity.

$ENSURE serves as both money and mechanism - a utility currency that connects and powers Natural Capital Ensurance. As the common medium of exchange across thousands of natural capital currencies and assets, it enables seamless value flow between all participants and components of the system.

Through these interconnections, $ENSURE is foundational to closing the global $1T biodiversity funding gap.

## Mechanisms

Mechanisms are modeled after natural cycles—specifically, the water cycle—powering Ensurance's perpetual flywheel.

Ensurance Proceeds circulate throughout Natural Capital Ensurance, distributing funding to all participants. The proceeds system provides:
- Instance-based funding
- Time-based funding
- Continuous support for Groups, Members, and Agents

Key mechanisms include:
- Ensurance Pools
- Ensurance Syndicates
- Protocol Rewards
- Ensurance Exchange

## Summary
Natural Capital Ensurance ensures the fundamental stocks and flows of nature are properly valued, secured, and sustained. 

Ensurance transforms risk reduction costs into investment opportunities, combining real assets, blended finance, and AI to scale ecosystem protection and restoration worldwide.
````

## File: src/app/docs/natural-capital/page.mdx
````
# Natural Capital

Natural capital is the stocks of living and non-living natural phenomena that generate flows of benefits essential to all life.

## Stocks & Flows
The benefits nature provides—often referred to as environmental assets—are composed of stocks and flows:
- Ecosystem assets (stocks): the foundational natural systems
- Ecosystem services (flows): the benefits derived from these systems

Together, when defined by extent, characteristics, and condition, they form a Natural Asset (real asset).

Ensurance safeguards 14 stocks and 19 flows of natural capital, ensuring ecosystem function:

<div className="not-prose">
  <div className="grid grid-cols-2 gap-8 natural-capital-grid">
    <div className="bg-[rgba(var(--foreground-rgb),0.03)] p-6 rounded-lg">
      <h3 className="text-lg font-semibold mb-4">STOCKS (Ecosystem Assets)</h3>
      <ul className="space-y-2">
        <li>Cultivated & Developed</li>
        <li>Boreal Forests</li>
        <li>Urban Open Space</li>
        <li>Coastal Systems</li>
        <li>Rural Open Space</li>
        <li>Grasslands</li>
        <li>Rivers & Lakes</li>
        <li>Shrublands</li>
        <li>Inland Wetlands</li>
        <li>Polar & Alpine</li>
        <li>Tropical Forests</li>
        <li>Desert</li>
        <li>Temperate Forests</li>
        <li>Subterranean</li>
      </ul>
    </div>
    <div className="bg-[rgba(var(--foreground-rgb),0.03)] p-6 rounded-lg">
      <h3 className="text-lg font-semibold mb-4">FLOWS (Ecosystem Services)</h3>
      <ul className="space-y-2">
        <li>Raw Materials</li>
        <li>Food</li>
        <li>Energy</li>
        <li>Water Abundance</li>
        <li>Healthy Soils</li>
        <li>Medicinal & Genetic</li>
        <li>Climate Stability</li>
        <li>Clean Air</li>
        <li>Clean Water</li>
        <li>Risk Resilience</li>
        <li>Pollination</li>
        <li>Erosion Control</li>
        <li>Pest & Disease Control</li>
        <li>Habitat</li>
        <li>Recreation & Experiences</li>
        <li>Research & Learning</li>
        <li>Aesthetic & Sensory</li>
        <li>Art & Inspiration</li>
        <li>Existence & Legacy</li>
      </ul>
    </div>
  </div>
</div>

## Accounting: Price, Cost, & Value 

The current financial system recognizes only a fraction of natural capital's true value, primarily:
- Food
- Raw materials
- Energy

Most ecosystem services remain outside market mechanisms, leading to systemic undervaluation. While real assets like land and water rights reflect some value, traditional markets struggle to price ecological risk and scarcity.

Environmental accounting methods attempt to quantify this value, but face a fundamental challenge: as measurement precision increases, nature's value approaches infinity—the Richardson Effect. This makes full accounting impractical.

### The RealValue of Natural Capital

To address this challenge, we use a practical approach that values annual flows in relation to the cost of underlying stocks:

- Annual flows → Ecosystem Services Value (ESV) in dollars
- Stocks → Market price of real asset plus project costs
- Extent & Characteristics → Land cover type and size
- Condition → Current ecosystem health metrics

#### Example

<div className="not-prose">
  <div className="content-box">
    <div className="grid grid-cols-2 gap-8">
      <div>
        <div className="label-group">
          <div className="label-row">
            <span className="label">Extent</span>
            <span className="value">100 acres</span>
          </div>
        </div>
        <div className="label-group">
          <div className="label-row">
            <span className="label">Characteristics</span>
          </div>
          <ul className="list-disc">
            <li>Wetlands</li>
            <li>Riparian zone</li>
            <li>Temperate forest</li>
          </ul>
        </div>
      </div>
      <div>
        <div className="label-group">
          <div className="label-row">
            <span className="label">Condition Scores</span>
          </div>
          <ul className="list-disc">
            <li>Wetlands: 7/10</li>
            <li>Riparian: 9/10</li>
            <li>Forest: 8/10</li>
          </ul>
        </div>
      </div>
    </div>
    <div className="border-t">
      <div className="grid grid-cols-2 gap-4">
        <div className="label-group">
          <div className="label-row">
            <span className="label">Annual Flows (ESV)</span>
            <span className="value font-mono">$1,200,000</span>
          </div>
        </div>
        <div className="label-group">
          <div className="label-row">
            <span className="label">Stocks Value</span>
            <span className="value font-mono">$600,000</span>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

### Natural Cap Rate

The relationship between flows and stocks can be expressed as the Natural Capitalization Rate:

<div className="not-prose">
  <div className="content-box">
    <div className="font-mono">
      <div className="mb-2">Natural Cap Rate = Flows (ESV) / Stocks (Real Asset Value)</div>
      <div>$1,200,000 / $600,000 = 200%</div>
    </div>
  </div>
</div>

Higher Natural Cap Rates indicate ecosystems that are cost-effective to conserve. Lower Natural Cap Rates suggest land that may be better suited for human use (due to high real estate values) or ideal for restoration (if ecosystem condition is low).

## Applied Natural Capital

Natural Capital Ensurance applies BASIN's RealValue Framework to:
- Value and underwrite natural assets
- Enable Ensurance Policies and Premiums
- Place ecosystems in Entrust
- Transform ecological risk into investment opportunity

For detailed examples, metrics, and supporting materials, visit [docs.basin.global](https://docs.basin.global/realvalue/the-realvalue-of-natural-capital)
````

## File: src/app/docs/protocol/page.mdx
````
# Protocol Overview

Natural Capital Ensurance is made possible through three core components:

## BASIN Natural Capital
BASIN LLC and BASIN Foundation provides the core frameworks and operations:

### Frameworks
- Core Benefits Framework
- RealValue of Natural Capital Framework
- Natural Capital Accounting
- Ensurance Policy Underwriting

### Operations
- Core Protocol Operations (OpCo, PropCo, HoldCo)
- Ensurance Proceeds Contract Management
- Protocol Development & Maintenance

## SITUS Protocol
SITUS is the onchain infrastructure powering Ensurance through EVM smart contracts:

### Core Features
- Group Management (`ERC-721`)
- Account/Agent System (`ERC-6551`)
- General Ensurance (`ERC-20`)
- Specific Ensurance (`ERC-1155`)

### Key Functions
- Permissionless Group Creation
- Account Issuance & Management
- Cross-chain Interoperability
- Protocol Governance

## ENSURANCE DUNA
Decentralized Unincorporated Nonprofit Association formed in Wyoming:

### Membership
- BASIN & SITUS as founding members
- Each Account = 1 membership
- Groups as organizational members

### Structure
- Permissionless membership via Account creation
- Equal voting rights per Account
- Transparent governance
- Non-profit operation

## ElizaOS
Agent framework powering ensurance.app:

### Core Capabilities
- RAG memory system
- Document processing
- Media analysis
- Autonomous trading

### Features
- Multi-model support (Llama, GPT-4, Claude)
- Voice, text, and media interaction
- Custom actions & plugins
- TypeScript-based extensibility

Together, these components create a resilient hyperstructure that ensures the protection and regeneration of natural capital.
````

## File: src/app/docs/technical/zora/coins.mdx
````
# Zora Coins

> **Documentation Note**: This guide reflects the implementation of Zora Coins as of February 2024. For the most current information, please refer to the [official Zora documentation](https://docs.zora.co/).

## Implementation Notes

### Contract Addresses (Base Network)
- Factory: `0x777777751622c0d3258f214F9DF38E35BF45baF3`
- Implementation: `0x6B78be0808262b1d5E9B1eeDfE448aDCE2C637a8`

### Key Events to Monitor
```solidity
// Factory events
event CoinCreated(...)  // Emitted on deploy()

// Coin contract events
event CoinBuy(...)      // Emitted on buy()
event CoinSell(...)     // Emitted on sell()
event TradeRewards(...) // Trading fee distributions
event MarketRewards(...) // LP fee distributions
event CoinPayoutRecipientUpdated(...) // Creator reward address changes
event ContractMetadataUpdated(...)    // Metadata URI updates
```

### SDK Status
Currently implementing direct contract interactions until official Zora Coins SDK is released. Key integration points:
- Factory's `deploy()` for coin creation
- Individual coin's `buy()` and `sell()` for trading
- Event monitoring for rewards and updates
- Protocol Rewards contract for fee distribution

## Contract Roles

### Payout Recipient (Creator)
- Receives initial 10M tokens (1% of supply)
- Collects 50% of trading fees
- Collects 50% of LP fees
- Can be updated by owners via `setPayoutRecipient()`

### Contract Owners
- Set during initialization as array of addresses
- Multiple owners possible through `MultiOwnable`
- Admin rights to:
  - Update payout recipient
  - Update contract metadata
  - Other admin functions

### Minter/Deployer
- Account that calls factory's `deploy()`
- Can be different from creator/owners
- Often a platform account deploying on behalf of creator

Note: The "creator" (payout recipient) and contract owners can be different addresses. A platform could deploy and own the contract while setting a creator as the payout recipient.

## Overview

Zora Coins are ERC20 tokens created through a factory system that integrates with Uniswap V3 for liquidity and includes built-in reward distribution mechanisms.

## Contract Architecture

### Factory Contract
The `ZoraFactoryImpl` contract creates new Zora Coin instances using minimal proxies (EIP-1167). Each deployment configures:
- Payout recipient (creator)
- Token URI (metadata)
- Name and symbol
- Platform referrer
- Currency (ETH/WETH or ERC20)
- Initial pool configuration

### Coin Implementation
Each Zora Coin is an ERC20 token with:
- Upgradeable contracts (OpenZeppelin)
- Multi-owner capability
- Automatic liquidity pool creation
- Built-in reward distribution
- Reentrancy protection

## Core Constants

All Zora Coins share the same immutable constants defined in the `CoinConstants` contract. These values cannot be changed after deployment.

### Supply Distribution
```solidity
// Total supply: 1 billion coins
MAX_TOTAL_SUPPLY = 1_000_000_000e18

// Initial distribution:
POOL_LAUNCH_SUPPLY = 990_000_000e18    // 99% to liquidity pool
CREATOR_LAUNCH_REWARD = 10_000_000e18   // 1% to creator
```

### Trading Parameters
```solidity
// Minimum trade size
MIN_ORDER_SIZE = 0.0000001 ether    // Prevents dust transactions

// Uniswap V3 pool fee
LP_FEE = 10000                      // 1% fee on all trades
```

### Fee Structure
All fees are specified in basis points (1 bps = 0.01%):

#### Trading Fees (1% total)
| Recipient | Basis Points | Percentage |
|-----------|-------------|------------|
| Creator | 5000 | 50% |
| Protocol | 2000 | 20% |
| Platform Referrer | 1500 | 15% |
| Trade Referrer | 1500 | 15% |

#### LP Fee Distribution
| Recipient | Basis Points | Percentage |
|-----------|-------------|------------|
| Creator | 5000 | 50% |
| Platform Referrer | 2500 | 25% |
| Protocol | 2500 | 25% |

### Pool Configuration
```solidity
// Price range for WETH pairs
LP_TICK_LOWER_WETH = -199200
LP_TICK_UPPER = 887200
```

## Key Features

### Liquidity Management
- Automatic Uniswap V3 pool creation
- Configurable initial tick range
- 1% pool fee structure
- Initial supply split between creator and pool

### Trading Mechanics
- Buy/sell functionality through Uniswap V3
- Slippage protection
- Support for both ETH and ERC20 trading pairs
- Automatic reward distribution on trades

### Reward System
Integrated with Protocol Rewards contract (`0x7777777F279eba3d3Ad8F4E708545291A6fDBA8B`):
- Creator rewards
- Platform referrer rewards
- Trade referrer rewards
- Protocol fees
- Market rewards from LP fees

## External System Integration

### Comments System
Contract Address: `0x7777777C2B3132e03a65721a41745C07170a5877`

Coins provide three key functions for the comments system:
```solidity
interface ICoinComments {
    function isOwner(address) external view returns (bool);
    function payoutRecipient() external view returns (address);
    function balanceOf(address) external view returns (uint256);
}
```

### Protocol Rewards
Contract Address: `0x7777777F279eba3d3Ad8F4E708545291A6fDBA8B`

Handles distribution of:
- Trading fees
- Market rewards
- Referral rewards
- Protocol fees

## Implementation Notes

### Deployment Parameters
```solidity
function initialize(
    address payoutRecipient_,
    address[] memory owners_,
    string memory tokenURI_,
    string memory name_,
    string memory symbol_,
    address platformReferrer_,
    address currency_,
    int24 tickLower_
) public initializer
```

### Fee Structure
Trading fees are distributed as follows:
- Creator rewards
- Platform referrer rewards
- Trade referrer rewards
- Protocol fees

Market rewards from LP fees are split between:
- Creator
- Platform referrer
- Protocol

### Security Features
- Reentrancy protection
- Multi-owner capability
- Address validation
- Slippage protection
- ETH handling safety checks

### Standards Support
- ERC20 with Permit
- ERC165 interface detection
- ERC7572 contract metadata
````

## File: src/app/docs/technical/zora/page.mdx
````
# Zora Protocol Integration

> **Documentation Note**: This guide reflects our implementation of the Zora Protocol as of February 2024. For the most current information, please refer to the [official Zora documentation](https://docs.zora.co/).

## Overview

Our implementation uses both Zora's Coins and 1155 contracts for different strategies:

1. **Zora Coins (ERC20 + Uniswap V3)**
   - Automatic liquidity pool creation
   - Built-in reward distribution
   - 1% trading fee with creator rewards
   - Contract: `0x777777751622c0d3258f214F9DF38E35BF45baF3`
   [Learn more about Zora Coins](/docs/technical/zora/coins)

2. **ERC1155 in ERC20 Price (e.g., USDC)**
   - Fixed price in ERC20 tokens
   - No secondary market functionality
   - Requires token approval before minting
   - Contract: `0x777777E8850d8D6d98De2B5f64fae401F96eFF31`

## Sale Strategy Details

### 1. Zora Coins

#### Supply Distribution
- Total Supply: 1 billion tokens
- Pool: 99% (990M tokens)
- Creator: 1% (10M tokens)

#### Fee Structure
Trading Fee: 1% total split:
- Creator: 50%
- Protocol: 20%
- Platform Referrer: 15%
- Trade Referrer: 15%

LP Fee Distribution:
- Creator: 50%
- Platform Referrer: 25%
- Protocol: 25%

#### Key Features
- Automatic Uniswap V3 pool creation
- Configurable initial tick range
- Support for ETH/WETH and ERC20 pairs
- Built-in reward distribution
[Full Zora Coins Documentation](/docs/technical/zora/coins)

### 2. ERC1155 in ERC20 Fixed Price

#### Configuration
```solidity
struct SalesConfig {
    uint64 saleStart;           // Start timestamp
    uint64 saleEnd;            // End timestamp
    uint64 maxTokensPerAddress; // 0 for unlimited
    uint256 pricePerToken;     // Price in ERC20 decimals
    address currency;          // ERC20 token address
}
```

#### Fee Structure
5% total fee split:
- Creator: 95% of sale price
- Platform fees (5% total):
  - Create Referral: 28.57%
  - Mint Referral: 28.57%
  - First Minter: 14.23%
  - Zora: 28.63%

## Implementation Notes

### Token Creation
```solidity
function createToken(
    string calldata tokenURI,
    ICreatorRoyaltiesControl.RoyaltyConfiguration memory royaltyConfiguration
) external returns (uint256)
```

### Metadata Structure
```json
{
  "name": "Token Name",
  "description": "Token Description",
  "image": "ipfs://{cid}",
  "animation_url": "ipfs://{cid}",
  "content": {
    "mime": "Content MIME Type",
    "uri": "ipfs://{cid}"
  },
  "attributes": [
    {
      "trait_type": "Trait Type",
      "value": "Trait Value"
    }
  ]
}
```

### Important Notes
- All URIs should use `ipfs://{cid}` format
- Supported media formats:
  - Images: PNG, JPG, GIF
  - 3D: gltf, glb
  - Video: webm, mp4, m4v
  - Audio: mp3, wav
  - Web: HTML

## Contract Permissions

### Role System
All 1155 contracts implement this permission system:

```solidity
uint256 PERMISSION_BIT_ADMIN = 2**1;  // Update sales, metadata, withdraw
uint256 PERMISSION_BIT_MINTER = 2**2; // Mint and airdrop tokens
uint256 CONTRACT_BASE_ID = 0;         // Contract-level permissions
```

### Key Operations
```solidity
function isAdminOrRole(
    address user,
    uint256 tokenId,
    uint256 role
) external view returns (bool)

function addPermission(
    uint256 tokenId,  // 0 for contract level
    address user,
    uint256 permissionBits
) external onlyAdmin
```

## Comments System

Contract Address: `0x7777777C2B3132e03a65721a41745C07170a5877` (all chains)

### Overview
- Only token owners/holders can comment
- Owners pay 1 Spark to comment
- Creators can comment for free
- Anyone can "Spark" (like) comments

### Spark Value Distribution
| Recipient | Percentage | Notes |
|-----------|------------|-------|
| Protocol Fee | 30% | Split between referrer and Zora |
| Referrer | 20% | If specified, otherwise to Zora |
| Zora | 10% | Base protocol fee |
| Creator/Commenter | 70% | For primary comments/replies |

### Comment Types
1. **Primary Comments**
   - On the token itself
   - Spark value goes to creator
   - Requires token ownership

2. **Reply Comments**
   - Responses to existing comments
   - Spark value goes to original commenter
   - Must own token to reply

3. **Sparking (Liking)**
   - Anyone can Spark a comment
   - Rewards go to original commenter
   - No ownership requirement

### Implementation
```typescript
interface CommentIdentifier {
    address commenter;
    address contractAddress;
    uint256 tokenId;
    bytes32 nonce;
}

function comment(
    address commenter,
    address contractAddress,
    uint256 tokenId,
    string calldata text,
    CommentIdentifier calldata replyTo,
    address referrer
) external payable returns (CommentIdentifier memory)
```

### Integration Notes
1. **Spark Value**
   - 1 Spark = 0.000001 ETH
   - Required for non-creator comments
   - Used for "liking" comments

2. **Referral System**
   - Platforms can earn 20% of Spark value
   - Must specify referrer address in calls
   - Applies to comments and Sparks

3. **Legacy Support**
   - Backfilled historical comments
   - Maintains interaction history
   - Preserves comment IDs

## Cointags System

Contract Address: `0x7777777BbD0b88aD5F3b5f4c89C6B60D74b9774F` (Base and Zora Network)

### Overview
Cointags enable creators to:
- Connect posts with onchain communities
- Automatically burn community tokens from mint rewards
- Create token-gated engagement mechanisms

### Sale Strategy Compatibility
- ✅ **Timed Sale (Zero ETH)**: Fully compatible, uses creator's ✧55 rewards
- ✅ **Fixed ETH Price**: Fully compatible, uses 95% creator earnings
- ❌ **ERC20 Price**: Not recommended, requires complex ERC20→ETH conversion

### Reward Recipients

The contract uses a hierarchical system for determining where rewards (earnings) go:

1. **Creator Reward Recipient** (`getCreatorRewardRecipient`)
   - First checks token-specific royalty recipient
   - If not set, falls back to contract's `fundsRecipient`
   - If neither set, defaults to contract itself
   
2. **Setting Recipients**
   ```solidity
   // Set funds recipient for contract or specific token
   function setFundsRecipient(
       uint256 tokenId,  // use 0 for contract-level
       address recipient
   ) external onlyAdmin  // requires PERMISSION_BIT_ADMIN

   // Read current recipient
   function getCreatorRewardRecipient(
       uint256 tokenId
   ) external view returns (address)
   ```

3. **Default Behavior**
   - If no recipient set: Contract becomes recipient
   - Funds can be withdrawn using `withdrawFor` function
   - Requires `PERMISSION_BIT_FUNDS_MANAGER` permission

### Protocol Rewards

#### Rewards Contract
- Address: `0x7777777F279eba3d3Ad8F4E708545291A6fDBA8B` (all chains)
- Handles reward distribution and escrow
- Supports both free and paid mints

#### Withdrawing Rewards
```solidity
// Basic withdrawal
function withdraw(
    address to, 
    uint256 amount
) external;

// Withdraw on behalf of another address
function withdrawFor(
    address to, 
    uint256 amount
) external;

// Withdraw with signature
function withdrawWithSig(
    address from,
    address to,
    uint256 amount,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
) external;
```

#### Key Terms
- **Mint Referral**: Platform that referred a specific mint
- **Create Referral**: Platform that referred the creator to deploy
- **First Minter**: First collector (defaults to creator for ERC20)

#### Integration Notes
1. **For Creators**
   - Select "Free + Rewards" for protocol rewards
   - Specify reward recipient address
   - Rewards accumulate in escrow contract

2. **For Developers**
   - Set `createReferral` during token creation
   - Include `mintReferral` in mint transactions
   - Use appropriate withdrawal method

### Adding Cointags
When implementing Cointags, you need to:

1. **During Token Creation**
   ```typescript
   const { parameters } = await create1155({
     token: {
       tokenMetadataURI: "ipfs://token-metadata.json",
       fundsRecipient: cointagAddress  // Sets contract-level recipient
     }
   });
   ```

2. **After Creation**
   ```solidity
   // Option 1: Set for specific token
   await setFundsRecipient(tokenId, cointagAddress);
   
   // Option 2: Set for entire contract
   await setFundsRecipient(0, cointagAddress);
   ```

3. **Verification**
   ```solidity
   // Verify recipient is set correctly
   const recipient = await getCreatorRewardRecipient(tokenId);
   ```

### How It Works
1. **Setup Process**
   - Creator deploys Cointag via factory
   - Sets 1155 post's reward recipient to Cointag address
   - Configures burn percentage and target token

2. **Reward Flow**
   - Mints generate ETH rewards for creator
   - Rewards split between:
     - Token buying and burning (configured %)
     - Direct creator earnings (remaining %)

3. **Technical Requirements**
   - Must use Uniswap V3 pools
   - Pool must include WETH pair
   - Deterministic deployment ensures consistent addresses

### Contract Architecture
```solidity
// Factory deploys individual Cointag contracts
CointagFactoryImpl {
    // Deterministic deployment using CREATE3
    function deployCointag(
        address creator,
        address pool,
        uint256 burnBps
    ) external returns (address)
}

// Individual Cointag contract
CointagImpl {
    // Distribute accumulated rewards
    function pull() external {
        // 1. Withdraw ETH from protocol rewards
        // 2. Wrap portion as WETH
        // 3. Swap for target ERC20
        // 4. Burn tokens
        // 5. Return remaining ETH to creator
    }
}
```

### Implementation Notes
1. **Automatic Processing**
   - Bot automatically pulls outstanding rewards
   - Handles token swaps and burns
   - Distributes creator earnings

2. **Error Handling**
   - Failed buy/burn sends all ETH to creator
   - Graceful fallback mechanisms
   - Preserves creator earnings

3. **Upgradeability**
   - Uses UUPS proxy pattern
   - Owner-only upgrade rights
   - UpgradeGate security checks

### Integration Considerations
1. **Setup Requirements**
   - Valid Uniswap V3 pool
   - WETH pairing available
   - Proper reward recipient configuration

2. **Monitoring**
   - Track outstanding rewards
   - Monitor burn transactions
   - Verify creator withdrawals

3. **Security**
   - Upgrades controlled by multisig
   - Deterministic addresses across chains
   - Protected reward distribution

## Collector Client Operations

### 1. Getting Token Information (`getToken`)
```typescript
const { token, prepareMint, primaryMintActive, primaryMintEnd, secondaryMarketActive } = await getToken({
  tokenContract: "0x...",  // contract address
  mintType: "1155",        // "1155" | "721" | "premint"
  tokenId: 1n,             // for 1155s
  preferredSaleType?: "fixedPrice" | "erc20" | "allowlist" | "premint" | "timed"
});
```

#### Response Structure
- `token`: Contains contract details, sales config, token info
- `primaryMintActive`: Boolean indicating if primary mint is active
- `primaryMintEnd`: Optional timestamp for mint end
- `secondaryMarketActive`: Boolean for secondary market status
- `prepareMint`: Function to prepare mint transaction (if primary mint active)

### 2. Getting Contract Tokens (`getTokensOfContract`)
```typescript
const { tokens, contract } = await getTokensOfContract({
  tokenContract: "0x...",
  preferredSaleType?: "fixedPrice" | "erc20" | "allowlist" | "premint" | "timed"
});
```
Returns array of all tokens in a contract with their mint status.

### 3. Minting Process
```typescript
// 1. Prepare mint parameters
const { parameters, costs, erc20Approval } = prepareMint({
  minterAccount: "0x...",
  quantityToMint: 3n,
  mintComment?: string,
  mintReferral?: string,
  mintRecipient?: string
});

// 2. Handle ERC20 approval if needed
if (erc20Approval) {
  // Execute approval transaction first
}

// 3. Execute mint transaction
// parameters ready for wallet client
```

## Creator Client Operations

### 1. Creating New 1155 Contract & Token

```typescript
const { parameters, contractAddress } = await create1155({
  contract: {
    name: "ContractName",
    uri: "ipfs://contract-metadata.json",
  },
  token: {
    tokenMetadataURI: "ipfs://token-metadata.json",
    salesConfig: {
      // Secondary Market Configuration
      erc20Name?: "Token Name",      // Optional: defaults to contract name
      erc20Symbol?: "TKN",           // Optional: derived from name if not provided
      saleStart: 0n,                 // 0 = immediate start
      marketCountdown: 86400n,       // 24 hours in seconds
      minimumMintsForCountdown: 1111n
    }
  },
  account: creatorAddress,
  publicClient
});
```

### 2. ERC20 Token Sales Configuration

```typescript
const { parameters } = await create1155({
  contract: {
    name: "ContractName",
    uri: "ipfs://contract-metadata.json",
  },
  token: {
    tokenMetadataURI: "ipfs://token-metadata.json",
    salesConfig: {
      type: "erc20Mint",
      currency: "0x...",  // ERC20 token address
      pricePerToken: 1000000000000000000n,  // Price in ERC20 decimals
      saleStart: 0n,
      saleEnd: 1895873160n
    }
  },
  account: creatorAddress,
  publicClient
});
```

### 3. Split Payment Configuration

```typescript
// 1. Configure Split Recipients
const splitsConfig = {
  recipients: [
    {
      address: "0x...",
      percentAllocation: 70,
    },
    {
      address: "0x...",
      percentAllocation: 30,
    }
  ],
  distributorFeePercent: 0
};

// 2. Create Split Contract (if doesn't exist)
const predicted = await splitsClient.predictImmutableSplitAddress(splitsConfig);
if (!predicted.splitExists) {
  const { data, address } = await splitsClient.callData.createSplit(splitsConfig);
  // Execute split creation transaction
}

// 3. Create 1155 with Split Recipient
const { parameters } = await create1155({
  contract: contractConfig,
  token: {
    tokenMetadataURI: "ipfs://token-metadata.json",
    fundsRecipient: predicted.splitAddress
  },
  account: creatorAddress,
  publicClient
});
```

### Key Creation Considerations

1. **Secondary Market Setup**
   - Zero ETH price enables secondary market
   - Configurable countdown and minimum mints
   - Automatic ERC20 token creation for trading

2. **ERC20 Sales**
   - Requires specific `salesConfig.type = "erc20Mint"`
   - Must specify currency address and price
   - No secondary market available for ERC20 sales

3. **Split Payments**
   - Must be set during creation
   - Not supported with premints
   - Requires two transactions (split creation + token creation)
   - Uses 0xSplits protocol under the hood

4. **Price Configuration Impact**
   - Non-zero ETH price disables secondary market
   - ERC20 pricing disables secondary market
   - Zero ETH price enables full Zora market features

## Pricing Models

### 1. ERC20 Fixed Price Sale
- Token is priced in an ERC20 token (e.g., USDC)
- Identified by `salesConfig.saleType === "erc20"`
- Requires token approval before minting
- Example from API:
```json
"salesConfig": {
  "saleType": "erc20",
  "pricePerToken": "1000000",
  "currency": "0x833589fcd6edb6e08f4c7c32d4f71b54bda02913",  // USDC contract
  "saleEnd": "1895873160",
  "saleStart": "1722554784"
}
```

### 2. ETH Fixed Price Sale
- Token is priced in ETH (non-zero amount)
- No secondary market functionality
- Direct mint without approvals

### 3. Zero ETH with Secondary Market
- Token is priced at 0 ETH
- Enables Zora's secondary market functionality
- Features:
  - Market countdown
  - Minimum mints requirement
  - Secondary trading pool

## Implementation Notes

### API Response Structure
- Primary sale info comes from `salesConfig` object
- Secondary market info available only for zero-ETH tokens
- Need to handle both ERC20 and ETH pricing models in UI

### Key Considerations
1. Check `salesConfig.saleType` to determine pricing model
2. For ERC20, need to handle token approval before minting
3. Secondary market features only available for zero-ETH tokens
4. Always check `primaryMintActive` before attempting mint
5. Handle both preparation and execution of transactions separately

## Secondary Market Operations

### Prerequisites
1. Token must use ZoraTimedSaleStrategy
2. Primary mint period must be ended
3. Secondary market must be launched
4. Token must have been created with zero ETH price

### 1. Getting Secondary Market Info
```typescript
const secondaryInfo = await collectorClient.getSecondaryInfo({
  contract: "0x...",
  tokenId: 4n
});

// Available Secondary Info
interface SecondaryInfo {
  secondaryActivated: boolean;     // If market is live
  pool: `0x${string}`;            // Uniswap pool address
  erc20z: `0x${string}`;          // Trading token address
  name: string;                    // ERC20z token name
  symbol: string;                  // ERC20z token symbol
  saleStart: bigint;              // Mint start time
  saleEnd?: bigint;               // Set after countdown starts
  marketCountdown?: bigint;        // Time until market launch
  minimumMintsForCountdown?: bigint; // Required mints for countdown
  mintCount: bigint;              // Total mints so far
}
```

### 2. Buying on Secondary Market
```typescript
const { parameters, price, error } = await buy1155OnSecondary({
  contract: "0x...",
  tokenId: 1n,
  quantity: 3n,
  account: buyerAddress,
  slippage: 0.005,  // Optional: 0.5% default
  recipient?: "0x...", // Optional: defaults to account
  comment?: "Buying tokens", // Optional
  publicClient
});

if (error) {
  console.error("Market error:", error);
  return;
}

// Price info available
console.log("Per token (wei):", price.wei.perToken);
console.log("Total (wei):", price.wei.total);

// Execute buy transaction
await writeContract(parameters);
```

### 3. Selling on Secondary Market
```typescript
const { parameters, price, error } = await sell1155OnSecondary({
  contract: "0x...",
  tokenId: 1n,
  quantity: 3n,
  account: sellerAddress,
  slippage: 0.005,  // Optional: 0.5% default
  recipient?: "0x...", // Optional: ETH recipient
  publicClient
});

if (error) {
  console.error("Market error:", error);
  return;
}

// Price info available in wei/sparks/USDC
const usdcPrice = await price.usdc.total;
console.log("Sale value (USDC):", usdcPrice);

// Execute sell transaction
await writeContract(parameters);
```

### Secondary Market Flow

#### Creator Perspective
1. Create token with zero ETH price
2. Configure market parameters:
   - `marketCountdown`: Time window after minimum mints
   - `minimumMintsForCountdown`: Mints needed to start countdown
   - `erc20Name/Symbol`: Optional custom token naming

#### Collector Perspective
1. Check if secondary market is active:
   ```typescript
   const { secondaryMarketActive } = await getToken({...});
   const secondaryInfo = secondaryMarketActive ? 
     await getSecondaryInfo({...}) : null;
   ```
2. For buying:
   - Ensure sufficient ETH balance
   - Account for slippage
   - Handle transaction failure cases
3. For selling:
   - Verify token ownership
   - Set appropriate slippage
   - Consider gas costs

### Price Quoting
All market operations return a `QuotePrice` object:
```typescript
interface QuotePrice {
  wei: {
    perToken: bigint;
    total: bigint;
  };
  sparks: {
    perToken: bigint;
    total: bigint;
  };
  usdc: {
    perToken: Promise<number>;
    total: Promise<number>;
  };
}
```

## Deprecated Strategies

### Zero ETH (Timed Sale)
> **Note**: This strategy has been deprecated in favor of Zora Coins, which provides improved liquidity and trading features.

The Zero ETH strategy was previously used for community-driven price discovery and secondary market functionality. It has been replaced by Zora Coins which offers better liquidity management and reward distribution through Uniswap V3 integration.

Contract: `0x777777722D078c97c6ad07d9f36801e653E356Ae` (Historical reference only)

### Merkle Allowlist
> **Note**: This strategy is not currently used in our implementation.

The Merkle Allowlist strategy was designed for:
- Merkle tree-based access control
- Per-address customization (price/quantity)
- Whitelist-based sales

Contract: `0xf48172CA3B6068B20eE4917Eb27b5472f1f272C7` (Historical reference only)

While this strategy could be useful for specific use cases like whitelist sales or custom pricing per address, we currently handle such requirements through other mechanisms.

### Fixed ETH Price
> **Note**: This strategy has been deprecated in favor of ERC20 Minter for fixed pricing and Zora Coins for ETH-based trading.

The Fixed ETH Price strategy was previously used for direct ETH payments. It has been replaced by:
- ERC20 Minter for fixed pricing (using USDC/$ENSURE)
- Zora Coins for ETH-based trading and liquidity

This change better serves our corporate and non-crypto users by:
- Providing stable pricing in USD-pegged tokens
- Offering better reward distribution
- Supporting more sophisticated trading features
- Enabling clearer business accounting

Contract: `0x04E2516A2c207E84a1839755675dfd8eF6302F0a` (Historical reference only)
````

## File: src/app/docs/technical/page.mdx
````
# Technical Documentation

## Certificates of Ensurance

### General Ensurance (`ERC-20`)
Values what matters, flowing like a currency where market activity **indirectly** funds place, people, and purpose.

*Full contract list available in /market for active general ensurance*

### Specific Ensurance (`ERC-1155`)
Protects what matters, anchoring as an asset to **directly** fund natural assets and stewardship.

*Full contract list available in /market for active specific ensurance*

## ENSURE Currency
Nature-based utility token that provides liquidity between currencies and assets.
- Standard: `ERC-20`
- Primary Chain: Base
- Cross-chain: EVM via [Axelar ITS](https://interchain.axelar.dev/base/0x0c66d591d1ff5944A44aebB65c33f6B6e82a124F)

### Contract Addresses
```
Base:           0x0c66d591d1ff5944a44aebb65c33f6b6e82a124f
Other EVMs:     0x0ea010dCB1DfBE5c9d1AC475901a59642bad90f4
Axelar Relayer: 0xF29D33e99F770caC53Aad2CE125711329804A76a
```

## Group Protocol (SITUS)

### Core Contracts
```
Factory:  0x67c814835e1920324634fd6da416a0e79c949970 [Base]
Resolver: 0x30EF3151Ca370562F25ea6F3611fEFD70B5a93df [Base]
```

### Groups
Available via [`getTldsArray`](https://basescan.org/address/0x67c814835e1920324634fd6da416a0e79c949970#readContract#F3) e.g.
```
[.basin, .situs, .boulder, .regen, .mumbai, .refi, .ebf, 
.bloom, .bioregion, .kokonut, .ogallala, .sicilia, .tokyo, .earth]
```

Use [`tldNamesAddresses`](https://basescan.org/address/0x67c814835e1920324634fd6da416a0e79c949970#readContract#F9) to get contract addresses (e.g., `.basin` → `0x76AC406218413950DB2b050f7C3449AB5E24AABc`)

### Metadata Contracts
1. **Onchain Default** (Basic SVG)
   ```
   0x780A9a92BA66a29d942bdb289DB455F8e3ED0dFa [Base]
   ```

2. **Dynamic Custom** (API Route)
   ```
   0x38b34fe7Ae46aEB93ca0afDa165568656720B31d [Base]
   ```

## Tokenbound Implementation (`ERC-6551`)

All contracts on Base network:
```
Create2 Factory:             0x4e59b44847b379578588920ca78fbf26c0b4956c
ERC-6551 Registry:           0x000000006551c19487814612e58FE06813775758
V3 Account Proxy:            0x55266d75D1a14E4572138116aF39863Ed6596E7F
V3 Account Implementation:   0x41C8f39463A868d3A88af00cd0fe7102F30E44eC
V3 Account Guardian:         0x2FE5ccb0d7Ea195FEb87987d3573F9fcCE2b5D57
Authenticated Multicall:     0xcA1167915584462449EE5b4Ea51c37fE81eCDCCD
LayerZero V2 Executor:       0x0F220412Bf22E05EBcC5070D60fd7136A08aF22C
```

## Accounts & Agents

### Types
1. **Human Operated**
   - EOA
   - Smart wallet
   - Safe
   
2. **Semi-Autonomous**
   - Agent Account: Tokenbound account with agent + human controls
   - Operator Account: OwnerOf account with human controls
   - Can be EOA or Server Wallet

### Account Properties
- `name`: Unique onchain name within Group namespace
- `tokenId`: Distinct numerical identifier
- `AgentAccount`: Cross-chain 0x wallet for onchain interactions

### Group Contract Functions
- `buyingEnabled`: Controls new account creation
- `metadataAddress`: Data reference storage
- `minter`: Account issuance control
- `price`: Account cost
- `referral`: Referral structure
- `owner`: Contract ownership

### Token Standards
Accounts can hold and transact:
- `ERC-20`: Fungible tokens/currency
- `ERC-721`: NFTs/unique assets
- `ERC-1155`: Semi-fungible tokens/certificates

## Ensurance Proceeds
Modeled after natural water cycles, proceeds flow through three distribution mechanisms:

### Distribution Types
```
Instance-based:  Immediate funding
Time-based:      3 months to 512 years
Continuous:      Ongoing stewardship
```

*Full contract list available soon in /proceeds*

All proceeds can be traced from [HEADWATERS](https://app.splits.org/accounts/0xa187F8CBdd36D63967c33f5BD4dD4B9ECA51270e/?chainId=8453) on Base.

## Deprecated Contracts
*If you own assets on these contracts, contact us for migration to new versions*

### ENSURANCE
```
Base:      0x1f98380fb1b3ae8cd097d5f9d49a7e79cd69a4fb
Zora:      0x14b71a8e0c2c4d069cb230cc88a1423736b34096
Arbitrum:  0xc6e4e6e5a11e70af6334bf3274f4d4c2e0ce3571
Optimism:  0x5c738cdf228d8c6e8dc68a94b08be7d8958bcccf
```

### Legacy Protocols
```
Emergent Streams (Polygon): 0xc31b90964a5062376a62e2c772a6c4d422cd73b2
.basin MVP (Polygon):       0x4bf5a99ea2f8de061f7d77ba9edd749503d945da
```
````

## File: src/app/docs/tldr/page.mdx
````
# TLDR

Society and the economy are 100% dependent on nature.

Yet the foundation of all wealth—physical, financial, spiritual—is in rapid decline, nearing irreversible tipping points. Avoiding systemic collapse requires $1T annual investment in biodiversity and natural capital.

**Natural Capital Ensurance**, by BASIN, transforms how we value and fund nature-ensuring the benefits it provides to all beings.

Rather than donating or expensing, anyone-person, group, or agent-can invest to:
- Reduce risk
- Increase resilience
- Enhance well-being

These Ensurance investments secure real assets that deliver financial, ecological, social, and cultural returns-while honoring nature's intrinsic value.
````

## File: src/app/docs/layout.tsx
````typescript
'use client'

import { useState, useEffect } from 'react'
import Link from 'next/link'
import { usePathname } from 'next/navigation'

// Navigation items for the sidebar
const navItems = [
  {
    title: 'TLDR',
    links: [
      { href: '/docs/tldr', label: 'TLDR' },
    ]
  },
  {
    title: 'FUNDAMENTALS',
    links: [
      { href: '/docs/fundamentals', label: 'FUNDAMENTALS' },
    ]
  },
  {
    title: 'NATURAL CAPITAL',
    links: [
      { href: '/docs/natural-capital', label: 'NATURAL CAPITAL' },
    ]
  },
  {
    title: 'ENSURANCE',
    links: [
      { href: '/docs/ensurance', label: 'ENSURANCE' },
    ]
  },
  {
    title: 'PROTOCOL',
    links: [
      { href: '/docs/protocol', label: 'PROTOCOL' },
    ]
  },
  {
    title: 'TECHNICAL',
    links: [
      { href: '/docs/technical', label: 'TECHNICAL' },
    ]
  },
  {
    title: 'FAQ',
    links: [
      { href: '/docs/faq', label: 'FAQ' },
    ]
  }
]

function DocsNavigation() {
  const pathname = usePathname()

  return (
    <nav className="w-52 pr-6 hidden md:block">
      <div className="sticky top-24">
        <h5 className="text-xs font-semibold text-[rgba(var(--foreground-rgb),0.5)] uppercase tracking-wide mb-6 font-mono">
          Documentation
        </h5>
        <ul className="space-y-4">
          {navItems.map((section, idx) => (
            <li key={idx}>
              {section.links.map((link) => (
                <Link
                  key={link.href}
                  href={link.href}
                  className={`block py-1 text-sm font-grotesk ${
                    pathname === link.href
                      ? 'text-[rgb(var(--foreground-rgb))]'
                      : 'text-[rgba(var(--foreground-rgb),0.7)] hover:text-[rgb(var(--foreground-rgb))]'
                  }`}
                >
                  {link.label}
                </Link>
              ))}
            </li>
          ))}
        </ul>
      </div>
    </nav>
  )
}

function TableOfContents() {
  const [headings, setHeadings] = useState<{ id: string; text: string; level: number }[]>([])
  const [activeId, setActiveId] = useState<string>('')
  const [opacity, setOpacity] = useState(1)
  const pathname = usePathname()

  useEffect(() => {
    // Get all headings from the main content
    const elements = document.querySelectorAll('main h2, main h3')
    const headingsList = Array.from(elements).map((element) => {
      // Generate ID if not present (fallback)
      if (!element.id) {
        element.id = element.textContent?.toLowerCase().replace(/[^a-z0-9\s-]/g, '').replace(/\s+/g, '-') || ''
      }
      return {
        id: element.id,
        text: element.textContent || '',
        level: Number(element.tagName[1])
      }
    })
    setHeadings(headingsList)

    // Handle scroll and active section
    const handleScroll = () => {
      const pageNav = document.querySelector('.page-navigation')
      if (!pageNav) return

      // Handle opacity
      const windowHeight = window.innerHeight
      const pageNavTop = pageNav.getBoundingClientRect().top
      const fadeDistance = windowHeight / 2
      const rawOpacity = Math.min(Math.max((pageNavTop - (windowHeight / 2)) / fadeDistance, 0), 1)
      const newOpacity = 0.4 + (rawOpacity * 0.6)
      setOpacity(newOpacity)

      // Find active section
      const headingElements = Array.from(document.querySelectorAll('main h2, main h3'))
      for (const element of headingElements) {
        const { top } = element.getBoundingClientRect()
        if (top >= 0 && top <= 150) {
          setActiveId(element.id)
          break
        }
      }
    }

    window.addEventListener('scroll', handleScroll)
    handleScroll() // Initial check

    return () => window.removeEventListener('scroll', handleScroll)
  }, [pathname])

  return (
    <nav className="w-52 pl-4 hidden lg:block">
      <div className="sticky top-24" style={{ opacity: headings.length ? opacity : 0, transition: 'opacity 150ms ease-out' }}>
        {headings.length > 0 && (
          <>
            <h5 className="text-xs font-semibold text-[rgba(var(--foreground-rgb),0.5)] uppercase tracking-wide mb-6 font-mono">
              On this page
            </h5>
            <ul className="space-y-1.5">
              {headings.map((heading) => (
                <li key={heading.id}>
                  <Link
                    href={`${pathname}#${heading.id}`}
                    className={`block py-1 text-sm hover:text-[rgba(var(--foreground-rgb),0.8)] font-grotesk transition-colors ${
                      heading.level === 3 ? 'pl-3 text-xs' : ''
                    } ${
                      activeId === heading.id 
                        ? 'text-[rgb(var(--foreground-rgb))]' 
                        : 'text-[rgba(var(--foreground-rgb),0.5)]'
                    }`}
                  >
                    {heading.text}
                  </Link>
                </li>
              ))}
            </ul>
          </>
        )}
      </div>
    </nav>
  )
}

function PageNavigation() {
  const pathname = usePathname()
  
  const allPages = navItems.reduce((acc, section) => {
    return [...acc, ...section.links]
  }, [] as { href: string; label: string }[])
  
  const currentIndex = allPages.findIndex(page => page.href === pathname)
  const prevPage = currentIndex > 0 ? allPages[currentIndex - 1] : null
  const nextPage = currentIndex < allPages.length - 1 ? allPages[currentIndex + 1] : null
  
  return (
    <div className="mt-16 flex justify-center gap-8 border-t border-[rgba(var(--foreground-rgb),0.1)] pt-8 page-navigation">
      {prevPage ? (
        <Link 
          href={prevPage.href} 
          className="group flex flex-col items-center p-4 rounded-lg bg-[rgba(var(--foreground-rgb),0.03)] hover:bg-[rgba(var(--foreground-rgb),0.05)] transition-all duration-200 min-w-[200px]"
        >
          <span className="text-sm text-[rgba(var(--foreground-rgb),0.5)]">Previous</span>
          <span className="text-center text-[rgba(var(--foreground-rgb),0.8)] group-hover:text-[rgb(var(--foreground-rgb))]">
            {prevPage.label}
          </span>
        </Link>
      ) : <div className="min-w-[200px]" />}
      
      {nextPage ? (
        <Link 
          href={nextPage.href} 
          className="group flex flex-col items-center p-4 rounded-lg bg-[rgba(var(--foreground-rgb),0.03)] hover:bg-[rgba(var(--foreground-rgb),0.05)] transition-all duration-200 min-w-[200px]"
        >
          <span className="text-sm text-[rgba(var(--foreground-rgb),0.5)]">Next</span>
          <span className="text-center text-[rgba(var(--foreground-rgb),0.8)] group-hover:text-[rgb(var(--foreground-rgb))]">
            {nextPage.label}
          </span>
        </Link>
      ) : <div className="min-w-[200px]" />}
    </div>
  )
}

export default function DocsLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <div className="container mx-auto pl-4 pr-2 py-16">
      <div className="flex">
        <DocsNavigation />
        <main className="flex-1 min-w-0 max-w-3xl mx-auto -mt-8">
          <div className="prose prose-invert max-w-none">
            {children}
          </div>
          <PageNavigation />
        </main>
        <TableOfContents />
      </div>
    </div>
  )
}
````

## File: src/app/docs/page.mdx
````
# Documentation

Welcome to the Natural Capital Ensurance documentation. 

## Quick Start

For a quick overview of Natural Capital Ensurance, start with our [TLDR](/docs/tldr) section.

## Main Sections

<div className="section-grid">
  <div className="section">
    <a href="/docs/fundamentals" className="card-link" aria-label="Read Fundamentals documentation"></a>
    <div className="section-content">
      <h3 className="section-title">Fundamentals</h3>
      <p className="section-description">
        Core concepts and components of the protocol, including Groups, Accounts/Agents, Assets, Currency, and Mechanisms.
      </p>
    </div>
  </div>

  <div className="section">
    <a href="/docs/natural-capital" className="card-link" aria-label="Read Natural Capital documentation"></a>
    <div className="section-content">
      <h3 className="section-title">Natural Capital</h3>
      <p className="section-description">
        Understanding natural capital, its stocks and flows, and how they're safeguarded through the protocol.
      </p>
    </div>
  </div>

  <div className="section">
    <a href="/docs/ensurance" className="card-link" aria-label="Read Ensurance documentation"></a>
    <div className="section-content">
      <h3 className="section-title">Ensurance</h3>
      <p className="section-description">
        Detailed explanation of how Natural Capital Ensurance works and its key features.
      </p>
    </div>
  </div>

  <div className="section">
    <a href="/docs/protocol" className="card-link" aria-label="Read Protocol documentation"></a>
    <div className="section-content">
      <h3 className="section-title">Protocol</h3>
      <p className="section-description">
        Details of the BASIN SITUS Protocol and its implementation.
      </p>
    </div>
  </div>

  <div className="section">
    <a href="/docs/technical" className="card-link" aria-label="Read Technical documentation"></a>
    <div className="section-content">
      <h3 className="section-title">Technical</h3>
      <p className="section-description">
        In-depth technical documentation for developers and integrators.
      </p>
    </div>
  </div>

  <div className="section">
    <a href="/docs/faq" className="card-link" aria-label="Read FAQ"></a>
    <div className="section-content">
      <h3 className="section-title">FAQ</h3>
      <p className="section-description">
        Frequently asked questions about Natural Capital Ensurance.
      </p>
    </div>
  </div>
</div>
````

## File: src/app/ensure/page.tsx
````typescript
'use client'

import { useState } from 'react'
import EnsureGrid from '@/modules/ensure/EnsureGrid'
import { TypewriterInput } from '@/components/ui/typewriter-input'
import { ensurePhrases } from '@/modules/ensure/ensurePhrases'
import { cn } from '@/lib/utils'

export default function EnsurePage() {
  const [ensureData, setEnsureData] = useState<any[]>([])
  const [searchQuery, setSearchQuery] = useState('')
  const [isInputFocused, setIsInputFocused] = useState(false)

  return (
    <div className="min-h-screen flex flex-col">
      <div className="container mx-auto px-4 py-8 flex-1">
        <div className="space-y-8">
          <div className="px-4 md:px-6 pt-8">
            <h1 className="text-2xl md:text-4xl font-bold text-center mb-3 md:mb-4">
              what do you want to ensure?
            </h1>
            <div className="w-full flex justify-center mb-6 md:mb-8 px-2 md:px-0">
              <div className="relative w-full max-w-2xl">
                <input
                  type="text"
                  value={searchQuery}
                  onChange={(e) => setSearchQuery(e.target.value)}
                  onFocus={() => setIsInputFocused(true)}
                  placeholder=""
                  className={cn(
                    "w-full px-4 py-2 rounded-lg text-center",
                    "bg-[rgb(var(--background-rgb))]",
                    "border border-[rgba(var(--foreground-rgb),0.1)]",
                    "text-[rgb(var(--foreground-rgb))]",
                    "placeholder:text-[rgba(var(--foreground-rgb),0.5)]",
                    "focus:outline-none focus:ring-2 focus:ring-[rgba(var(--foreground-rgb),0.2)]",
                    "transition-colors duration-200",
                    "text-2xl md:text-3xl"
                  )}
                />
                {!isInputFocused && (
                  <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                    <TypewriterInput words={ensurePhrases} size="small" />
                  </div>
                )}
              </div>
            </div>
          </div>
          <EnsureGrid 
            types={['general', 'specific', 'syndicate', 'account', 'group']}
            urlPrefix=""
            searchQuery={searchQuery}
            onDataChange={setEnsureData}
          />
        </div>
      </div>
    </div>
  )
}
````

## File: src/app/exposure/page.tsx
````typescript
'use client'

import { useState } from 'react'
import { PageHeader } from '@/components/layout/PageHeader'
import ExposureSankey from '@/modules/exposure/ExposureSankey'
import Link from 'next/link'
import { exposureData } from '@/modules/exposure/data'

export default function ExposurePage() {
  return (
    <>
      <div className="h-screen w-screen bg-primary-dark overflow-hidden p-0 m-0">
        <ExposureSankey data={exposureData} />
      </div>
      <div className="w-full text-xs text-gray-400 text-center py-2 bg-black/80 border-t border-gray-800/60">
        Data based on industry dependencies and risks mapping from{' '}
        <Link 
          href="https://docs.basin.global/appendix/ecosystem-services-dependencies-and-risks" 
          target="_blank"
          className="underline hover:text-gray-300"
        >
          BASIN Field Manual
        </Link>
        . Magnitude represents total nature-related financial risk exposure.
      </div>
    </>
  );
}
````

## File: src/app/general/[contract]/page.tsx
````typescript
import { sql } from '@vercel/postgres'
import { notFound } from 'next/navigation'
import Link from 'next/link'
import { ArrowLeft } from 'lucide-react'
import Details from '@/modules/general/Details'
import { PageHeader } from '@/components/layout/PageHeader'
import VerificationSection from '@/components/layout/verifications/VerificationSection'
import { SplitsWrapper } from '@/providers/splits-provider'
import { Metadata } from 'next'

// Tell Next.js this is a dynamic route
export const dynamic = 'force-dynamic'

// Generate metadata for the page
export async function generateMetadata({ params }: { params: { contract: string } }): Promise<Metadata> {
  const dbResult = await sql`
    SELECT name, token_uri, contract_address
    FROM certificates.general 
    WHERE contract_address = ${params.contract}
  `
  const certificate = dbResult.rows[0]
  if (!certificate) return {}
  
  return {
    title: `${certificate.name} | Ensurance`,
    description: `View and trade ${certificate.name} certificate on Ensurance`,
  }
}

export default async function GeneralCertificateDetails({ 
  params 
}: { 
  params: { contract: string } 
}) {
  // Get immutable data from DB
  const dbResult = await sql`
    SELECT name, token_uri, contract_address, payout_recipient, provenance, initial_supply
    FROM certificates.general 
    WHERE contract_address = ${params.contract}
  `
  const certificate = dbResult.rows[0]
  if (!certificate) {
    notFound()
  }

  return (
    <div className="min-h-screen flex flex-col">
      <PageHeader 
        title="general ensurance"
        showSearch={false}
        showBackArrow={true}
        backLink="/general"
      />
      
      <div className="container mx-auto px-4 flex-1 pb-12">
        <SplitsWrapper>
          <Details
            contractAddress={certificate.contract_address}
            name={certificate.name}
            tokenUri={certificate.token_uri}
            payout_recipient={certificate.payout_recipient}
            provenance={certificate.provenance}
            initial_supply={certificate.initial_supply}
          />
        </SplitsWrapper>
      </div>

      <VerificationSection 
        type="general"
        name={certificate.name}
        contractAddress={certificate.contract_address}
      />
    </div>
  )
}
````

## File: src/app/general/page.tsx
````typescript
'use client'

import { useState } from 'react'
import { PageHeader } from "@/components/layout/PageHeader"
import GeneralGrid from '@/modules/general/GeneralGrid'
import MarketSummary from '@/modules/general/GeneralMarketSummary'

interface MarketData {
  total_volume?: string
  market_cap?: string
}

export default function GeneralPage() {
  const [searchQuery, setSearchQuery] = useState('')
  const [marketData, setMarketData] = useState<MarketData[]>([])

  return (
    <div className="container mx-auto px-4 py-6">
      <div className="flex flex-col gap-6">
        <div className="flex justify-between items-start">
          <div className="flex-1">
            <PageHeader 
              title="general ensurance"
              searchQuery={searchQuery}
              setSearchQuery={setSearchQuery}
              searchPlaceholder="what do you want to ensure?"
            />
          </div>
          <div className="min-w-[300px] pt-2">
            <MarketSummary 
              data={marketData}
              variant="subtle"
            />
          </div>
        </div>

        <GeneralGrid
          searchQuery={searchQuery}
          onDataChange={setMarketData}
        />
      </div>
    </div>
  )
}
````

## File: src/app/groups/[group]/[view]/page.tsx
````typescript
'use client'

import { useEffect } from 'react'
import { useRouter } from 'next/navigation'
import AccountsGrid from '@/modules/accounts/AccountsGrid'

export default function GroupPage({ params }: { params: { group: string; view: string } }) {
  const router = useRouter()

  useEffect(() => {
    console.log('Group page params:', params)
    
    if (params.group === 'ensurance' && params.view === 'all') {
      console.log('Redirecting to pools')
      router.replace('/pools')
      return
    }
  }, [params.group, params.view, router])

  return (
    <div className="container mx-auto px-4 py-8">
      <AccountsGrid groupName={params.group} />
    </div>
  )
}
````

## File: src/app/groups/[group]/all/page.tsx
````typescript
'use client'

import { useState } from 'react'
import AccountsGrid from '@/modules/accounts/AccountsGrid'
import { AssetSearch } from '@/modules/assets/AssetSearch'
import { GroupInfo } from '@/modules/groups/GroupInfo'
import VerificationSection from '@/components/layout/verifications/VerificationSection'

export default function GroupAllPage({ params }: { params: { group: string } }) {
  const [searchQuery, setSearchQuery] = useState('')

  return (
    <div className="min-h-screen flex flex-col">
      <div className="container mx-auto px-4 py-8 flex-1">
        <div className="space-y-4">
          <div className="w-full flex justify-center mb-8">
            <AssetSearch 
              searchQuery={searchQuery} 
              setSearchQuery={setSearchQuery}
              placeholder="Search accounts..."
            />
          </div>
          <AccountsGrid 
            groupName={params.group} 
            searchQuery={searchQuery}
          />
        </div>
      </div>
      <GroupInfo groupName={params.group} />
      <VerificationSection type="group" name={params.group} />
    </div>
  )
}
````

## File: src/app/groups/[group]/create/page.tsx
````typescript
'use client'

import { GroupInfo } from '@/modules/groups/GroupInfo'
import Image from 'next/image'
import { PageHeader } from '@/components/layout/PageHeader'

export default function GroupCreatePage({ params }: { params: { group: string } }) {
    return (
        <div className="min-h-screen flex flex-col">
            <div className="container mx-auto px-4 py-8 flex-1">
                <div className="space-y-4">
                    <PageHeader
                        title={`create ${params.group} account`}
                        showSearch={false}
                    />
                    <div className="flex items-center justify-center py-12">
                        <div className="w-20 h-20 flex-shrink-0 mr-6">
                            <Image
                                src={`/groups/orbs/${params.group}-orb.png`}
                                alt={`${params.group} orb`}
                                width={80}
                                height={80}
                                className="rounded-full"
                            />
                        </div>
                        <div>
                            <p className="text-xl font-mono text-white-400 mb-4">
                                Create your own .{params.group} account...
                            </p>
                            <p className="text-gray-500 font-mono">
                                Account creation is coming soon.{' '}
                                <a 
                                    href="https://x.com/ensurance_app" 
                                    target="_blank" 
                                    rel="noopener noreferrer"
                                    className="text-blue-400 hover:text-blue-300 transition-colors"
                                >
                                    follow updates here
                                </a>
                                .
                            </p>
                        </div>
                    </div>
                </div>
            </div>
            <GroupInfo groupName={params.group} />
        </div>
    )
}
````

## File: src/app/groups/[group]/mine/page.tsx
````typescript
'use client'

import { useState } from 'react'
import { usePrivy } from '@privy-io/react-auth'
import AccountsGrid from '@/modules/accounts/AccountsGrid'
import { PageHeader } from '@/components/layout/PageHeader'
import { GroupInfo } from '@/modules/groups/GroupInfo'

// Tell Next.js this is a dynamic route
export const dynamic = 'force-dynamic'

export default function GroupMinePage({ params }: { params: { group: string } }) {
  const [searchQuery, setSearchQuery] = useState('')
  const { user, ready, authenticated } = usePrivy()
  const walletAddress = user?.wallet?.address

  // If not ready, show loading
  if (!ready) {
    return (
      <div className="min-h-screen flex flex-col">
        <div className="flex-1 flex flex-col items-center justify-center p-8">
          <p className="text-xl text-center mb-4">Loading...</p>
          <p className="text-gray-500 text-center">Please wait...</p>
        </div>
        <GroupInfo groupName={params.group} />
      </div>
    )
  }

  // If not connected, show connect message
  if (!authenticated || !walletAddress) {
    return (
      <div className="min-h-screen flex flex-col">
        <div className="flex-1 flex flex-col items-center justify-center p-8">
          <p className="text-xl text-center mb-4">👋 Connect your wallet</p>
          <p className="text-gray-500 text-center">
            Connect your wallet to view your accounts and manage your assets
          </p>
        </div>
        <GroupInfo groupName={params.group} />
      </div>
    )
  }

  return (
    <div className="min-h-screen flex flex-col">
      <div className="container mx-auto px-4 py-8 flex-1">
        <div className="space-y-4">
          <PageHeader
            title={`my ${params.group} accounts`}
            searchQuery={searchQuery}
            setSearchQuery={setSearchQuery}
          />
          <AccountsGrid 
            groupName={params.group} 
            searchQuery={searchQuery}
            walletAddress={walletAddress}
          />
        </div>
      </div>
      <GroupInfo groupName={params.group} />
    </div>
  )
}
````

## File: src/app/groups/[group]/page.tsx
````typescript
import { groups } from '@/lib/database/groups'
import { notFound } from 'next/navigation'
import Image from 'next/image'
import Link from 'next/link'
import VerificationSection from '@/components/layout/verifications/VerificationSection'

export default async function GroupPage({ params }: { params: { group: string } }) {
    const groupData = await groups.getByName(`.${params.group}`)
    if (!groupData) {
        notFound()
    }

    return (
        <div className="flex flex-col min-h-screen">
            <div className="flex-1">
                {/* Hero Section with Banner */}
                <div className="relative h-[40vh] min-h-[400px]">
                    <Image
                        src={`/groups/banners/${params.group}-banner.jpg`}
                        alt={`${groupData.group_name} Banner`}
                        fill
                        className="object-cover brightness-75"
                        priority
                    />
                    <div className="absolute inset-0 bg-gradient-to-t from-black/90 via-black/50 to-transparent" />
                    
                    {/* Orb and Title Content */}
                    <div className="container mx-auto px-4 h-full relative z-10">
                        <div className="flex items-end h-full pb-12 max-w-4xl mx-auto">
                            <div className="flex items-center gap-8">
                                <div className="relative w-40 h-40">
                                    <Image
                                        src={`/groups/orbs/${params.group}-orb.png`}
                                        alt={`${groupData.group_name} Orb`}
                                        fill
                                        className="rounded-full"
                                    />
                                </div>
                                <div>
                                    <h1 className="text-5xl font-bold mb-4 text-white">
                                        {groupData.group_name}
                                    </h1>
                                    
                                    {groupData.name_front && (
                                        <h2 className="text-2xl text-gray-100 mb-4">
                                            {groupData.name_front}
                                        </h2>
                                    )}

                                    {groupData.tagline && (
                                        <p className="text-xl text-gray-200">
                                            {groupData.tagline}
                                        </p>
                                    )}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                {/* Content Section */}
                <div className="container mx-auto px-4 py-12">
                    <div className="max-w-4xl mx-auto">
                        {groupData.description && (
                            <div className="prose dark:prose-invert max-w-none mb-12">
                                <p className="text-lg leading-relaxed">{groupData.description}</p>
                            </div>
                        )}

                        <div className="grid grid-cols-1 md:grid-cols-2 gap-8 bg-gray-900/50 rounded-xl p-8">
                            <div className="space-y-6">
                                <h3 className="text-xl font-semibold">Details</h3>
                                <dl className="space-y-4">
                                    {groupData.situs_account && (
                                        <div>
                                            <dt className="text-sm text-gray-400">Situs Account</dt>
                                            <dd className="mt-1">
                                                <Link 
                                                    href={`/${groupData.situs_account}`}
                                                    className="font-mono text-blue-400 hover:text-blue-300"
                                                >
                                                    {groupData.situs_account}
                                                </Link>
                                            </dd>
                                            {groupData.tba_address && (
                                                <dd className="mt-1 font-mono text-sm text-gray-500 break-all">
                                                    {groupData.tba_address}
                                                </dd>
                                            )}
                                        </div>
                                    )}
                                    <div>
                                        <dt className="text-sm text-gray-400">Contract Address</dt>
                                        <dd className="font-mono mt-1">{groupData.contract_address}</dd>
                                    </div>
                                    <div>
                                        <dt className="text-sm text-gray-400">Total Supply</dt>
                                        <dd className="mt-1">{groupData.total_supply}</dd>
                                    </div>
                                </dl>
                            </div>

                            <div className="space-y-6">
                                <h3 className="text-xl font-semibold">Contact</h3>
                                <dl className="space-y-4">
                                    {groupData.email && (
                                        <div>
                                            <dt className="text-sm text-gray-400">Email</dt>
                                            <dd className="mt-1">
                                                <a href={`mailto:${groupData.email}`} className="text-blue-400 hover:text-blue-300">
                                                    {groupData.email}
                                                </a>
                                            </dd>
                                        </div>
                                    )}
                                    {groupData.website && (
                                        <div>
                                            <dt className="text-sm text-gray-400">Website</dt>
                                            <dd className="mt-1">
                                                <a href={groupData.website} target="_blank" rel="noopener noreferrer" className="text-blue-400 hover:text-blue-300">
                                                    {groupData.website}
                                                </a>
                                            </dd>
                                        </div>
                                    )}
                                    {groupData.chat && (
                                        <div>
                                            <dt className="text-sm text-gray-400">Chat</dt>
                                            <dd className="mt-1">
                                                <a href={groupData.chat} target="_blank" rel="noopener noreferrer" className="text-blue-400 hover:text-blue-300">
                                                    Join Chat
                                                </a>
                                            </dd>
                                        </div>
                                    )}
                                </dl>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <VerificationSection type="group" name={params.group} />
        </div>
    )
}
````

## File: src/app/groups/page.tsx
````typescript
'use client'

import { useState } from 'react'
import GroupGrid from '@/modules/groups/GroupGrid'
import { PageHeader } from '@/components/layout/PageHeader'

export default function GroupsPage() {
    const [searchQuery, setSearchQuery] = useState('')

    return (
        <div className="min-h-screen flex flex-col">
            <div className="container mx-auto px-4 py-8 flex-1">
                <div className="space-y-4">
                    <PageHeader
                        title="ensurance groups"
                        searchQuery={searchQuery}
                        setSearchQuery={setSearchQuery}
                        searchPlaceholder="Search groups..."
                    />
                    <GroupGrid searchQuery={searchQuery} />
                </div>
            </div>
        </div>
    )
}
````

## File: src/app/markets/page.tsx
````typescript
'use client'

import { useState } from 'react'
import { PageHeader } from '@/components/layout/PageHeader'
import EnsureGrid from '@/modules/ensure/EnsureGrid'

export default function MarketsPage() {
  const [marketData, setMarketData] = useState<any[]>([])
  const [searchQuery, setSearchQuery] = useState('')

  return (
    <div className="min-h-screen flex flex-col">
      <div className="container mx-auto px-4 py-8 flex-1">
        <div className="space-y-8">
          <PageHeader
            title="ensurance markets"
            searchQuery={searchQuery}
            setSearchQuery={setSearchQuery}
            searchPlaceholder="what do you want to ensure?"
            showSearch={true}
          />
          <EnsureGrid 
            types={['general', 'specific']}
            urlPrefix=""
            searchQuery={searchQuery}
            onDataChange={setMarketData}
          />
        </div>
      </div>
    </div>
  )
}
````

## File: src/app/natural-capital/flows/page.tsx
````typescript
'use client'

import { Suspense } from 'react'
import NaturalCapitalGrid from '@/modules/natural-capital/NaturalCapitalGrid'
import { useSearch } from '../SearchContext'

function FlowsContent() {
    const { searchQuery } = useSearch()
    
    return (
        <div className="container mx-auto px-4">
            <Suspense fallback={<div>Loading...</div>}>
                <NaturalCapitalGrid
                    variant="standard"
                    showHeader={false}
                    activeCategory="flow"
                    urlPrefix="/natural-capital"
                    searchQuery={searchQuery}
                />
            </Suspense>
        </div>
    )
}

export default function FlowsPage() {
    return <FlowsContent />
}
````

## File: src/app/natural-capital/stocks/page.tsx
````typescript
'use client'

import { Suspense } from 'react'
import NaturalCapitalGrid from '@/modules/natural-capital/NaturalCapitalGrid'
import { useSearch } from '../SearchContext'

function StocksContent() {
    const { searchQuery } = useSearch()
    
    return (
        <div className="container mx-auto px-4">
            <Suspense fallback={<div>Loading...</div>}>
                <NaturalCapitalGrid
                    variant="standard"
                    showHeader={false}
                    activeCategory="stock"
                    urlPrefix="/natural-capital"
                    searchQuery={searchQuery}
                />
            </Suspense>
        </div>
    )
}

export default function StocksPage() {
    return <StocksContent />
}
````

## File: src/app/natural-capital/layout.tsx
````typescript
'use client'

import { usePathname, useRouter } from 'next/navigation'
import { SearchProvider, useSearch } from './SearchContext'
import { PageHeader } from '@/components/layout/PageHeader'

type Category = 'all' | 'stocks' | 'flows'

function NavigationContent() {
    const router = useRouter()
    const pathname = usePathname()
    const { searchQuery, setSearchQuery } = useSearch()
    
    const activeCategory = pathname === '/natural-capital' 
        ? 'all'
        : pathname.endsWith('/stocks') 
            ? 'stock' 
            : 'flow'

    const isMainPage = pathname === '/natural-capital'

    const allTabs = [
        { value: 'all', display: 'ALL', href: '/natural-capital' },
        { value: 'stock', display: 'STOCKS', href: '/natural-capital/stocks' },
        { value: 'flow', display: 'FLOWS', href: '/natural-capital/flows' }
    ]

    const mainPageTabs = allTabs.filter(tab => tab.value !== 'all')
    
    const tabs = isMainPage ? mainPageTabs : allTabs

    const handleTabChange = (value: string) => {
        const tab = tabs.find(t => t.value === value)
        if (tab) {
            router.push(tab.href)
        }
    }

    return (
        <div className="container mx-auto px-4 py-8">
            <div className="space-y-6">
                <PageHeader
                    title="natural capital"
                    searchQuery={searchQuery}
                    setSearchQuery={setSearchQuery}
                    searchPlaceholder="search natural capital..."
                    tabs={tabs}
                    activeTab={activeCategory}
                    onTabChange={handleTabChange}
                />
            </div>
        </div>
    )
}

export default function NaturalCapitalLayout({
    children,
}: {
    children: React.ReactNode
}) {
    return (
        <SearchProvider>
            <div className="min-h-screen">
                <NavigationContent />
                {children}
            </div>
        </SearchProvider>
    )
}
````

## File: src/app/natural-capital/metadata.ts
````typescript
import { Metadata } from 'next'

export const metadata: Metadata = {
    title: 'Natural Capital | ensurance: markets for what matters',
    description: 'Explore natural capital assets and their flows',
}
````

## File: src/app/natural-capital/page.tsx
````typescript
'use client'

import { Suspense } from 'react'
import NaturalCapitalGrid from '@/modules/natural-capital/NaturalCapitalGrid'
import { useSearch } from './SearchContext'

function NaturalCapitalContent() {
    const { searchQuery } = useSearch()
    
    return (
        <div className="container mx-auto px-4">
            <Suspense fallback={<div>Loading...</div>}>
                <NaturalCapitalGrid
                    variant="standard"
                    showHeader={false}
                    activeCategory="all"
                    urlPrefix="/natural-capital"
                    searchQuery={searchQuery}
                />
            </Suspense>
        </div>
    )
}

export default function NaturalCapitalPage() {
    return <NaturalCapitalContent />
}
````

## File: src/app/natural-capital/SearchContext.tsx
````typescript
'use client'

import React, { createContext, useContext, useState } from 'react'

interface SearchContextType {
    searchQuery: string
    setSearchQuery: (query: string) => void
}

const SearchContext = createContext<SearchContextType | undefined>(undefined)

export function SearchProvider({ children }: { children: React.ReactNode }) {
    const [searchQuery, setSearchQuery] = useState('')

    return (
        <SearchContext.Provider value={{ searchQuery, setSearchQuery }}>
            {children}
        </SearchContext.Provider>
    )
}

export function useSearch() {
    const context = useContext(SearchContext)
    if (context === undefined) {
        throw new Error('useSearch must be used within a SearchProvider')
    }
    return context
}
````

## File: src/app/operator/portfolio/page.tsx
````typescript
'use client'

import { useState } from 'react'
import { usePrivy } from '@privy-io/react-auth'
import { PageHeader } from '@/components/layout/PageHeader'
import Portfolio from '@/modules/account-modules/portfolio'

export default function OperatorPortfolioPage() {
  const { authenticated, ready, user } = usePrivy()
  const [searchQuery, setSearchQuery] = useState('')

  // Show loading state while Privy is initializing
  if (!ready) {
    return (
      <div className="min-h-screen bg-black text-white">
        <PageHeader 
          title="operator portfolio"
          showSearch={true}
          searchQuery={searchQuery}
          setSearchQuery={setSearchQuery}
          searchPlaceholder="Search your portfolio..."
        />
        <div className="container mx-auto px-4">
          <div className="text-center py-8">
            <p className="text-gray-500">Loading...</p>
          </div>
        </div>
      </div>
    )
  }

  // Show connect prompt if not authenticated
  if (!authenticated || !user?.wallet?.address) {
    return (
      <div className="min-h-screen bg-black text-white">
        <PageHeader 
          title="operator portfolio"
          showSearch={true}
          searchQuery={searchQuery}
          setSearchQuery={setSearchQuery}
          searchPlaceholder="Search your portfolio..."
        />
        <div className="container mx-auto px-4">
          <div className="text-center py-16">
            <p className="text-gray-400 mb-4">Connect your wallet to view your portfolio</p>
            <p className="text-sm text-gray-500">Use the connect button in the header to get started</p>
          </div>
        </div>
      </div>
    )
  }

  return (
    <div className="min-h-screen bg-black text-white">
      <PageHeader 
        title="operator portfolio"
        showSearch={true}
        searchQuery={searchQuery}
        setSearchQuery={setSearchQuery}
        searchPlaceholder="Search your portfolio..."
      />
      <div className="container mx-auto px-4">
        <Portfolio
          address={user.wallet.address}
          context="operator"
          searchQuery={searchQuery}
        />
      </div>
    </div>
  )
}
````

## File: src/app/pools/page.tsx
````typescript
'use client'

import { useEffect, useState } from 'react'
import { PageHeader } from '@/components/layout/PageHeader'
import { Copy, ExternalLink } from 'lucide-react'

interface Pool {
  contract_address: string;
  name: string;
  pool_type: 'uniswap' | 'balancer' | 'ensure';
  tokens?: string[]; // Array of token symbols in the pool
  pair_token?: string;
  dex_type?: string;
}

// uniswap pools and balancer pools page

export default function PoolsPage() {
  const [pools, setPools] = useState<Pool[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [copiedAddress, setCopiedAddress] = useState<string | null>(null);
  const [searchQuery, setSearchQuery] = useState('');

  // Handle copy address
  const handleCopy = async (address: string) => {
    await navigator.clipboard.writeText(address);
    setCopiedAddress(address);
    setTimeout(() => setCopiedAddress(null), 2000);
  };

  useEffect(() => {
    const fetchPools = async () => {
      try {
        const response = await fetch('/api/pools');
        if (!response.ok) throw new Error('Failed to fetch pools');
        const data = await response.json();
        setPools(data);
      } catch (err) {
        console.error('Error fetching pools:', err);
        setError(err instanceof Error ? err.message : 'Failed to load pools');
      } finally {
        setLoading(false);
      }
    };

    fetchPools();
  }, []);

  // Filter pools based on search
  const filteredPools = pools.filter(pool => {
    const searchTerm = searchQuery.toLowerCase();
    const dexType = pool.pool_type === 'ensure' 
      ? pool.dex_type?.replace('_', ' ')
      : pool.pool_type === 'uniswap'
      ? 'uniswap v3'
      : pool.pool_type;

    return pool.name.toLowerCase().includes(searchTerm) ||
      (pool.tokens && pool.tokens.some(token => 
        token.toLowerCase().includes(searchTerm)
      )) ||
      (dexType?.toLowerCase() || '').includes(searchTerm);
  });

  return (
    <div className="min-h-screen flex flex-col">
      <div className="container mx-auto px-4 py-8 flex-1 max-w-7xl">
        <div className="space-y-8">
          <PageHeader
            title="ensurance pools"
            description="liquidity for what mattters"
            showSearch={true}
            searchPlaceholder="Search pools..."
            searchQuery={searchQuery}
            setSearchQuery={setSearchQuery}
          />

          {loading ? (
            <div className="animate-pulse">
              <div className="h-12 bg-gray-700 rounded-lg" />
            </div>
          ) : error ? (
            <div className="text-red-500">{error}</div>
          ) : (
            <div className="overflow-x-auto">
              <table className="w-full text-base">
                <thead>
                  <tr className="text-gray-400 border-b border-gray-800">
                    <th className="text-left py-3 px-4 w-[23%]">name</th>
                    <th className="text-left py-3 px-4 w-[10%]">type</th>
                    <th className="text-center py-3 px-4 w-[12%]">add liquidity</th>
                    <th className="text-left py-3 px-4 w-[15%]">contract address</th>
                    <th className="text-left py-3 px-4 w-[40%]">tokens</th>
                  </tr>
                </thead>
                <tbody>
                  {filteredPools.map((pool) => {
                    const shortAddress = `${pool.contract_address.slice(0, 6)}...${pool.contract_address.slice(-4)}`;
                    const protocolUrl = pool.pool_type === 'balancer' 
                      ? `https://balancer.fi/pools/base/v3/${pool.contract_address}`
                      : `https://app.uniswap.org/explore/pools/base/${pool.contract_address}`;
                    
                    return (
                      <tr 
                        key={pool.contract_address} 
                        className="border-b border-gray-800 hover:bg-gray-800/50 transition-colors"
                      >
                        <td className="py-3 px-4 text-gray-200">
                          {pool.pool_type === 'uniswap' 
                            ? pool.name.replace('/ETH', '')
                            : pool.name
                          }
                        </td>
                        <td className="py-3 px-4">
                          <span className="text-xs px-2 py-1 bg-gray-800 rounded-full text-gray-400">
                            {pool.pool_type === 'ensure' 
                              ? pool.dex_type?.replace('_', ' ') 
                              : pool.pool_type === 'uniswap'
                              ? 'uniswap v3'
                              : pool.pool_type
                            }
                          </span>
                        </td>
                        <td className="py-3 px-4 text-center">
                          <a
                            href={pool.pool_type === 'balancer' 
                              ? `https://balancer.fi/pools/base/v3/${pool.contract_address}`
                              : pool.pool_type === 'ensure' && pool.dex_type === 'aerodrome'
                              ? `https://aerodrome.finance/liquidity?query=0x0c66d591d1ff5944a44aebb65c33f6b6e82a124f`
                              : `https://app.uniswap.org/explore/pools/base/${pool.contract_address}`
                            }
                            target="_blank"
                            rel="noopener noreferrer"
                            className="inline-flex items-center gap-1 text-blue-400 hover:text-blue-300 transition-colors"
                          >
                            add liquidity
                            <ExternalLink size={14} />
                          </a>
                        </td>
                        <td className="py-3 px-4">
                          <div className="flex items-center gap-2">
                            <span className="font-mono text-gray-400">
                              {shortAddress}
                            </span>
                            <button
                              onClick={() => handleCopy(pool.contract_address)}
                              className="p-1 hover:bg-gray-700 rounded transition-colors"
                              title="Copy address"
                            >
                              <Copy 
                                size={14} 
                                className={copiedAddress === pool.contract_address ? 'text-green-400' : 'text-gray-400'}
                              />
                            </button>
                          </div>
                        </td>
                        <td className="py-3 px-4 text-gray-400">
                          {pool.pool_type === 'ensure' ? (
                            <div className="flex flex-wrap gap-x-2">
                              <span>ENSURE/{pool.pair_token}</span>
                            </div>
                          ) : pool.pool_type === 'uniswap' ? (
                            <div className="flex flex-wrap gap-x-2">
                              <span>{pool.name.replace('/ETH', '')}/ETH</span>
                            </div>
                          ) : (
                            pool.tokens && (
                              <div className="flex flex-wrap gap-x-2">
                                {pool.tokens.map((token, i) => (
                                  <span key={i} className="after:content-[','] last:after:content-none">
                                    {token}
                                  </span>
                                ))}
                              </div>
                            )
                          )}
                        </td>
                      </tr>
                    );
                  })}
                </tbody>
              </table>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}
````

## File: src/app/proceeds/[contract]/page.tsx
````typescript
'use client';

import { useEffect, useState, Suspense } from 'react';
import { SplitsClient } from '@0xsplits/splits-sdk';
import { base } from 'viem/chains';
import { Copy } from 'lucide-react';
import Portfolio from '@/modules/account-modules/portfolio';

interface ContractPageProps {
  params: {
    contract: string;
  }
}

interface SplitData {
  recipients: {
    recipient: {
      address: string;
    };
    percentAllocation: number;
  }[];
}

interface AddressInfo {
  name: string;
  type: string;
  description?: string;
}

interface ProceedsData {
  split: any | null;
  stream: any | null;
  swapper: any | null;
  team: any | null;
}

// Add loading component
function LoadingState() {
  return (
    <div className="container mx-auto p-8">
      <div className="animate-pulse">
        <div className="h-8 w-64 bg-gray-700 rounded mb-4" />
        <div className="h-4 w-96 bg-gray-700 rounded mb-8" />
        <div className="h-12 bg-gray-700 rounded-lg" />
      </div>
    </div>
  );
}

// Split the data fetching into a separate component
function ContractData({ contract }: { contract: string }) {
  const [splitData, setSplitData] = useState<SplitData | null>(null);
  const [proceedsData, setProceedsData] = useState<ProceedsData | null>(null);
  const [addressInfo, setAddressInfo] = useState<AddressInfo | null>(null);
  const [recipientNames, setRecipientNames] = useState<Record<string, AddressInfo>>({});
  const [error, setError] = useState<string | null>(null);
  const [copiedAddress, setCopiedAddress] = useState<string | null>(null);

  // Handle copy address
  const handleCopy = async (address: string) => {
    await navigator.clipboard.writeText(address);
    setCopiedAddress(address);
    setTimeout(() => setCopiedAddress(null), 2000);
  };

  useEffect(() => {
    const fetchData = async () => {
      try {
        // Fetch proceeds data and names in parallel
        const [proceedsResponse, namesResponse] = await Promise.all([
          fetch(`/api/proceeds?address=${contract}`, {
            next: { revalidate: 60 } // Cache for 1 minute
          }),
          fetch('/api/proceeds', {
            next: { revalidate: 60 } // Cache for 1 minute
          })
        ]);

        if (!proceedsResponse.ok) {
          throw new Error('Failed to fetch proceeds data');
        }

        if (!namesResponse.ok) {
          console.error('Failed to fetch names:', namesResponse.status);
        }

        const proceedsData = await proceedsResponse.json();
        setProceedsData(proceedsData);

        // Only fetch split data if this is a split
        if (proceedsData.split) {
          const client = new SplitsClient({
            chainId: base.id,
            includeEnsNames: false,
            apiConfig: {
              apiKey: process.env.NEXT_PUBLIC_SPLITS_API_KEY as string
            }
          }).dataClient;

          if (!client) {
            throw new Error('Failed to initialize Splits client');
          }

          const splitMetadata = await client.getSplitMetadata({
            chainId: base.id,
            splitAddress: contract
          });
          setSplitData(splitMetadata);
        }

        // Process names data
        const names = await namesResponse.json();
        // Set contract info
        const info = Object.entries(names).find(
          ([addr]) => addr.toLowerCase() === contract.toLowerCase()
        )?.[1] as AddressInfo;
        
        if (info) {
          setAddressInfo(info);
        }

        // Set recipient names
        const recipientInfo = Object.entries(names).reduce((acc, [addr, info]) => {
          acc[addr.toLowerCase()] = info as AddressInfo;
          return acc;
        }, {} as Record<string, AddressInfo>);
        setRecipientNames(recipientInfo);

      } catch (err) {
        console.error('Error fetching data:', err);
        setError(err instanceof Error ? err.message : 'Failed to load data');
      }
    };

    fetchData();
  }, [contract]);

  if (error) {
    return <div className="text-red-500">{error}</div>;
  }

  // If no data found for any type
  if (!proceedsData?.split && !proceedsData?.stream && !proceedsData?.swapper && !proceedsData?.team) {
    return (
      <div className="container mx-auto p-8">
        <div className="text-gray-300">
          No proceeds data found for address {contract} on chain {base.id}. Please confirm you have entered the correct address.
        </div>
      </div>
    );
  }

  return (
    <div className="container mx-auto p-8 space-y-6">
      {/* Contract Info */}
      <div className="space-y-4">
        <div className="space-y-2">
          <h1 className="text-2xl font-bold text-gray-100">
            {addressInfo?.name || 'Proceeds Contract'}
          </h1>
          {addressInfo?.description && (
            <p className="text-gray-300 text-lg">
              {addressInfo.description}
            </p>
          )}
        </div>
        
        <div className="inline-flex items-center gap-2 bg-gray-800/50 px-4 py-2 rounded-lg">
          <p className="text-gray-400 font-mono text-sm flex items-center gap-2">
            <span>{contract}</span>
            <button
              onClick={() => handleCopy(contract)}
              className="p-1 hover:bg-gray-700 rounded transition-colors"
              title="Copy address"
            >
              <Copy 
                size={14} 
                className={copiedAddress === contract ? 'text-green-400' : 'text-gray-400'}
              />
            </button>
          </p>
          {addressInfo?.type && (
            <span className="text-xs px-2 py-1 bg-gray-700/50 rounded-full text-gray-300">
              {addressInfo.type}
            </span>
          )}
        </div>
      </div>

      {/* Split Data */}
      {splitData && (
        <div className="space-y-6">
          <div className="mt-8">
            <h3 className="text-lg font-medium text-gray-200 mb-4">recipients</h3>
            <div className="overflow-x-auto">
              <table className="w-full text-sm">
                <thead>
                  <tr className="text-gray-400 border-b border-gray-800">
                    <th className="text-left py-3 px-4 w-[40%]">name/address</th>
                    <th className="text-right py-3 px-4 w-[20%]">allocation</th>
                    <th className="text-left py-3 px-4 w-[20%]">type</th>
                    <th className="text-right py-3 px-4 w-[20%]">actions</th>
                  </tr>
                </thead>
                <tbody>
                  {splitData.recipients.map((recipient, index) => {
                    const address = recipient.recipient.address;
                    const shortAddress = `${address.slice(0, 6)}...${address.slice(-4)}`;
                    const hue = (index * 137.508) % 360;
                    const recipientInfo = recipientNames[address.toLowerCase()];
                    const recipientType = recipientInfo?.type || 'account';

                    return (
                      <tr key={address} className="border-b border-gray-800/50">
                        <td className="py-3 px-4">
                          <div className="flex items-center gap-2">
                            <div 
                              className="w-3 h-3 rounded-full"
                              style={{ backgroundColor: `hsl(${hue}, 70%, 60%)` }}
                            />
                            <div className="flex flex-col">
                              {recipientInfo?.name ? (
                                <span className="text-gray-200">{recipientInfo.name}</span>
                              ) : (
                                <span className="text-gray-400 font-mono">{shortAddress}</span>
                              )}
                            </div>
                          </div>
                        </td>
                        <td className="text-right py-3 px-4 text-gray-300">
                          {recipient.percentAllocation}%
                        </td>
                        <td className="py-3 px-4">
                          <span className="text-xs px-2 py-1 bg-gray-800 rounded-full text-gray-400">
                            {recipientType}
                          </span>
                        </td>
                        <td className="text-right py-3 px-4">
                          <a
                            href={`https://app.splits.org/accounts/${address}/?chainId=8453`}
                            target="_blank"
                            rel="noopener noreferrer"
                            className="text-blue-400 hover:text-blue-300 transition-colors"
                          >
                            View on Splits
                          </a>
                        </td>
                      </tr>
                    );
                  })}
                </tbody>
              </table>
            </div>
          </div>
        </div>
      )}

      {/* Stream Data */}
      {proceedsData.stream && (
        <div className="space-y-6">
          <div className="mt-8">
            <h3 className="text-lg font-medium text-gray-200 mb-4">stream details</h3>
            <div className="bg-gray-800/50 rounded-lg p-4">
              <pre className="text-gray-300 text-sm overflow-x-auto">
                {JSON.stringify(proceedsData.stream, null, 2)}
              </pre>
            </div>
          </div>
        </div>
      )}

      {/* Swapper Data */}
      {proceedsData.swapper && (
        <div className="space-y-6">
          <div className="mt-8">
            <h3 className="text-lg font-medium text-gray-200 mb-4">swapper details</h3>
            <div className="bg-gray-800/50 rounded-lg p-4">
              <pre className="text-gray-300 text-sm overflow-x-auto">
                {JSON.stringify(proceedsData.swapper, null, 2)}
              </pre>
            </div>
          </div>
        </div>
      )}

      {/* Team Data */}
      {proceedsData.team && (
        <div className="mt-8">
          <Portfolio address={contract} />
        </div>
      )}
    </div>
  );
}

export default function ContractPage({ params }: ContractPageProps) {
  return (
    <Suspense fallback={<LoadingState />}>
      <ContractData contract={params.contract} />
    </Suspense>
  );
}
````

## File: src/app/proceeds/page.tsx
````typescript
'use client';

import { FlowViewer } from '@/modules/proceeds/components/viewer/ProceedsViewer';
import { SplitsWrapper } from '@/providers/splits-provider';

export default function ProceedsPage() {
  const defaultAddress = '0xa187F8CBdd36D63967c33f5BD4dD4B9ECA51270e';
  const chainId = 8453; // Base chain ID

  return (
    <SplitsWrapper>
      <div className="min-h-screen flex flex-col">
        <div className="flex-1">
          <FlowViewer 
            address={defaultAddress}
            chainId={chainId}
          />
        </div>
      </div>
    </SplitsWrapper>
  );
}
````

## File: src/app/specific/[contract]/[tokenId]/manage/page.tsx
````typescript
'use client'

import { useState, useEffect } from 'react'
import { useParams, useRouter } from 'next/navigation'
import { createPublicClient, http, createWalletClient, custom } from 'viem'
import { base } from 'viem/chains'
import { usePrivy, useWallets } from '@privy-io/react-auth'
import { toast } from 'react-toastify'
import { isAppAdmin } from '@/config/admin'
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { getTokenInfo } from '@/modules/specific/manage'
import { CONTRACTS, ABIS, SUPPORTED_TOKENS, type SupportedERC20Token, formatUsdcAmount, parseUsdcAmount, validateUsdcAmount, formatTimestamp, formatDateForInput, dateToUint64, formatSalesConfigForContract, formatSaleEnd } from '@/modules/specific/config'
import { encodeSalesConfig } from '@/modules/specific/callSale'
import { encodeInitialSalesConfig, getInitialSalesConfig } from '@/modules/specific/callSaleInitial'
import Image from 'next/image'
import { PageHeader } from '@/components/layout/PageHeader'
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import type { TokenData, SalesConfig } from '@/modules/specific/types'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"

// Initialize public client
const publicClient = createPublicClient({
  chain: base,
  transport: http()
})

// Helper to convert IPFS URLs if needed
const convertIpfsUrl = (url: string) => {
  if (url?.startsWith('ipfs://')) {
    return url.replace('ipfs://', 'https://magic.decentralized-content.com/ipfs/')
  }
  return url
}

// Helper to format addresses
const formatAddress = (address: string) => {
  if (!address) return ''
  return `${address.slice(0, 6)}...${address.slice(-4)}`
}

// Helper to format supply
const formatSupply = (totalMinted: string, maxSupply: string) => {
  // Check for effectively infinite supply (2^64 - 1, 2^64, or 0)
  const isEffectivelyInfinite = 
    maxSupply === '18446744073709551615' || 
    maxSupply === '18446744073709551616' || 
    maxSupply === '0'
  return `${totalMinted} / ${isEffectivelyInfinite ? '∞' : maxSupply}`
}

// Helper to validate address
const isValidAddress = (address: string) => {
  return /^0x[a-fA-F0-9]{40}$/.test(address)
}

// Helper to format date for display
const formatDateForDisplay = (timestamp: string | undefined) => {
  if (!timestamp || timestamp === '0') return ''
  const date = new Date(Number(timestamp) * 1000)
  return date.toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  })
}

export default function ManagePage() {
  const params = useParams()
  const { user, ready, authenticated } = usePrivy()
  const { wallets } = useWallets()
  const activeWallet = wallets[0]
  const address = user?.wallet?.address as `0x${string}` | undefined
  const router = useRouter()
  const [isLoading, setIsLoading] = useState(false)
  const [tokenInfo, setTokenInfo] = useState<{ token: TokenData; salesConfig: SalesConfig } | null>(null)
  const [imageUrl, setImageUrl] = useState<string>('/assets/no-image-found.png')
  const [fundsRecipient, setFundsRecipient] = useState('')
  const [price, setPrice] = useState('')
  const [saleStart, setSaleStart] = useState('')
  const [saleEnd, setSaleEnd] = useState('')
  const [isUpdating, setIsUpdating] = useState(false)
  const [description, setDescription] = useState<string>('')
  const [selectedCurrency, setSelectedCurrency] = useState<`0x${string}`>(CONTRACTS.usdc)
  const [recipientAddress, setRecipientAddress] = useState('')
  const [mintQuantity, setMintQuantity] = useState('')

  // Fetch token info on load
  useEffect(() => {
    if (!params.contract || !params.tokenId) return

    const fetchTokenInfo = async () => {
      try {
        const info = await getTokenInfo(
          params.contract as `0x${string}`,
          params.tokenId as string
        )
        setTokenInfo(info)

        // Set form values from current token info
        if (info.salesConfig.fundsRecipient) setFundsRecipient(info.salesConfig.fundsRecipient)
        if (info.salesConfig.pricePerToken) setPrice(formatUsdcAmount(info.salesConfig.pricePerToken.toString()))
        if (info.salesConfig.saleStart) setSaleStart(formatDateForInput(info.salesConfig.saleStart.toString()))
        if (info.salesConfig.saleEnd && info.salesConfig.saleEnd !== BigInt(0)) setSaleEnd(formatDateForInput(info.salesConfig.saleEnd.toString()))
        if (info.salesConfig.currency) setSelectedCurrency(info.salesConfig.currency)

        // Fetch metadata to get image URL and description
        const metadataResponse = await fetch(`/api/metadata/${params.contract}/${params.tokenId}`)
        if (metadataResponse.ok) {
          const metadata = await metadataResponse.json()
          if (metadata.image) {
            setImageUrl(convertIpfsUrl(metadata.image))
          }
          if (metadata.description) {
            setDescription(metadata.description)
          }
        }
      } catch (error) {
        toast.error('Failed to fetch token information')
      }
    }

    fetchTokenInfo()
  }, [params.contract, params.tokenId])

  // Redirect non-admins
  useEffect(() => {
    if (ready && authenticated && address && !isAppAdmin(address)) {
      router.push('/specific')
    }
  }, [ready, authenticated, address, router])

  // Helper to get currency symbol
  const getCurrencySymbol = (address: `0x${string}`) => {
    const token = Object.values(SUPPORTED_TOKENS).find((t: SupportedERC20Token) => 
      t.address.toLowerCase() === address.toLowerCase()
    )
    return token?.symbol || 'Unknown'
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    if (!activeWallet) {
      toast.error('Please connect your wallet')
      return
    }

    // Validate funds recipient if provided
    if (fundsRecipient && !isValidAddress(fundsRecipient)) {
      toast.error('Invalid funds recipient address')
      return
    }

    setIsUpdating(true)
    try {
      const provider = await activeWallet.getEthereumProvider()
      const walletClient = createWalletClient({
        account: activeWallet.address as `0x${string}`,
        chain: base,
        transport: custom(provider)
      })

      // Create updated config using original contract values as base
      const config: SalesConfig = {
        saleStart: saleStart ? dateToUint64(saleStart) : tokenInfo?.salesConfig.saleStart || BigInt(0),
        saleEnd: saleEnd ? dateToUint64(saleEnd) : tokenInfo?.salesConfig.saleEnd || BigInt(0),
        maxTokensPerAddress: tokenInfo?.salesConfig.maxTokensPerAddress || BigInt(0),
        pricePerToken: price ? parseUsdcAmount(price) : tokenInfo?.salesConfig.pricePerToken || BigInt(0),
        fundsRecipient: fundsRecipient ? fundsRecipient as `0x${string}` : tokenInfo?.salesConfig.fundsRecipient || CONTRACTS.erc20Minter,
        currency: selectedCurrency || tokenInfo?.salesConfig.currency || CONTRACTS.usdc
      }

      // Use encodeSalesConfig instead of direct encoding
      const salesConfigBytes = encodeSalesConfig(config, params.tokenId as string)

      // Add detailed logging
      console.log('=== Update Sales Config Details ===')
      console.log('Token ID:', params.tokenId)
      console.log('Sales Config Bytes:', salesConfigBytes)
      console.log('Contract Address:', CONTRACTS.specific)
      console.log('Minter Address:', CONTRACTS.erc20Minter)
      console.log('Raw Config:', config)
      console.log('================================')

      // Call the specific contract's callSale function
      const tx = await walletClient.writeContract({
        address: CONTRACTS.specific,
        abi: ABIS.specific,
        functionName: 'callSale',
        args: [BigInt(params.tokenId as string), CONTRACTS.erc20Minter, salesConfigBytes]
      })

      // Wait for transaction
      await publicClient.waitForTransactionReceipt({ hash: tx })

      toast.success('Token updated successfully')
    } catch (error) {
      console.error('Error updating token:', error)
      toast.error(error instanceof Error ? error.message : 'Failed to update token')
    } finally {
      setIsUpdating(false)
    }
  }

  // Add this helper function after the other helper functions
  const isSalesConfigUndefined = (config: SalesConfig | undefined) => {
    if (!config) return true
    return (
      config.saleStart === BigInt(0) &&
      config.saleEnd === BigInt(0) &&
      config.maxTokensPerAddress === BigInt(0) &&
      config.pricePerToken === BigInt(0)
    )
  }

  // Add this new handler function before the return statement
  const handleInitialConfig = async () => {
    if (!activeWallet) {
      toast.error('Please connect your wallet')
      return
    }

    setIsUpdating(true)
    try {
      const provider = await activeWallet.getEthereumProvider()
      const walletClient = createWalletClient({
        account: activeWallet.address as `0x${string}`,
        chain: base,
        transport: custom(provider)
      })

      const salesConfigBytes = encodeInitialSalesConfig(params.tokenId as string, activeWallet.address as `0x${string}`)
      
      // Add detailed logging
      console.log('=== Initial Sales Config Details ===')
      console.log('Token ID:', params.tokenId)
      console.log('Sales Config Bytes:', salesConfigBytes)
      console.log('Contract Address:', CONTRACTS.specific)
      console.log('Minter Address:', CONTRACTS.erc20Minter)
      console.log('Wallet Address:', activeWallet.address)
      console.log('Raw Config:', getInitialSalesConfig(params.tokenId as string, activeWallet.address as `0x${string}`))
      console.log('================================')

      const tx = await walletClient.writeContract({
        address: CONTRACTS.specific,
        abi: ABIS.specific,
        functionName: 'callSale',
        args: [BigInt(params.tokenId as string), CONTRACTS.erc20Minter, salesConfigBytes]
      })

      const receipt = await publicClient.waitForTransactionReceipt({ hash: tx })
      
      if (receipt.status === 'success') {
        toast.success('Initial sales configuration set: Free tokens with no limits')
      } else {
        toast.error('Transaction failed: Configuration not updated')
        return
      }
      
      // Refresh token info
      const info = await getTokenInfo(
        params.contract as `0x${string}`,
        params.tokenId as string
      )
      setTokenInfo(info)
    } catch (error) {
      console.error('Error setting initial config:', error)
      if (error instanceof Error) {
        if (error.message.includes('user rejected')) {
          toast.error('Transaction cancelled by user')
        } else if (error.message.includes('insufficient funds')) {
          toast.error('Insufficient funds for gas')
        } else {
          toast.error(`Transaction failed: ${error.message}`)
        }
      } else {
        toast.error('Failed to set initial configuration')
      }
    } finally {
      setIsUpdating(false)
    }
  }

  // Show loading or unauthorized state
  if (!ready || !authenticated) {
    return (
      <div className="min-h-screen flex flex-col">
        <PageHeader 
          title="manage specific certificate"
          showSearch={false}
          showBackArrow={true}
          backLink={`/specific/${params.contract}/${params.tokenId}`}
        />
        <div className="container mx-auto px-4 flex-1">
          <Card className="max-w-2xl mx-auto mt-8">
            <CardContent className="p-6">
              <p className="text-muted-foreground">Please connect your wallet to continue.</p>
            </CardContent>
          </Card>
        </div>
      </div>
    )
  }

  if (address && !isAppAdmin(address)) {
    return null // Will redirect
  }

  return (
    <div className="min-h-screen flex flex-col">
      <PageHeader 
        title="manage specific certificate"
        showSearch={false}
        showBackArrow={true}
        backLink={`/specific/${params.contract}/${params.tokenId}`}
      />

      <div className="container mx-auto px-4 flex-1 py-8">
        <div className="max-w-7xl mx-auto grid grid-cols-1 md:grid-cols-2 gap-8">
          {/* Left Column: Current Token Info */}
          <Card className="overflow-hidden bg-primary-dark/30 border-gray-800">
            <CardHeader>
              <CardTitle>Current Token Info</CardTitle>
            </CardHeader>
            <CardContent className="p-6">
              <div className="flex items-start gap-6">
                <div className="relative w-32 h-32 rounded-xl overflow-hidden bg-black/20">
                  <Image
                    src={imageUrl}
                    alt="Token thumbnail"
                    fill
                    className="object-cover"
                  />
                </div>
                <div className="flex-1 space-y-4">
                  <div>
                    <h2 className="text-xl font-semibold mb-1">{tokenInfo?.token.name || `Token #${params.tokenId}`}</h2>
                    {description && (
                      <p className="text-sm text-muted-foreground mt-2">{description}</p>
                    )}
                    {!tokenInfo?.token.name && (
                      <p className="text-sm text-muted-foreground mt-2">
                        Metadata not found in database. Please update metadata using the Neon/Blob.
                      </p>
                    )}
                  </div>
                  
                  <div className="grid grid-cols-2 gap-x-8 gap-y-4">
                    <div>
                      <p className="text-sm text-muted-foreground mb-1">Current Price</p>
                      <p className="text-sm">
                        {tokenInfo?.salesConfig.pricePerToken ? 
                          `$${formatUsdcAmount(tokenInfo.salesConfig.pricePerToken.toString())} USDC` : 
                          'Not set'}
                      </p>
                    </div>
                    <div>
                      <p className="text-sm text-muted-foreground mb-1">Supply</p>
                      <p className="text-sm">
                        {tokenInfo?.token ? 
                          formatSupply(tokenInfo.token.totalMinted.toString(), tokenInfo.token.maxSupply.toString()) : 
                          'Not set'}
                      </p>
                    </div>
                    <div>
                      <p className="text-sm text-muted-foreground mb-1">Sale Start</p>
                      <p className="text-sm">
                        {tokenInfo?.salesConfig.saleStart ? 
                          formatTimestamp(tokenInfo.salesConfig.saleStart.toString()) : 
                          'Not set'}
                      </p>
                    </div>
                    <div>
                      <p className="text-sm text-muted-foreground mb-1">Sale End</p>
                      <p className="text-sm">{formatSaleEnd(tokenInfo?.salesConfig.saleEnd)}</p>
                    </div>
                    <div>
                      <p className="text-sm text-muted-foreground mb-1">Funds Recipient</p>
                      <p className="font-mono text-sm" title={tokenInfo?.salesConfig.fundsRecipient || ''}>
                        {tokenInfo?.salesConfig.fundsRecipient ? 
                          formatAddress(tokenInfo.salesConfig.fundsRecipient) : 
                          'Not set'}
                      </p>
                    </div>
                  </div>

                  <div className="mt-6 p-4 bg-primary-dark/50 rounded-lg border border-gray-800">
                    <p className="text-sm text-muted-foreground">
                      To update token name, description, or image, please use the Neon/Blob
                    </p>
                  </div>
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Right Column: Update Form */}
          <Card className="bg-primary-dark/30 border-gray-800">
            <CardHeader>
              <CardTitle>Update Token</CardTitle>
            </CardHeader>
            <CardContent>
              {tokenInfo && isSalesConfigUndefined(tokenInfo.salesConfig) ? (
                <div className="space-y-4">
                  <p className="text-sm text-muted-foreground">
                    This token has no sales configuration set. Click below to set the initial configuration.
                  </p>
                  <Button 
                    onClick={handleInitialConfig}
                    className="w-full"
                    disabled={isUpdating}
                  >
                    {isUpdating ? 'Setting Initial Config...' : 'Set Initial Sales Config'}
                  </Button>
                </div>
              ) : (
                <form onSubmit={handleSubmit} className="space-y-6">
                  <div className="space-y-4">
                    <div>
                      <label htmlFor="saleStart" className="block text-sm font-medium mb-1">Sale Start</label>
                      <input
                        id="saleStart"
                        type="date"
                        value={saleStart}
                        onChange={(e) => setSaleStart(e.target.value)}
                        className="mt-1 w-full rounded-md border border-gray-800 bg-black/20 px-3 py-2 text-sm text-white ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&::-webkit-calendar-picker-indicator]:invert"
                      />
                    </div>

                    <div>
                      <label htmlFor="saleEnd" className="block text-sm font-medium mb-1">Sale End</label>
                      <input
                        id="saleEnd"
                        type="date"
                        value={saleEnd}
                        onChange={(e) => setSaleEnd(e.target.value)}
                        className="mt-1 w-full rounded-md border border-gray-800 bg-black/20 px-3 py-2 text-sm text-white ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&::-webkit-calendar-picker-indicator]:invert"
                      />
                      <button
                        type="button"
                        onClick={() => setSaleEnd('18446744073709551615')}
                        className="text-xs text-blue-400 hover:text-blue-300 mt-1"
                      >
                        Set to infinite
                      </button>
                    </div>

                    <div>
                      <label htmlFor="price" className="block text-sm font-medium mb-1">Price (USDC)</label>
                      <div className="relative mt-1">
                        <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                          <span className="text-gray-400">$</span>
                        </div>
                        <input
                          id="price"
                          type="text"
                          value={price}
                          onChange={(e) => {
                            const value = e.target.value.replace(/,/g, '')
                            const error = validateUsdcAmount(value)
                            if (!error) {
                              setPrice(value) // Allow any valid input while typing
                            }
                          }}
                          onBlur={(e) => {
                            // Format the price when user is done typing
                            const value = e.target.value.replace(/,/g, '')
                            const amountFloat = parseFloat(value)
                            if (!isNaN(amountFloat)) {
                              setPrice(amountFloat.toFixed(2))
                            }
                          }}
                          className="w-full rounded-md border border-gray-800 bg-black/20 pl-7 px-3 py-2 text-sm text-white ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50"
                        />
                      </div>
                    </div>

                    <div>
                      <label htmlFor="fundsRecipient" className="block text-sm font-medium mb-1">Funds Recipient</label>
                      <input
                        id="fundsRecipient"
                        value={fundsRecipient}
                        onChange={(e) => setFundsRecipient(e.target.value)}
                        className="mt-1 w-full rounded-md border border-gray-800 bg-black/20 px-3 py-2 text-sm text-white font-mono ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50"
                      />
                    </div>

                    <div>
                      <label className="block text-sm font-medium mb-1">Max Tokens Per Address</label>
                      <div className="mt-1 px-3 py-2 text-sm text-muted-foreground bg-black/20 rounded-md border border-gray-800">
                        {tokenInfo?.salesConfig.maxTokensPerAddress.toString() === '0' ? 'No limit' : tokenInfo?.salesConfig.maxTokensPerAddress.toString()}
                      </div>
                    </div>

                    <div>
                      <label className="block text-sm font-medium mb-1">Currency</label>
                      <Select
                        value={selectedCurrency}
                        onValueChange={(value) => setSelectedCurrency(value as `0x${string}`)}
                      >
                        <SelectTrigger className="mt-1 w-full bg-black/20 border-gray-800">
                          <SelectValue placeholder="Select currency" />
                        </SelectTrigger>
                        <SelectContent className="bg-gray-900 border-gray-800">
                          {Object.entries(SUPPORTED_TOKENS).map(([symbol, token]) => (
                            <SelectItem 
                              key={token.address} 
                              value={token.address}
                              className="hover:bg-gray-800"
                            >
                              {symbol}
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                    </div>
                  </div>

                  <Button 
                    type="submit" 
                    className="w-full"
                    disabled={isUpdating}
                  >
                    {isUpdating ? 'Updating...' : 'Update Token'}
                  </Button>
                </form>
              )}
            </CardContent>
          </Card>
        </div>

        {/* Admin Mint Section */}
        <Card className="max-w-7xl mx-auto mt-8 bg-primary-dark/30 border-gray-800">
          <CardHeader>
            <CardTitle>Admin Mint</CardTitle>
          </CardHeader>
          <CardContent>
            {tokenInfo && isSalesConfigUndefined(tokenInfo.salesConfig) ? (
              <div className="space-y-4">
                <p className="text-sm text-muted-foreground">
                  Sales configuration must be set before admin minting is available.
                </p>
                <Button 
                  onClick={handleInitialConfig}
                  className="w-full"
                  disabled={isUpdating}
                >
                  {isUpdating ? 'Setting Initial Config...' : 'Set Initial Sales Config'}
                </Button>
              </div>
            ) : (
              <form onSubmit={async (e: React.FormEvent) => {
                e.preventDefault()
                if (!activeWallet) {
                  toast.error('Please connect your wallet')
                  return
                }

                setIsUpdating(true)
                try {
                  const provider = await activeWallet.getEthereumProvider()
                  const walletClient = createWalletClient({
                    account: activeWallet.address as `0x${string}`,
                    chain: base,
                    transport: custom(provider)
                  })

                  const tx = await walletClient.writeContract({
                    address: CONTRACTS.specific,
                    abi: ABIS.specific,
                    functionName: 'adminMint',
                    args: [
                      recipientAddress as `0x${string}`,
                      BigInt(params.tokenId as string),
                      BigInt(mintQuantity),
                      '0x' // empty bytes data - standard for non-contract recipients
                    ]
                  })

                  await publicClient.waitForTransactionReceipt({ hash: tx })
                  toast.success('Successfully minted tokens')
                } catch (error) {
                  console.error('Error minting tokens:', error)
                  toast.error(error instanceof Error ? error.message : 'Failed to mint tokens')
                } finally {
                  setIsUpdating(false)
                }
              }} className="space-y-4">
                <div>
                  <label htmlFor="recipientAddress" className="block text-sm font-medium mb-1">Recipient Address</label>
                  <input
                    id="recipientAddress"
                    type="text"
                    value={recipientAddress}
                    onChange={(e) => setRecipientAddress(e.target.value)}
                    className="mt-1 w-full rounded-md border border-gray-800 bg-black/20 px-3 py-2 text-sm text-white font-mono ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50"
                    placeholder="0x..."
                  />
                </div>

                <div>
                  <label htmlFor="mintQuantity" className="block text-sm font-medium mb-1">Quantity</label>
                  <input
                    id="mintQuantity"
                    type="number"
                    min="1"
                    value={mintQuantity}
                    onChange={(e) => setMintQuantity(e.target.value)}
                    className="mt-1 w-full rounded-md border border-gray-800 bg-black/20 px-3 py-2 text-sm text-white ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50"
                  />
                </div>

                <Button 
                  type="submit" 
                  className="w-full"
                  disabled={isUpdating || !recipientAddress || !mintQuantity || !isValidAddress(recipientAddress)}
                >
                  {isUpdating ? 'Minting...' : 'Mint Tokens'}
                </Button>
              </form>
            )}
          </CardContent>
        </Card>
      </div>
    </div>
  )
}
````

## File: src/app/specific/[contract]/[tokenId]/page.tsx
````typescript
'use client'

import { useEffect, useState } from 'react'
import Image from 'next/image'
import { Card, CardContent } from '@/components/ui/card'
import { formatUnits } from 'viem'
import { getTokenInfo, type TokenDisplayInfo } from '@/modules/specific/collect'
import { cn } from '@/lib/utils'
import { PageHeader } from '@/components/layout/PageHeader'
import { MAX_SUPPLY_OPEN_EDITION } from '@/modules/specific/config'
import EnsureButtons from '@/modules/ensure/buttons/EnsureButtonsDetails'
import VerificationSection from '@/components/layout/verifications/VerificationSection'
import ReactMarkdown from 'react-markdown'
import { ChevronDown, ChevronUp } from 'lucide-react'
import { Proceeds } from '@/modules/proceeds/components/Proceeds'
import { TokenPriceDisplay } from '@/components/layout/TokenPriceDisplay'

const FALLBACK_IMAGE = '/assets/no-image-found.png'

// Convert IPFS URL to use a gateway
const convertIpfsUrl = (url: string) => {
  if (url?.startsWith('ipfs://')) {
    return url.replace('ipfs://', 'https://magic.decentralized-content.com/ipfs/')
  }
  return url
}

// Status dot component
const StatusDot = ({ active }: { active: boolean }) => {
  const statusDotClasses = "w-2 h-2 rounded-full relative after:content-[''] after:absolute after:inset-0 after:rounded-full after:animate-pulse"
  
  return (
    <span className={cn(
      statusDotClasses,
      active 
        ? "bg-green-500 after:bg-green-500/50" 
        : "bg-red-500 after:bg-red-500/50"
    )} />
  )
}

export default function SpecificTokenPage({
  params
}: {
  params: { contract: string; tokenId: string }
}) {
  const [tokenInfo, setTokenInfo] = useState<TokenDisplayInfo | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string>()
  const [metadata, setMetadata] = useState<{ 
    image?: string;
    name?: string;
    description?: string;
  } | null>(null)
  const [imageUrl, setImageUrl] = useState<string>(FALLBACK_IMAGE)
  const [isDescriptionExpanded, setIsDescriptionExpanded] = useState(false)
  const [priceData, setPriceData] = useState<{
    averagePrice: number | null;
    averagePriceUsd: number | null;
    floorPrice: number | null;
    floorPriceUsd: number | null;
  }>({
    averagePrice: null,
    averagePriceUsd: null,
    floorPrice: null,
    floorPriceUsd: null
  })

  useEffect(() => {
    const fetchTokenInfo = async () => {
      try {
        setLoading(true)
        const info = await getTokenInfo(params.contract as `0x${string}`, params.tokenId)
        console.log('Zora SDK returned:', info)
        setTokenInfo(info)

        // Fetch metadata if we have a tokenURI
        if (info?.tokenURI) {
          try {
            let metadataData
            if (info.tokenURI.startsWith('http')) {
              // Handle HTTP URLs (like our API metadata route)
              const response = await fetch(info.tokenURI + `?t=${Date.now()}`)
              if (!response.ok) throw new Error('Failed to fetch metadata')
              metadataData = await response.json()
            } else {
              // Handle IPFS URLs
              const uri = convertIpfsUrl(info.tokenURI)
              const response = await fetch(uri + `?t=${Date.now()}`)
              if (!response.ok) throw new Error('Failed to fetch metadata')
              metadataData = await response.json()
            }
            
            console.log('Metadata response:', metadataData)
            setMetadata(metadataData)
            
            // Get image URL from metadata
            if (metadataData?.image) {
              const imageUrl = metadataData.image.startsWith('ipfs://')
                ? convertIpfsUrl(metadataData.image) + `?t=${Date.now()}`
                : metadataData.image + `?t=${Date.now()}`
              console.log('Setting image URL from metadata:', imageUrl)
              setImageUrl(imageUrl)
            } else {
              console.warn('No image found in metadata')
              setImageUrl(FALLBACK_IMAGE)
            }
          } catch (err) {
            console.warn('Failed to fetch metadata:', err)
            setImageUrl(FALLBACK_IMAGE)
          }
        } else {
          console.warn('No tokenURI found')
          setImageUrl(FALLBACK_IMAGE)
        }
      } catch (err) {
        console.error('Error loading data:', err)
        setError(err instanceof Error ? err.message : 'Failed to load data')
      } finally {
        setLoading(false)
      }
    }

    fetchTokenInfo()
  }, [params.contract, params.tokenId])

  useEffect(() => {
    const fetchPriceData = async () => {
      try {
        // Get floor price
        const floorResponse = await fetch(`/api/moralis/price-floor?address=${params.contract}`);
        const floorData = floorResponse.ok ? await floorResponse.json() : null;
        
        // Get sales data
        const salesResponse = await fetch(`/api/moralis/contract-sales?address=${params.contract}`);
        const salesData = salesResponse.ok ? await salesResponse.json() : null;
        
        // Get ETH price
        const ethPriceResponse = await fetch('/api/eth-price');
        const ethPriceData = ethPriceResponse.ok ? await ethPriceResponse.json() : null;
        const ethPrice = ethPriceData?.price || 0;

        // Process floor price
        const floorPrice = floorData?.floor_price ? parseFloat(floorData.floor_price) : null;
        const floorPriceUsd = floorPrice ? floorPrice * ethPrice : null;

        // Process sales data
        const averagePrice = salesData?.average_sale?.price_formatted ? parseFloat(salesData.average_sale.price_formatted) : null;
        const averagePriceUsd = averagePrice ? averagePrice * ethPrice : null;

        setPriceData({
          averagePrice,
          averagePriceUsd,
          floorPrice,
          floorPriceUsd
        });
      } catch (err) {
        console.error('Error fetching price data:', err);
      }
    };

    fetchPriceData();
  }, [params.contract]);

  const renderDescription = (description: string) => {
    if (!description) return null;
    
    const maxLength = 150;
    const shouldTruncate = description.length > maxLength;
    
    if (!shouldTruncate) {
      return <ReactMarkdown>{description}</ReactMarkdown>;
    }

    const displayText = isDescriptionExpanded 
      ? description 
      : `${description.slice(0, maxLength)}...`;

    return (
      <div className="space-y-2">
        <ReactMarkdown>{displayText}</ReactMarkdown>
        <button
          onClick={() => setIsDescriptionExpanded(!isDescriptionExpanded)}
          className="text-sm text-primary hover:text-primary/80 flex items-center gap-1"
        >
          {isDescriptionExpanded ? (
            <>
              show less <ChevronUp className="w-4 h-4" />
            </>
          ) : (
            <>
              show more <ChevronDown className="w-4 h-4" />
            </>
          )}
        </button>
      </div>
    );
  };

  if (loading) {
    return (
      <div className="min-h-screen flex flex-col">
        <PageHeader 
          title="specific ensurance"
          showSearch={false}
          showBackArrow={true}
          backLink="/specific"
        />
        <div className="container mx-auto px-4 flex-1 pb-12">
          <div className="animate-pulse space-y-4">
            <div className="h-64 bg-gray-800 rounded-lg mb-4"></div>
            <div className="h-8 bg-gray-800 rounded w-1/2 mb-2"></div>
            <div className="h-4 bg-gray-800 rounded w-3/4"></div>
          </div>
        </div>
      </div>
    )
  }

  if (error) {
    return (
      <div className="min-h-screen flex flex-col">
        <PageHeader 
          title="specific ensurance"
          showSearch={false}
          showBackArrow={true}
          backLink="/specific"
        />
        <div className="container mx-auto px-4 flex-1 pb-12">
          <div className="bg-red-900/50 border border-red-700 rounded-lg p-4">
            <h2 className="text-red-400 font-medium">Error</h2>
            <p className="text-red-300">{error}</p>
          </div>
        </div>
      </div>
    )
  }

  if (!tokenInfo) {
    return (
      <div className="min-h-screen flex flex-col">
        <PageHeader 
          title="specific ensurance"
          showSearch={false}
          showBackArrow={true}
          backLink="/specific"
        />
        <div className="container mx-auto px-4 flex-1 pb-12">
          <div className="bg-yellow-900/50 border border-yellow-700 rounded-lg p-4">
            <h2 className="text-yellow-400 font-medium">Not Found</h2>
            <p className="text-yellow-300">Token not found</p>
          </div>
        </div>
      </div>
    )
  }

  return (
    <div className="min-h-screen flex flex-col">
      <PageHeader 
        title="specific ensurance"
        showSearch={false}
        showBackArrow={true}
        backLink="/specific"
      />
      
      <div className="container mx-auto px-4 flex-1 pb-12">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
          {/* Media Display */}
          <Card className="bg-primary-dark border-0">
            <CardContent className="p-4">
              <div className="relative w-full aspect-square rounded-lg overflow-hidden bg-black/20">
                <Image
                  src={imageUrl}
                  alt={metadata?.name || 'Token'}
                  fill
                  sizes="(max-width: 768px) 100vw, 50vw"
                  priority
                  className="object-cover"
                  unoptimized={true}
                  onError={(e: any) => {
                    console.warn('Image failed to load:', imageUrl)
                    e.target.src = FALLBACK_IMAGE
                  }}
                  loading="eager"
                  fetchPriority="high"
                />
              </div>
            </CardContent>
          </Card>

          {/* Details */}
          <div className="space-y-6">
            {/* Header */}
            <div>
              <h1 className="text-3xl font-bold text-white">
                {metadata?.name ? (
                  <>
                    {metadata.name.split('|')[0].trim()}
                    {metadata.name.includes('|') && (
                      <div className="text-lg text-gray-400 mt-1">
                        {metadata.name.split('|')[1].trim()}
                      </div>
                    )}
                  </>
                ) : 'Unnamed Token'}
              </h1>
              {metadata?.description && (
                <div className="prose dark:prose-invert max-w-none prose-strong:text-white">
                  <div className="text-base leading-relaxed text-gray-200">
                    {renderDescription(metadata.description)}
                  </div>
                </div>
              )}
            </div>
            
            {/* Token Info */}
            <Card className="bg-primary-dark/50 border-0">
              <CardContent className="p-6">
                {/* Top row: Price and Market Info */}
                <div className="flex flex-row gap-8 items-start mb-6">
                  {/* Left: Price Info */}
                  <div className="flex flex-col gap-2 flex-1">
                    <div className="flex flex-row items-center gap-x-2">
                      <span className="text-gray-400 w-12">price</span>
                      <span className="flex items-baseline font-medium text-white tabular-nums gap-x-1">
                        <span className="inline-block text-right" style={{ width: '1.2em' }}>$</span>
                        <span className="inline-block text-right" style={{ width: '4em' }}>
                          {tokenInfo.salesConfig?.pricePerToken 
                            ? `${Number(formatUnits(tokenInfo.salesConfig.pricePerToken, 6)).toLocaleString('en-US', {
                                minimumFractionDigits: 2,
                                maximumFractionDigits: 2,
                                useGrouping: false
                              })}`
                            : 'N/A'}
                        </span>
                        <span className="ml-1 text-xs text-gray-400 font-normal">ea</span>
                      </span>
                    </div>
                    <div className="flex flex-row items-center gap-x-2">
                      <span className="text-gray-400 w-12">market</span>
                      <TokenPriceDisplay
                        averagePrice={priceData.averagePrice}
                        averagePriceUsd={priceData.averagePriceUsd}
                        floorPrice={priceData.floorPrice}
                        floorPriceUsd={priceData.floorPriceUsd}
                        configuredPrice={tokenInfo.salesConfig?.pricePerToken 
                          ? parseFloat(formatUnits(tokenInfo.salesConfig.pricePerToken, 6))
                          : null}
                        className="font-medium text-white tabular-nums gap-x-1"
                        alignDollarSign
                        dollarWidth="1.2em"
                        numberWidth="4em"
                      />
                    </div>
                  </div>

                  {/* Right: Action Buttons */}
                  <div className="flex flex-row items-center justify-end flex-1">
                    <EnsureButtons
                      contractAddress={params.contract}
                      tokenId={params.tokenId}
                      tokenType="erc1155"
                      context="specific"
                      imageUrl={imageUrl}
                      tokenName={metadata?.name}
                      tokenSymbol={metadata?.name || 'Certificate'}
                      pricePerToken={tokenInfo.salesConfig?.pricePerToken}
                      primaryMintActive={true}
                    />
                  </div>
                </div>

                {/* Bottom row: Supply Info */}
                <div className="flex flex-row items-center gap-x-2">
                  <span className="text-gray-400 w-12">supply</span>
                  <span className="font-medium text-white tabular-nums text-right" style={{ minWidth: '6em', display: 'inline-block' }}>
                    {tokenInfo.totalMinted.toString()} / {tokenInfo.maxSupply >= MAX_SUPPLY_OPEN_EDITION - BigInt(1) ? '∞' : tokenInfo.maxSupply.toString()}
                  </span>
                </div>
              </CardContent>
            </Card>

            {/* Proceeds Section */}
            <Proceeds
              variant="specific"
              tokenId={params.tokenId}
              payout_recipient={tokenInfo.salesConfig?.fundsRecipient || ''}
            />
          </div>
        </div>
      </div>

      <VerificationSection 
        type="specific"
        name={metadata?.name || 'Unnamed Token'}
        contractAddress={params.contract}
        tokenId={params.tokenId}
      />
    </div>
  )
}
````

## File: src/app/specific/create/page.tsx
````typescript
'use client'

import { useState, useEffect } from 'react'
import { createWalletClient, custom, type Hash } from 'viem'
import { base } from 'viem/chains'
import { createToken, finalizeToken, type CreateTokenStatus } from '@/modules/specific/create'
import { CONTRACTS, MAX_SUPPLY_OPEN_EDITION } from '@/modules/specific/config'
import { toast } from 'react-toastify'
import { usePrivy, useWallets } from '@privy-io/react-auth'
import { useRouter } from 'next/navigation'
import { isAppAdmin } from '@/config/admin'
import Link from 'next/link'
import { createWalletClient as createWalletClientViem, http, createPublicClient } from 'viem'
import type { WalletClient } from 'viem'
import { PageHeader } from '@/components/layout/PageHeader'

// Initialize public client
const publicClient = createPublicClient({
  chain: base,
  transport: http()
})

export default function CreateSpecificPage() {
  const { user, ready, authenticated } = usePrivy()
  const address = user?.wallet?.address as `0x${string}` | undefined
  const router = useRouter()
  const [isLoading, setIsLoading] = useState(false)
  const [status, setStatus] = useState<CreateTokenStatus>()
  const { wallets } = useWallets()
  const activeWallet = wallets[0]

  // Redirect non-admins
  useEffect(() => {
    if (ready && authenticated && address && !isAppAdmin(address)) {
      router.push('/specific')
    }
  }, [ready, authenticated, address, router])

  // Form state
  const [name, setName] = useState('')
  const [description, setDescription] = useState('')
  const [mediaFile, setMediaFile] = useState<File>()
  const [previewUrl, setPreviewUrl] = useState<string>()

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    if (!activeWallet || !mediaFile || !name) {
      toast.error('Please fill in all required fields')
      return
    }

    try {
      setIsLoading(true)
      setStatus(undefined)

      // Get the provider from the wallet
      const provider = await activeWallet.getEthereumProvider()
      
      const walletClient = createWalletClientViem({
        account: activeWallet.address as `0x${string}`,
        chain: base,
        transport: custom(provider)
      })

      // Step 1: Create token on-chain
      const result = await createToken({
        metadata: {
          name,
          description,
          maxSupply: MAX_SUPPLY_OPEN_EDITION
        },
        mediaFile,
        creatorAccount: activeWallet.address as `0x${string}`,
        onStatus: (newStatus) => {
          setStatus(newStatus)
          
          if (newStatus.error) {
            toast.error(newStatus.error)
            return
          }

          // Show step progress
          switch (newStatus.step) {
            case 'creating-token':
              toast.info('Creating token on-chain...')
              break
            case 'uploading-media':
              toast.info('Uploading media files...')
              break
            case 'storing-metadata':
              toast.info('Storing metadata...')
              break
            case 'complete':
              toast.success('Token created successfully!')
              break
          }
        }
      })

      // Step 2: Submit setup transaction
      const { abi, functionName, args, address: contractAddress } = result.parameters
      const hash = await walletClient.writeContract({
        abi,
        functionName,
        args,
        address: contractAddress,
        account: activeWallet.address as `0x${string}`,
        chain: base
      }) as Hash
      
      setStatus(prev => prev ? {
        ...prev,
        txHash: hash
      } : prev)

      // Step 3: Wait for transaction confirmation
      await publicClient.waitForTransactionReceipt({ hash })

      // Step 4: Upload media and store metadata
      await finalizeToken({
        tokenId: result.tokenId,
        metadata: {
          name,
          description,
          maxSupply: MAX_SUPPLY_OPEN_EDITION
        },
        mediaFile,
        onStatus: (newStatus) => {
          setStatus(prev => ({
            ...prev,
            ...newStatus,
            txHash: hash
          }))
        }
      })

      // Step 5: Redirect to token page
      if (status?.redirectUrl) {
        router.push(status.redirectUrl)
      } else {
        router.push(`/specific/${CONTRACTS.specific}/${result.tokenId}/manage`)
      }

    } catch (error) {
      console.error('Error creating token:', error)
      toast.error(error instanceof Error ? error.message : 'Failed to create token')
    } finally {
      setIsLoading(false)
    }
  }

  const handleMediaChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0]
    if (!file) return

    // Validate file type
    if (!file.type.startsWith('image/')) {
      toast.error('Only image files are supported')
      return
    }

    // Create preview
    const url = URL.createObjectURL(file)
    setPreviewUrl(url)

    // Load image to check dimensions
    const img = new Image()
    img.onload = () => {
      if (img.width !== img.height) {
        toast.warning('Image should be square. It will be cropped to square.')
      }
      setMediaFile(file)
    }
    img.src = url
  }

  // Clean up preview URL
  useEffect(() => {
    return () => {
      if (previewUrl) {
        URL.revokeObjectURL(previewUrl)
      }
    }
  }, [previewUrl])

  // Status display component
  const StatusDisplay = () => {
    if (!status) return null

    return (
      <div className="mt-6 p-4 border rounded-lg bg-background/50">
        <h3 className="font-medium mb-2">Creation Status</h3>
        
        <div className="space-y-2">
          {status.tokenId && (
            <p className="text-sm">
              Token ID: {status.tokenId}
            </p>
          )}
          
          {status.txHash && (
            <p className="text-sm">
              Transaction: {' '}
              <Link 
                href={`https://explorer.zora.energy/tx/${status.txHash}`}
                target="_blank"
                className="text-primary hover:underline"
              >
                View on Explorer
              </Link>
            </p>
          )}

          {status.mediaUrl && (
            <p className="text-sm">
              Media: {' '}
              <Link 
                href={status.mediaUrl}
                target="_blank"
                className="text-primary hover:underline"
              >
                View File
              </Link>
            </p>
          )}

          <div className="flex gap-2 items-center mt-2">
            <div className="flex-1 h-2 bg-gray-200 rounded-full overflow-hidden">
              {/* Progress bar */}
              <div 
                className="h-full bg-primary transition-all duration-300"
                style={{
                  width: (() => {
                    switch (status.step) {
                      case 'creating-token': return '25%'
                      case 'uploading-media': return '50%'
                      case 'storing-metadata': return '75%'
                      case 'complete': return '100%'
                      default: return '0%'
                    }
                  })()
                }}
              />
            </div>
            <span className="text-sm text-gray-500">
              {status.step === 'creating-token' && 'Creating...'}
              {status.step === 'uploading-media' && 'Uploading...'}
              {status.step === 'storing-metadata' && 'Storing...'}
              {status.step === 'complete' && 'Complete'}
              {status.step === 'error' && 'Error'}
            </span>
          </div>
        </div>
      </div>
    )
  }

  // Show loading or unauthorized state
  if (!ready || !authenticated) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="container max-w-2xl">
          <div className="bg-background border rounded-lg p-6">
            <h1 className="text-2xl font-bold mb-6">create specific ensurance</h1>
            <p className="text-muted-foreground">Please connect your wallet to continue.</p>
          </div>
        </div>
      </div>
    )
  }

  if (address && !isAppAdmin(address)) {
    return null // Will redirect
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <PageHeader 
        title="create specific ensurance"
        showSearch={false}
      />

      <form onSubmit={handleSubmit} className="max-w-2xl mx-auto space-y-6">
        {/* Basic Info */}
        <div className="space-y-4">
          <div>
            <label className="block text-sm font-medium mb-1 text-white">Name *</label>
            <input
              type="text"
              value={name}
              onChange={(e) => setName(e.target.value)}
              className="w-full px-3 py-2 border rounded-lg bg-gray-900 text-white border-gray-700"
              required
            />
          </div>

          <div>
            <label className="block text-sm font-medium mb-1 text-white">Description</label>
            <textarea
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              className="w-full px-3 py-2 border rounded-lg bg-gray-900 text-white border-gray-700"
              rows={4}
            />
          </div>
        </div>

        {/* Media Upload */}
        <div>
          <label className="block text-sm font-medium mb-1 text-white">Media (PNG) *</label>
          <label className="mt-1 flex justify-center px-6 pt-5 pb-6 border-2 border-dashed rounded-lg bg-gray-900 border-gray-700 cursor-pointer hover:border-primary/50 transition-colors">
            <div className="space-y-1 text-center">
              {previewUrl ? (
                <img src={previewUrl} alt="Preview" className="mx-auto h-32 w-32 object-cover rounded-lg" />
              ) : (
                <svg className="mx-auto h-12 w-12 text-gray-400" stroke="currentColor" fill="none" viewBox="0 0 48 48">
                  <path d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8m-12 4h.02" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                </svg>
              )}
              <div className="flex text-sm text-gray-300">
                <span className="font-medium text-primary hover:text-primary/80">
                  Upload a file
                </span>
                <p className="pl-1">or drag and drop</p>
              </div>
              <p className="text-xs text-gray-400">PNG only, up to 10MB</p>
            </div>
            <input type="file" className="hidden" onChange={handleMediaChange} accept="image/png" />
          </label>
        </div>

        {/* Submit Button */}
        <div className="flex justify-center mt-8">
          <button
            type="submit"
            disabled={isLoading}
            className="px-8 py-3 text-lg font-medium text-white rounded-lg shadow-lg bg-blue-600 hover:bg-blue-500 active:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200 transform hover:scale-105 active:scale-95"
          >
            {isLoading ? 'Creating...' : 'Create Certificate'}
          </button>
        </div>

        {/* Status Display */}
        <StatusDisplay />
      </form>
    </div>
  )
}
````

## File: src/app/specific/page.tsx
````typescript
'use client'

import { useState } from 'react'
import { PageHeader } from "@/components/layout/PageHeader"
import SpecificGrid from '@/modules/specific/SpecificGrid'
import SpecificMarketSummary from '@/modules/specific/SpecificMarketSummary'

interface MarketData {
  total_volume?: string
  market_cap?: string
}

export default function SpecificPage() {
  const [searchQuery, setSearchQuery] = useState('')
  const [marketData, setMarketData] = useState<MarketData[]>([])

  return (
    <div className="container mx-auto px-4 py-6">
      <div className="flex flex-col gap-6">
        <div className="flex justify-between items-start">
          <div className="flex-1">
            <PageHeader 
              title="specific ensurance"
              searchQuery={searchQuery}
              setSearchQuery={setSearchQuery}
              searchPlaceholder="what do you want to ensure?"
            />
          </div>
          <div className="min-w-[300px] pt-2">
            <SpecificMarketSummary variant="subtle" />
          </div>
        </div>

        <SpecificGrid
          searchQuery={searchQuery}
          onDataChange={setMarketData}
        />
      </div>
    </div>
  )
}
````

## File: src/app/syndicates/[name]/page.tsx
````typescript
'use client'

import React, { useEffect, useState } from 'react'
import { useParams } from 'next/navigation'
import Image from 'next/image'
import Link from 'next/link'
import { ArrowLeft } from 'lucide-react'
import { Card, CardContent } from '@/components/ui/card'
import { Skeleton } from '@/components/ui/skeleton'
import { PageHeader } from '@/components/layout/PageHeader'

interface SyndicateDetails {
  name: string;
  tagline: string;
  description: string | null;
  asset_address: string;
  chain: string;
  natural_capital_stocks: string[];
  natural_capital_flows: string[];
  nat_cap_rate: string | number;
  image_url: string;
  media?: {
    banner?: string;
  }
}

export default function SyndicateDetailsPage() {
  const params = useParams()
  // Keep the hyphenated version for the API query
  const syndicateName = params.name as string;
  
  const [syndicate, setSyndicate] = useState<SyndicateDetails | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  
  useEffect(() => {
    const fetchSyndicateDetails = async () => {
      try {
        setLoading(true)
        const response = await fetch(`/api/syndicates?name=${syndicateName}`)
        
        if (!response.ok) {
          throw new Error('Failed to fetch syndicate details')
        }
        
        const data = await response.json()
        if (data && data.length > 0) {
          setSyndicate(data[0])
        } else {
          setError('Syndicate not found')
        }
      } catch (err) {
        console.error('Error fetching syndicate details:', err)
        setError('Failed to load syndicate details')
      } finally {
        setLoading(false)
      }
    }
    
    if (syndicateName) {
      fetchSyndicateDetails()
    }
  }, [syndicateName])
  
  if (loading) {
    return (
      <div className="container mx-auto py-6 px-4">
        <PageHeader title="ensurance syndicate" showSearch={false} />
        <div className="max-w-4xl mx-auto">
          <Skeleton className="h-[30vh] min-h-[300px] w-full rounded-lg mb-6" />
          <Skeleton className="h-10 w-3/4 mb-3" />
          <Skeleton className="h-5 w-full mb-2" />
        </div>
      </div>
    )
  }
  
  if (error || !syndicate) {
    return (
      <div className="container mx-auto py-6 px-4">
        <PageHeader title="ensurance syndicate" showSearch={false} />
        <div className="max-w-4xl mx-auto">
          <Card>
            <CardContent className="pt-4">
              <div className="text-center">
                <h2 className="text-2xl font-bold text-red-500 mb-3">Error</h2>
                <p>{error || 'Failed to load syndicate details'}</p>
              </div>
            </CardContent>
          </Card>
        </div>
      </div>
    )
  }
  
  // Get banner image from media.banner or fallback to image_url
  const bannerImage = syndicate.media?.banner || syndicate.image_url || '/assets/ensurance-example.png';
  
  console.log('Syndicate data:', {
    name: syndicate.name,
    bannerImage,
    media: syndicate.media,
    image_url: syndicate.image_url
  });
  
  return (
    <div className="flex flex-col">
      {/* Hero Section with Banner */}
      <div className="relative h-[60vh] min-h-[500px]">
        <Image
          src={bannerImage}
          alt={`${syndicate.name} Banner`}
          fill
          className="object-cover"
          priority
          sizes="100vw"
          quality={95}
          onError={(e) => {
            const img = e.target as HTMLImageElement;
            img.src = '/assets/ensurance-example.png';
          }}
        />
        <div className="absolute inset-0 bg-gradient-to-t from-black/90 via-black/50 to-transparent" />
        
        {/* Overlay Content */}
        <div className="absolute inset-0 flex flex-col">
          <Link href="/syndicates" className="block">
            <div className="flex justify-center items-center gap-3 group pt-8">
              <ArrowLeft className="w-6 h-6 text-gray-400 group-hover:text-white transition-colors" />
              <PageHeader 
                title="ensurance syndicates"
                showSearch={false}
              />
            </div>
          </Link>
          
          {/* Title Content */}
          <div className="container mx-auto px-4 pb-12 mt-auto">
            <div className="max-w-4xl mx-auto space-y-6">
              <div className="space-y-4">
                <h1 className="text-4xl font-semibold text-white tracking-tight lowercase">
                  {syndicate.name}
                </h1>
                <p className="text-xl text-white/85 font-normal leading-relaxed lowercase">
                  {syndicate.tagline}
                </p>
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* Content Section */}
      <div className="container mx-auto px-4 py-12">
        <div className="max-w-4xl mx-auto space-y-12">
          {/* Top Stats */}
          <div className="flex items-center justify-between gap-4 flex-wrap">
            <span className="px-4 py-2 bg-white/10 backdrop-blur-md rounded-full text-sm text-white/90 font-medium tracking-wide lowercase">
              natural cap rate: {syndicate.nat_cap_rate}%
            </span>
            <a 
              href={`mailto:tmo@basin.global?subject=Join Waitlist: ${syndicate.name}&body=Hi, I'm interested in joining the waitlist for the ${syndicate.name} syndicate.%0D%0A%0D%0ASyndicate: ${syndicate.name}`}
              className="px-4 py-2 bg-white/10 hover:bg-white/15 backdrop-blur-md rounded-full text-sm text-white/90 font-medium tracking-wide lowercase transition-all duration-300"
            >
              join waitlist
            </a>
          </div>

          {/* Description */}
          {syndicate.description && (
            <div className="prose prose-lg dark:prose-invert max-w-none">
              <p className="text-lg leading-relaxed text-white/85 lowercase">{syndicate.description}</p>
            </div>
          )}

          {/* Natural Capital Details */}
          <div className="grid grid-cols-1 md:grid-cols-2 gap-12">
            <div className="space-y-4">
              <h3 className="text-xl font-semibold text-white tracking-tight lowercase mb-6">
                natural capital stocks
              </h3>
              <div className="flex flex-wrap gap-2">
                {syndicate.natural_capital_stocks.map((stock, index) => (
                  <span key={index} className="px-4 py-2 text-sm bg-white/10 backdrop-blur-sm rounded-full text-white/90 font-medium tracking-wide lowercase">
                    {stock}
                  </span>
                ))}
              </div>
            </div>

            <div className="space-y-4">
              <h3 className="text-xl font-semibold text-white tracking-tight lowercase mb-6">
                natural capital flows
              </h3>
              <div className="flex flex-wrap gap-2">
                {syndicate.natural_capital_flows.map((flow, index) => (
                  <span key={index} className="px-4 py-2 text-sm bg-white/10 backdrop-blur-sm rounded-full text-white/90 font-medium tracking-wide lowercase">
                    {flow}
                  </span>
                ))}
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}
````

## File: src/app/syndicates/page.tsx
````typescript
'use client'

// Syndicates functionality coming soon
// This page will be updated with syndicate features in an upcoming release

import { useState } from 'react'
import { PageHeader } from '@/components/layout/PageHeader'
import SyndicateGrid from '@/modules/syndicates/SyndicateGrid'

export default function SyndicatesPage() {
  const [searchQuery, setSearchQuery] = useState('')

  return (
    <div className="min-h-screen flex flex-col">
      <div className="container mx-auto px-4 py-8 flex-1">
        <div className="space-y-8">
          <PageHeader
            title="ensurance syndicates"
            description="diversified natural capital investments"
            searchQuery={searchQuery}
            setSearchQuery={setSearchQuery}
            searchPlaceholder="what do you want to ensure?"
            showSearch={true}
          />

          <SyndicateGrid 
            searchQuery={searchQuery}
          />
        </div>
      </div>
    </div>
  )
}
````

## File: src/app/fonts.ts
````typescript
import { Space_Grotesk, Space_Mono } from 'next/font/google';

export const spaceGrotesk = Space_Grotesk({
  subsets: ['latin'],
  variable: '--font-space-grotesk',
});

export const spaceMono = Space_Mono({
  subsets: ['latin'],
  weight: ['400', '700'],
  variable: '--font-space-mono',
});
````

## File: src/app/globals.css
````css
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer utilities {
  .animate-blink {
    animation: blink 1s step-end infinite;
  }
  
  .animate-pulse-subtle {
    animation: pulse-subtle 2s ease-in-out infinite;
  }
  
  .swarm-orb {
    opacity: 0;
    transform: scale(0.5) translate(var(--entry-x), var(--entry-y));
    animation: swarmEntry 1.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) var(--delay) forwards;
  }
}

@keyframes blink {
  from, to {
    opacity: 1;
  }
  50% {
    opacity: 0;
  }
}

@keyframes pulse-subtle {
  0%, 100% {
    box-shadow: 0 0 0 1px rgba(96, 165, 250, 0.2);
  }
  50% {
    box-shadow: 0 0 0 2px rgba(96, 165, 250, 0.4);
  }
}

@keyframes swarmEntry {
  0% {
    opacity: 0;
    transform: scale(0.5) translate(var(--entry-x), var(--entry-y));
  }
  100% {
    opacity: 1;
    transform: scale(1) translate(0px, 0px);
  }
}

:root {
  --foreground-rgb: 255, 255, 255;
  --background-rgb: 0, 0, 0;
  /* Dark theme tabs */
  --tab-active: rgb(var(--foreground-rgb));
  --tab-text: rgb(var(--background-rgb));
  --tab-bg: rgba(var(--foreground-rgb), 0.1);
  --tab-panel-bg: rgba(var(--foreground-rgb), 0.05);
}

/* Privy Modal Customization */
:root {
  /* Background colors - dark theme */
  --privy-color-background: hsl(0, 0%, 0%);
  --privy-color-background-2: hsl(0, 0%, 9%);
  --privy-color-background-3: hsl(0, 0%, 13%);
  
  /* Text colors */
  --privy-color-foreground: hsl(0, 0%, 100%);
  --privy-color-foreground-2: hsl(0, 0%, 80%);
  --privy-color-foreground-3: hsl(0, 0%, 60%);
  --privy-color-foreground-4: hsl(0, 0%, 40%);
  
  /* Accent colors - using your green theme */
  --privy-color-accent: hsl(142, 71%, 45%);
  --privy-color-accent-light: hsl(142, 71%, 55%);
  --privy-color-accent-lightest: hsl(142, 71%, 65%);
  --privy-color-accent-dark: hsl(142, 71%, 35%);
  
  /* Status colors */
  --privy-color-success: hsl(142, 71%, 45%);
  --privy-color-error: hsl(0, 84%, 60%);
  --privy-color-error-light: hsl(0, 84%, 90%);
  
  /* Border radius */
  --privy-border-radius-sm: 4px;
  --privy-border-radius-md: 6px;
  --privy-border-radius-lg: 8px;
  --privy-border-radius-full: 9999px;

  /* Modal dimensions and spacing */
  --privy-height-modal-compact: 420px;
  --privy-spacing-modal-header: 12px;
  --privy-spacing-modal-content: 16px;
}

/* Force Space Mono font on all Privy elements */
[data-privy-dialog] *,
div[role="dialog"] *,
[data-radix-popper-content-wrapper] * {
  font-family: 'Space Mono', monospace !important;
}

/* Additional Privy modal spacing adjustments */
[data-privy-dialog] [role="dialog"] > div:first-child {
  gap: 12px !important;
}

/* Style Privy's sign and wallet messages */
[data-privy-dialog] [role="dialog"] h2,
[data-privy-dialog] [role="dialog"] h3,
[data-privy-dialog] [role="dialog"] [role="heading"] {
  font-size: 14px !important;
  opacity: 0.7;
  letter-spacing: -0.01em;
  font-family: 'Space Mono', monospace !important;
}

[data-privy-dialog] [role="dialog"] p,
[data-privy-dialog] [role="dialog"] span {
  font-size: 12px !important;
  opacity: 0.5;
  letter-spacing: -0.01em;
  font-family: 'Space Mono', monospace !important;
}

/* Style Privy footer/branding */
.ModalFooter-sc-c97bf02f-1 {
  font-family: 'Space Mono', monospace !important;
  opacity: 0.75 !important;
}

.ModalFooter-sc-c97bf02f-1 svg {
  opacity: 0.75 !important;
}

.ModalFooter-sc-c97bf02f-1 svg g {
  fill: hsl(0, 0%, 58%) !important;
}

html {
  height: 100%;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}

body {
  min-height: 100vh;
  color: rgb(var(--foreground-rgb));
  background: rgb(var(--background-rgb));
}

/* Add these styles to override react-toastify defaults */
.Toastify__toast {
  font-family: var(--font-space-mono) !important;
}

.Toastify__toast-body {
  font-family: var(--font-space-mono) !important;
}

/* Ensure modals are always on top */
.modal-backdrop {
  position: fixed;
  inset: 0;
  z-index: 999999 !important;
  background: rgba(0, 0, 0, 0.5);
}

.modal-content {
  position: fixed;
  top: 1rem;
  left: 50%;
  transform: translateX(-50%);
  z-index: 1000000 !important;
  width: 100%;
}

/* Documentation Typography Improvements */
.prose {
  font-size: 1.125rem !important;
  line-height: 1.75 !important;
  letter-spacing: -0.01em !important;
}

.prose p {
  margin-top: 1.25em !important;
  margin-bottom: 1.25em !important;
  opacity: 0.9 !important;
}

.prose h1 {
  font-size: 2.5rem !important;
  line-height: 1.2 !important;
  margin-bottom: 2rem !important;
}

.prose h2 {
  font-size: 1.875rem !important;
  line-height: 1.3 !important;
  margin-top: 2.5rem !important;
  margin-bottom: 1.25rem !important;
}

.prose h3 {
  font-size: 1.5rem !important;
  line-height: 1.4 !important;
  margin-top: 2rem !important;
  margin-bottom: 1rem !important;
}

.prose h4 {
  font-size: 1.25rem !important;
  line-height: 1.4 !important;
  margin-top: 1.5rem !important;
  margin-bottom: 0.75rem !important;
  opacity: 0.9 !important;
}

/* Documentation Link Styles */
.prose a {
  color: rgb(var(--foreground-rgb)) !important;
  text-decoration: none !important;
  transition: all 0.15s ease-in-out !important;
  opacity: 0.9 !important;
  border-bottom: 1px solid rgba(var(--foreground-rgb), 0.3) !important;
  padding-bottom: 1px !important;
}

.prose a:hover {
  opacity: 1 !important;
  border-bottom-color: rgba(var(--foreground-rgb), 0.8) !important;
}

/* Section cards should not have underlines */
.section-link {
  border-bottom: none !important;
  padding-bottom: 0 !important;
}

.section-link:hover {
  border-bottom: none !important;
}

/* External links get a subtle icon */
.prose a[href^="http"]::after {
  content: "↗" !important;
  display: inline-block !important;
  margin-left: 0.2em !important;
  font-family: 'Space Mono', monospace !important;
  font-size: 0.9em !important;
  opacity: 0.6 !important;
  transition: opacity 0.15s ease-in-out !important;
}

.prose a[href^="http"]:hover::after {
  opacity: 0.9 !important;
}

/* Keep headings links clean */
.prose h1 a,
.prose h2 a,
.prose h3 a,
.prose h4 a {
  border-bottom: none !important;
  padding-bottom: 0 !important;
}

.prose h1 a:hover,
.prose h2 a:hover,
.prose h3 a:hover,
.prose h4 a:hover {
  border-bottom: none !important;
}

/* Section link styles */
.prose .section-link {
  display: block !important;
  margin-bottom: 0.5rem !important;
  font-weight: 500 !important;
  opacity: 0.8 !important;
  transition: opacity 0.15s ease-in-out !important;
}

.prose .section-link:hover {
  opacity: 1 !important;
}

.prose .section-description {
  font-size: 0.9375rem !important;
  opacity: 0.7 !important;
  margin-top: 0.25rem !important;
  margin-bottom: 1rem !important;
}

.prose ul,
.prose ol {
  margin-top: 1.25em !important;
  margin-bottom: 1.25em !important;
  padding-left: 1.625em !important;
}

.prose li {
  margin-top: 0.5em !important;
  margin-bottom: 0.5em !important;
  opacity: 0.9 !important;
}

.prose code {
  font-size: 0.875em !important;
  padding: 0.2em 0.4em !important;
  background-color: rgba(var(--foreground-rgb), 0.1) !important;
  border-radius: 0.25rem !important;
}

/* Not Prose Section Styling */
.not-prose {
  font-family: 'Space Mono', monospace;
  font-size: 0.9375rem;
  line-height: 1.6;
  margin-top: 1.5rem;
  margin-bottom: 1.5rem;
}

.not-prose .content-box {
  background-color: rgba(var(--foreground-rgb), 0.03);
  padding: 1.5rem;
  border-radius: 0.5rem;
}

/* Grid Styling */
.not-prose .grid {
  margin-top: 0 !important;
}

.not-prose .grid h3 {
  margin-top: 0 !important;
  font-size: 1.125rem !important;
  font-weight: 600 !important;
  margin-bottom: 1rem !important;
  opacity: 0.9 !important;
}

.not-prose .grid ul {
  margin: 0 !important;
  padding: 0 !important;
}

.not-prose .grid li {
  margin: 0.5rem 0 !important;
  opacity: 0.9 !important;
}

/* Rest of not-prose styles */
.not-prose h3 {
  font-size: 1.125rem;
  font-weight: 600;
  margin-bottom: 1rem;
  margin-top: 0;
  opacity: 0.9;
}

/* Adjust spacing between prose and not-prose */
.prose + .not-prose {
  margin-top: 1.5rem;
}

.not-prose + .prose {
  margin-top: 1.5rem;
}

/* Remove double margins when not-prose elements are stacked */
.not-prose + .not-prose {
  margin-top: 0;
}

/* Rest of not-prose styles */
.not-prose .label-group {
  margin-bottom: 1.25rem;
}

.not-prose .label-row {
  display: flex;
  align-items: baseline;
  gap: 0.5rem;
  margin-bottom: 0.5rem;
}

.not-prose .label {
  font-weight: 500;
  opacity: 0.7;
}

.not-prose .value {
  opacity: 0.9;
}

.not-prose ul.list-disc {
  list-style-type: disc;
  margin-top: 0.5rem;
  margin-left: 1rem;
  opacity: 0.9;
}

.not-prose li {
  margin: 0.25rem 0;
}

.not-prose .border-t {
  border-top-width: 1px;
  border-color: rgba(var(--foreground-rgb), 0.1);
  margin-top: 1.5rem;
  padding-top: 1.5rem;
}

.not-prose .font-mono {
  opacity: 0.9;
}

/* Documentation Section Grid */
.section-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 2rem;
  margin-top: 2rem;
}

.section {
  position: relative;
  background-color: rgba(var(--foreground-rgb), 0.03);
  padding: 1.5rem;
  border-radius: 0.5rem;
  transition: all 0.15s ease-in-out;
}

.section:hover {
  background-color: rgba(var(--foreground-rgb), 0.05);
  transform: translateY(-1px);
}

.section a.card-link {
  position: absolute;
  inset: 0;
  border-radius: 0.5rem;
  border-bottom: none !important;
  z-index: 1;
}

.section a.card-link:hover {
  border-bottom: none !important;
}

.section .section-content {
  position: relative;
  z-index: 2;
  pointer-events: none;
}

.section .section-title {
  font-size: 1.25rem;
  font-weight: 500;
  margin-bottom: 0.5rem;
  color: rgb(var(--foreground-rgb));
  opacity: 0.9;
}

.section .section-description {
  font-size: 0.9375rem;
  opacity: 0.7;
  margin: 0;
}
````

## File: src/app/layout.tsx
````typescript
import { spaceGrotesk, spaceMono } from './fonts'
import './globals.css'
import { PrivyProviderWrapper } from '@/providers/privy-provider'
import Header from '@/components/layout/header'
import Footer from '@/components/layout/footer'
import WebAnalytics from '@/components/analytics/WebAnalytics'
import AnnouncementBanner from '@/components/layout/AnnouncementBanner'
import 'react-toastify/dist/ReactToastify.css';
import { ToastContainer } from 'react-toastify'
import { Metadata } from 'next'
import { generateShare } from '@/lib/share'
import { headers } from 'next/headers'
import '@/config/zora'

export async function generateMetadata({ params }: { params: any }): Promise<Metadata> {
  const headersList = headers()
  const pathname = headersList.get('x-pathname') || '/'
  return generateShare(pathname, params)
}

export const viewport = {
  width: 'device-width',
  initialScale: 1,
  maximumScale: 5,
  userScalable: true,
  themeColor: '#000000',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en" className={`${spaceGrotesk.variable} ${spaceMono.variable}`}>
      <head>
        <WebAnalytics />
      </head>
      <body className="antialiased min-h-screen flex flex-col font-grotesk bg-black text-white overflow-x-hidden">
        <PrivyProviderWrapper>
          <AnnouncementBanner />
          <Header />
          <ToastContainer 
            theme="dark"
            position="top-right"
            toastClassName="!bg-gray-900 !text-gray-100 !max-w-[90vw] md:!max-w-md"
            progressClassName="!bg-blue-500"
            closeButton={false}
            limit={3}
          />
          <main className="flex-1 w-full max-w-[100vw]">
            {children}
          </main>
          <Footer />
        </PrivyProviderWrapper>
        <div id="modal-root" className="relative z-50" />
      </body>
    </html>
  )
}
````

## File: src/app/not-found.tsx
````typescript
import Image from 'next/image'

export default function NotFound() {
  // Array of disaster photos - you'll need to add these to /public/404/
  const disasterPhotos = Array.from({ length: 8 }, (_, i) => `/404/disaster-${i + 1}.jpg`)

  return (
    <div className="flex-1 flex flex-col items-center justify-center p-4 md:p-8 lg:p-12">
      <div className="w-full max-w-[min(80vh,80vw)] mx-auto">
        <a href="/" className="block hover:opacity-90 transition-opacity">
          {/* 3x3 Grid with Message in Center */}
          <div className="grid grid-cols-3 gap-2 md:gap-3 lg:gap-4 aspect-square w-full">
            {disasterPhotos.slice(0, 4).map((photo, index) => (
              <div key={index} className="relative aspect-square w-full overflow-hidden rounded-lg">
                <Image
                  src={photo}
                  alt={`Natural disaster ${index + 1}`}
                  fill
                  className="object-cover transition-all hover:scale-105"
                  sizes="(max-width: 768px) 33vw, 25vw"
                />
              </div>
            ))}
            
            {/* Center Message Tile */}
            <div className="relative aspect-square w-full rounded-lg bg-black/50 backdrop-blur-sm flex items-center justify-center p-2">
              <div className="text-center">
                <h1 className="text-lg md:text-2xl font-bold font-grotesk mb-1">
                  <span className="text-2xl md:text-4xl block mb-1">404</span>
                  this no longer exists!!!
                </h1>
                <p className="text-xs md:text-sm font-grotesk text-[rgba(var(--foreground-rgb),0.8)] mb-1">
                  neither will society or the economy
                </p>
                <p className="text-sm md:text-base font-bold font-grotesk">
                  unless we <span className="text-emerald-400">$ENSURE</span> it
                </p>
              </div>
            </div>

            {/* Remaining Photos */}
            {disasterPhotos.slice(4).map((photo, index) => (
              <div key={index + 4} className="relative aspect-square w-full overflow-hidden rounded-lg">
                <Image
                  src={photo}
                  alt={`Natural disaster ${index + 5}`}
                  fill
                  className="object-cover transition-all hover:scale-105"
                  sizes="(max-width: 768px) 33vw, 25vw"
                />
              </div>
            ))}
          </div>
        </a>
      </div>
    </div>
  )
}
````

## File: src/app/page.tsx
````typescript
'use client'

import { EnsureMagnet } from '@/modules/ensure/EnsureMagnet'
import { DeclarativeHero } from '@/components/layout/DeclarativeHero'
import { DeclarativeSection } from '@/components/layout/DeclarativeSection'
import { useEffect } from 'react'

export default function HomePage() {
  useEffect(() => {
    const handleScroll = () => {
      const scrollPosition = window.scrollY
      const windowHeight = window.innerHeight
      const header = document.querySelector('header')
      
      if (header) {
        // Add fixed positioning and high z-index only on home page
        header.style.position = 'fixed'
        header.style.top = '0'
        header.style.zIndex = '100'
        
        // Start fading in when we're closer to the DeclarativeHero section
        if (scrollPosition > windowHeight * 0.7) {
          header.style.opacity = '1'
          header.style.backgroundColor = 'black'
        } else {
          header.style.opacity = '0'
          header.style.backgroundColor = 'transparent'
        }
      }
    }

    // Set initial state
    const header = document.querySelector('header')
    if (header) {
      header.style.position = 'fixed'
      header.style.top = '0'
      header.style.zIndex = '100'
      header.style.opacity = '0'
      header.style.backgroundColor = 'transparent'
    }
    handleScroll()

    window.addEventListener('scroll', handleScroll)
    return () => {
      window.removeEventListener('scroll', handleScroll)
      // Clean up styles when leaving home page
      const header = document.querySelector('header')
      if (header) {
        header.style.position = ''
        header.style.top = ''
        header.style.zIndex = ''
        header.style.opacity = ''
        header.style.backgroundColor = ''
      }
    }
  }, [])

  return (
    <main>
      <EnsureMagnet />
      <DeclarativeHero />
      <DeclarativeSection />
    </main>
  )
}
````

## File: src/components/analytics/WebAnalytics.tsx
````typescript
'use client'

import Script from 'next/script'

// Replace these with your actual IDs
const GA_MEASUREMENT_ID = 'G-L3DDVTMKQK'
const META_PIXEL_ID = '621181203754012'

export default function WebAnalytics() {
  return (
    <>
      {/* Site Analytics */}
      <Script
        src={`https://www.googletagmanager.com/gtag/js?id=${GA_MEASUREMENT_ID}`}
        strategy="afterInteractive"
      />
      <Script id="google-analytics" strategy="afterInteractive">
        {`
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', '${GA_MEASUREMENT_ID}');
        `}
      </Script>

      {/* Social Integration */}
      <Script id="meta-pixel" strategy="afterInteractive">
        {`
          !function(f,b,e,v,n,t,s)
          {if(f.fbq)return;n=f.fbq=function(){n.callMethod?
          n.callMethod.apply(n,arguments):n.queue.push(arguments)};
          if(!f._fbq)f._fbq=n;n.push=n;n.loaded=!0;n.version='2.0';
          n.queue=[];t=b.createElement(e);t.async=!0;
          t.src=v;s=b.getElementsByTagName(e)[0];
          s.parentNode.insertBefore(t,s)}(window, document,'script',
          'https://connect.facebook.net/en_US/fbevents.js');
          fbq('init', '${META_PIXEL_ID}');
          fbq('track', 'PageView');
        `}
      </Script>
    </>
  )
}
````

## File: src/components/layout/verifications/AccountVerification.tsx
````typescript
'use client'

import Link from 'next/link'
import useSWR from 'swr'
import OperatorVerification from './OperatorVerification'

interface Props {
  name: string
  group: string
}

const fetcher = (url: string) => fetch(url).then(r => r.json())

export default function AccountVerification({ name, group }: Props) {
  const { data: groupData } = useSWR(
    `/api/groups?group_name=${encodeURIComponent(group.startsWith('.') ? group : `.${group}`)}`,
    fetcher,
    { 
      revalidateOnFocus: false,
      revalidateOnReconnect: false,
      dedupingInterval: 60000 
    }
  )

  const { data: accountData } = useSWR(
    `/api/accounts/${encodeURIComponent(name)}`,
    fetcher,
    { 
      revalidateOnFocus: false,
      revalidateOnReconnect: false,
      dedupingInterval: 60000 
    }
  )

  if (!groupData?.contract_address || !accountData?.token_id) return null

  // TODO(TMO): Fix spacing issue between verification section and gradient line in account page layout
  return (
    <div className="text-[12px] flex flex-col items-center gap-2">
      <div className="flex gap-2">
        <Link
          href={`https://basescan.org/token/${groupData.contract_address}#code`}
          target="_blank"
          rel="noopener noreferrer"
          className="text-gray-400 hover:text-white transition-colors"
        >
          group
        </Link>
        <Link
          href={`https://basescan.org/nft/${groupData.contract_address}/${accountData.token_id}`}
          target="_blank"
          rel="noopener noreferrer"
          className="text-gray-400 hover:text-white transition-colors"
        >
          account
        </Link>
      </div>
      <div className="flex gap-2">
        <Link
          href={`https://opensea.io/assets/base/${groupData.contract_address}/${accountData.token_id}`}
          target="_blank"
          rel="noopener noreferrer"
          className="text-gray-400 hover:text-white transition-colors"
        >
          opensea
        </Link>
        <Link
          href={`https://rarible.com/token/base/${groupData.contract_address}:${accountData.token_id}`}
          target="_blank"
          rel="noopener noreferrer"
          className="text-gray-400 hover:text-white transition-colors"
        >
          rarible
        </Link>
        <Link
          href={`https://tokenbound.org/assets/base/${groupData.contract_address}/${accountData.token_id}`}
          target="_blank"
          rel="noopener noreferrer"
          className="text-gray-400 hover:text-white transition-colors"
        >
          tokenbound
        </Link>
      </div>
      <div className="flex gap-2">
        <OperatorVerification 
          name={name}
          group={group}
          tokenId={accountData.token_id}
        />
      </div>
    </div>
  )
}
````

## File: src/components/layout/verifications/GeneralCertificateVerification.tsx
````typescript
'use client'

import { useState } from 'react'
import Link from 'next/link'
import { Button } from "@/components/ui/button"

interface Props {
  contractAddress: string
}

export default function GeneralCertificateVerification({ contractAddress }: Props) {
  const [refreshing, setRefreshing] = useState(false)

  const handleRefresh = async () => {
    try {
      setRefreshing(true)
      const response = await fetch(`/api/general?address=${contractAddress}`, {
        method: 'POST'
      })
      
      if (!response.ok) {
        throw new Error('Failed to refresh market data')
      }
      
      // Trigger a page refresh to show updated data
      window.location.reload()
    } catch (error) {
      console.error('Error refreshing market data:', error)
    } finally {
      setRefreshing(false)
    }
  }

  return (
    <div className="flex flex-col gap-1.5">
      {/* Certificate verification line */}
      <div className="flex justify-center">
        <Link
          href={`https://basescan.org/token/${contractAddress}#readProxyContract`}
          target="_blank"
          rel="noopener noreferrer"
          className="text-blue-500 hover:text-blue-600 transition-colors"
        >
          certificate of ensurance
        </Link>
      </div>

      {/* Zora link line */}
      <div className="flex justify-center gap-2">
        <Link
          href={`https://zora.co/coin/base:${contractAddress}`}
          target="_blank"
          rel="noopener noreferrer"
          className="text-gray-400 hover:text-white transition-colors"
        >
          zora
        </Link>
        <Link
          href={`https://matcha.xyz/tokens/base/${contractAddress}`}
          target="_blank"
          rel="noopener noreferrer"
          className="text-gray-400 hover:text-white transition-colors"
        >
          matcha
        </Link>
      </div>

      <Button
        variant="ghost"
        size="sm"
        onClick={handleRefresh}
        disabled={refreshing}
        className="text-[12px] text-gray-400 hover:text-white transition-colors"
      >
        {refreshing ? 'refreshing...' : 'refresh'}
      </Button>
    </div>
  )
}
````

## File: src/components/layout/verifications/GroupVerification.tsx
````typescript
'use client'

import Link from 'next/link'
import useSWR from 'swr'

interface Props {
  name: string
}

const fetcher = (url: string) => fetch(url).then(r => r.json())

export default function GroupVerification({ name }: Props) {
  const { data: groupData } = useSWR(
    `/api/groups?group_name=${encodeURIComponent(name.startsWith('.') ? name : `.${name}`)}`,
    fetcher,
    { 
      revalidateOnFocus: false,
      revalidateOnReconnect: false,
      dedupingInterval: 60000 
    }
  )

  if (!groupData?.contract_address) return null

  return (
    <Link
      href={`https://basescan.org/token/${groupData.contract_address}#readContract`}
      target="_blank"
      rel="noopener noreferrer"
      className="text-gray-400 hover:text-white transition-colors"
    >
      group
    </Link>
  )
}
````

## File: src/components/layout/verifications/NftLinks.tsx
````typescript
'use client'

import Link from 'next/link'

interface Props {
  contractAddress: string
  tokenId: string
  chain?: string
  showTokenbound?: boolean
}

export default function NftLinks({ contractAddress, tokenId, chain = 'base', showTokenbound = false }: Props) {
  return (
    <div className="flex justify-center gap-2">
      <Link
        href={`https://opensea.io/assets/${chain}/${contractAddress}/${tokenId}`}
        target="_blank"
        rel="noopener noreferrer"
        className="text-gray-400 hover:text-white transition-colors"
      >
        opensea
      </Link>

      <Link
        href={`https://rarible.com/token/${chain}/${contractAddress}:${tokenId}`}
        target="_blank"
        rel="noopener noreferrer"
        className="text-gray-400 hover:text-white transition-colors"
      >
        rarible
      </Link>

      {showTokenbound && (
        <Link
          href={`https://tokenbound.org/assets/${chain}/${contractAddress}/${tokenId}`}
          target="_blank"
          rel="noopener noreferrer"
          className="text-gray-400 hover:text-white transition-colors"
        >
          tokenbound
        </Link>
      )}
    </div>
  )
}
````

## File: src/components/layout/verifications/OperatorVerification.tsx
````typescript
'use client'

import { useEffect, useState } from 'react'
import Link from 'next/link'
import { usePrivy } from '@privy-io/react-auth'
import { createPublicClient, http } from 'viem'
import { base } from 'viem/chains'
import type { Address } from 'viem'
import { cn } from '@/lib/utils'
import SITUS_ABI from '@/abi/SitusOG.json'

interface Props {
  name: string
  group: string
  tokenId: number
}

export default function OperatorVerification({ name, group, tokenId }: Props) {
  const { user } = usePrivy()
  const [isOperator, setIsOperator] = useState(false)
  const [operatorAddress, setOperatorAddress] = useState<Address | null>(null)
  const statusDotClasses = "w-1.5 h-1.5 rounded-full relative after:content-[''] after:absolute after:inset-0 after:rounded-full after:animate-pulse mt-[1px]"

  useEffect(() => {
    async function checkOperator() {
      try {
        const client = createPublicClient({
          chain: base,
          transport: http()
        })

        // Get the contract address from the group name
        const factoryResponse = await fetch('/api/groups')
        const groups = await factoryResponse.json()
        const groupData = groups.find((g: any) => g.group_name === `.${group}`)
        
        if (!groupData?.contract_address) {
          console.warn('Group contract address not found')
          return
        }

        const operator = await client.readContract({
          address: groupData.contract_address as `0x${string}`,
          abi: SITUS_ABI,
          functionName: 'ownerOf',
          args: [BigInt(tokenId)]
        }) as Address

        setOperatorAddress(operator)
        if (user?.wallet?.address) {
          setIsOperator(operator.toLowerCase() === user.wallet.address.toLowerCase())
        }
      } catch (error) {
        console.error('Error checking operator:', error)
      }
    }

    checkOperator()
  }, [user?.wallet?.address, tokenId, group])

  if (!operatorAddress) return null

  return (
    <div className="flex items-center gap-2">
      <Link
        href={`https://basescan.org/address/${operatorAddress}`}
        target="_blank"
        rel="noopener noreferrer"
        className="text-gray-400 hover:text-white transition-colors"
      >
        operator
      </Link>
      {isOperator && (
        <span className={cn(
          statusDotClasses,
          "bg-green-500 after:bg-green-500/50"
        )} />
      )}
    </div>
  )
}
````

## File: src/components/layout/verifications/SpecificCertificateVerification.tsx
````typescript
'use client'

// TODO: This component will be reimplemented for specific ensurance certificates
// Currently contains legacy verification code that will be updated
// to handle Base chain specific functionality in the future

import Link from 'next/link'
import NftLinks from './NftLinks'

interface Props {
  tokenId?: string
  contractAddress: string
}

export default function SpecificCertificateVerification({ tokenId, contractAddress }: Props) {
  if (!tokenId) {
    return null
  }

  return (
    <div className="flex flex-col gap-1.5">
      {/* Certificate verification line */}
      <div className="flex justify-center gap-2">
        <Link
          href={`https://basescan.org/nft/${contractAddress}/${tokenId}`}
          target="_blank"
          rel="noopener noreferrer"
          className="text-blue-500 hover:text-blue-600 transition-colors"
        >
          certificate
        </Link>
        <span className="text-gray-400">of</span>
        <Link
          href={`https://basescan.org/token/${contractAddress}#readProxyContract`}
          target="_blank"
          rel="noopener noreferrer"
          className="text-blue-500 hover:text-blue-600 transition-colors"
        >
          ensurance
        </Link>
      </div>

      {/* NFT marketplaces line */}
      <NftLinks 
        contractAddress={contractAddress}
        tokenId={tokenId}
        chain="base"
        showTokenbound={false}
      />
    </div>
  )
}
````

## File: src/components/layout/verifications/VerificationSection.tsx
````typescript
'use client'

import GroupVerification from './GroupVerification'
import AccountVerification from './AccountVerification'
import GeneralCertificateVerification from './GeneralCertificateVerification'
import SpecificCertificateVerification from './SpecificCertificateVerification'
import { ShieldCheck } from 'lucide-react'

interface Props {
  type: 'group' | 'account' | 'general' | 'specific'
  name: string
  group?: string
  contractAddress?: string
  tokenId?: string
}

export default function VerificationSection({ type, name, group, contractAddress, tokenId }: Props) {
  return (
    <div className="w-full border-t border-gray-800 py-4">
      <div className="container mx-auto px-4">
        <div className="max-w-4xl mx-auto">
          <div className="flex flex-col items-center justify-center gap-1">
            <div className="flex items-center gap-1.5">
              <ShieldCheck className="w-4 h-4 text-white" />
              <span className="text-[13px] font-mono text-white font-medium">based onchain</span>
              <ShieldCheck className="w-4 h-4 text-white" />
            </div>
            <div className="text-[12px]">
              {type === 'group' ? (
                <GroupVerification name={name} />
              ) : type === 'account' ? (
                <AccountVerification name={name} group={group!} />
              ) : type === 'specific' ? (
                <SpecificCertificateVerification 
                  contractAddress={contractAddress!} 
                  tokenId={tokenId}
                />
              ) : (
                <GeneralCertificateVerification contractAddress={contractAddress!} />
              )}
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}
````

## File: src/components/layout/AccountNavigation.tsx
````typescript
'use client'

import Link from 'next/link'
import { usePathname } from 'next/navigation'
import { cn } from '@/lib/utils'
import * as Tooltip from '@radix-ui/react-tooltip'

interface AccountNavigationProps {
  accountName: string
}

export function AccountNavigation({ accountName }: AccountNavigationProps) {
  const pathname = usePathname()
  const isSubPage = pathname.endsWith('/hold') || pathname.endsWith('/tend') || pathname.endsWith('/presence')
  
  const links = [
    { 
      href: `/${accountName}/tend`, 
      label: 'TEND',
      tooltip: 'ensure this asset & outcome'
    },
    { 
      href: `/${accountName}/hold`, 
      label: 'HOLD',
      tooltip: 'view agent\'s portfolio'
    },
    { 
      href: `/${accountName}/presence`, 
      label: 'PRESENCE',
      tooltip: 'view agent\'s impact'
    }
  ]

  return (
    <Tooltip.Provider delayDuration={300}>
      <div className="flex items-center h-14 ml-[104px]">
        <div className="flex items-center">
          {/* Fixed width back arrow container */}
          <div className="w-10 flex justify-center">
            {isSubPage ? (
              <Tooltip.Root>
                <Tooltip.Trigger asChild>
                  <Link
                    href={`/${accountName}`}
                    className="p-2 text-gray-400 hover:text-gray-200 transition-colors"
                    title="Back to overview"
                  >
                    <svg 
                      viewBox="0 0 16 16" 
                      fill="none" 
                      className="w-5 h-5"
                      stroke="currentColor" 
                      strokeWidth={2}
                    >
                      <path d="M10 12L6 8L10 4" strokeLinecap="round" strokeLinejoin="round" />
                    </svg>
                  </Link>
                </Tooltip.Trigger>
                <Tooltip.Portal>
                  <Tooltip.Content
                    className="bg-gray-900 px-3 py-1.5 rounded-md text-xs text-gray-200 border border-gray-800"
                    sideOffset={5}
                  >
                    Back to overview
                    <Tooltip.Arrow className="fill-gray-900" />
                  </Tooltip.Content>
                </Tooltip.Portal>
              </Tooltip.Root>
            ) : (
              <div className="w-10" /> 
            )}
          </div>

          {/* Navigation buttons */}
          <div className="flex gap-2">
            {links.map(({ href, label, tooltip }) => {
              const isActive = pathname === href
              return (
                <Tooltip.Root key={href}>
                  <Tooltip.Trigger asChild>
                    <Link
                      href={href}
                      className={cn(
                        "px-4 py-2 rounded-md text-base font-semibold tracking-wide transition-colors",
                        isActive
                          ? "bg-gray-800 text-white"
                          : "text-gray-400 hover:text-gray-200"
                      )}
                    >
                      {label}
                    </Link>
                  </Tooltip.Trigger>
                  <Tooltip.Portal>
                    <Tooltip.Content
                      className="bg-gray-900 px-3 py-1.5 rounded-md text-xs text-gray-200 border border-gray-800"
                      sideOffset={5}
                    >
                      {tooltip}
                      <Tooltip.Arrow className="fill-gray-900" />
                    </Tooltip.Content>
                  </Tooltip.Portal>
                </Tooltip.Root>
              )
            })}
          </div>
        </div>
      </div>
    </Tooltip.Provider>
  )
}
````

## File: src/components/layout/AnnouncementBanner.tsx
````typescript
'use client';

import { useState, useEffect } from 'react';
import Link from 'next/link';

export default function AnnouncementBanner() {
  const [isVisible, setIsVisible] = useState(false);

  useEffect(() => {
    const lastDismissed = localStorage.getItem('announcementBannerDismissed');
    const shownThisSession = sessionStorage.getItem('announcementBannerShownThisSession');
    
    const shouldShow = !lastDismissed || 
      (Date.now() - parseInt(lastDismissed)) > 7 * 24 * 60 * 60 * 1000 ||
      (!shownThisSession && !lastDismissed);
    
    if (shouldShow) {
      setIsVisible(true);
      sessionStorage.setItem('announcementBannerShownThisSession', 'true');
    }
  }, []);

  const handleDismiss = () => {
    setIsVisible(false);
    localStorage.setItem('announcementBannerDismissed', Date.now().toString());
    sessionStorage.removeItem('announcementBannerShownThisSession');
  };

  if (!isVisible) return null;

  return (
    <div className="relative bg-gray-900/50 backdrop-blur-sm border-b border-gray-800/50">
      <div className="max-w-7xl mx-auto py-0.5 px-3 sm:px-6 lg:px-8">
        <div className="flex items-center justify-between flex-wrap">
          <div className="w-0 flex-1 flex items-center justify-center">
            <p className="text-[11px] text-gray-400 text-center">
              <span className="inline-flex items-center">
                <span className="mr-1">⚡️</span>
                <span>YOU&apos;RE EARLY - please</span>
                <Link
                  href="https://x.com/ensurance_app"
                  className="ml-1 font-medium text-blue-400 hover:text-blue-300 transition-colors underline-offset-4 hover:underline"
                  target="_blank"
                  rel="noopener noreferrer"
                >
                  report bugs
                </Link>
                <span className="ml-1">⚡️</span>
              </span>
            </p>
          </div>
          <div className="order-2 flex-shrink-0 sm:order-3 sm:ml-3">
            <button
              type="button"
              onClick={handleDismiss}
              className="-mr-1 flex p-0.5 rounded-md hover:bg-gray-800/50 focus:outline-none focus:ring-1 focus:ring-gray-700 transition-colors"
            >
              <span className="sr-only">Dismiss</span>
              <svg 
                className="h-2.5 w-2.5 text-gray-500" 
                fill="none" 
                viewBox="0 0 24 24" 
                stroke="currentColor"
              >
                <path 
                  strokeLinecap="round" 
                  strokeLinejoin="round" 
                  strokeWidth="2" 
                  d="M6 18L18 6M6 6l12 12" 
                />
              </svg>
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}
````

## File: src/components/layout/ConnectOperator.tsx
````typescript
'use client'

import { useState, useEffect, useRef } from 'react'
import { cn } from '@/lib/utils'
import { ChevronDown, User, Wallet } from 'lucide-react'
import { usePrivy } from '@privy-io/react-auth'
import { toast } from 'react-toastify'
import Link from 'next/link'

export function ConnectOperator() {
  const { login, ready, authenticated, logout, user } = usePrivy()
  const [showDropdown, setShowDropdown] = useState(false)
  const menuRef = useRef<HTMLDivElement>(null)

  const truncateAddress = (address?: string) => {
    if (!address) return ''
    return `${address.slice(0, 6)}...${address.slice(-4)}`
  }

  useEffect(() => {
    const handleClick = (e: MouseEvent) => {
      if (menuRef.current && !menuRef.current.contains(e.target as Node)) {
        setShowDropdown(false)
      }
    }
    window.addEventListener('click', handleClick)
    return () => window.removeEventListener('click', handleClick)
  }, [])

  const handleClick = (e: React.MouseEvent) => {
    e.stopPropagation()
    if (!ready) return
    if (!authenticated) {
      login()
    } else {
      setShowDropdown(!showDropdown)
    }
  }

  const handleDisconnect = (e: React.MouseEvent) => {
    e.stopPropagation()
    logout()
    setShowDropdown(false)
  }

  const handleCopyAddress = (e: React.MouseEvent) => {
    e.stopPropagation()
    if (!user?.wallet?.address) return
    
    navigator.clipboard.writeText(user.wallet.address)
      .then(() => toast.success('Address copied to clipboard!', {
        autoClose: 2000,
        hideProgressBar: false,
        closeOnClick: true,
        pauseOnHover: true,
        draggable: true,
      }))
      .catch(() => toast.error('Failed to copy address'))
  }

  const statusDotClasses = "w-2 h-2 rounded-full relative after:content-[''] after:absolute after:inset-0 after:rounded-full after:animate-pulse"

  return (
    <div ref={menuRef} className="relative flex justify-end z-50">
      <div className="flex flex-col items-end">
        <button 
          onClick={handleClick}
          className="flex items-center text-base font-mono text-gray-500 hover:text-gray-300 transition-colors"
        >
          <span>{authenticated ? 'connected' : 'connect'}</span>
          <div className="inline-flex items-center ml-[10px]">
            <span className={cn(
              statusDotClasses,
              authenticated 
                ? "bg-green-500 after:bg-green-500/50" 
                : "bg-red-500 after:bg-red-500/50"
            )} />
          </div>
          {authenticated && <ChevronDown className="w-4 h-4 ml-1 opacity-60" />}
        </button>
        
        {showDropdown && (
          <div 
            className="absolute top-full right-0 mt-2 bg-black/90 backdrop-blur-sm rounded-lg p-2 shadow-xl border border-gray-800 min-w-48"
          >
            <div className="flex flex-col space-y-1">
              {/* Portfolio Link */}
              <Link 
                href="/operator/portfolio"
                className="flex items-center gap-3 px-3 py-2 text-sm text-gray-300 hover:text-white hover:bg-gray-800/50 rounded-md transition-colors"
                onClick={() => setShowDropdown(false)}
              >
                <Wallet className="w-4 h-4" />
                <span>portfolio</span>
              </Link>
              
              {/* Divider */}
              <div className="border-t border-gray-700 my-1" />
              
              {/* Address (clickable to copy) */}
              <div 
                onClick={handleCopyAddress}
                className="flex items-center gap-3 px-3 py-2 text-sm text-gray-400 hover:text-gray-200 cursor-pointer rounded-md transition-colors"
                title="Click to copy full address"
              >
                <User className="w-4 h-4" />
                <span className="font-mono">{truncateAddress(user?.wallet?.address)}</span>
              </div>
              
              {/* Disconnect */}
              <button
                onClick={handleDisconnect}
                className="flex items-center justify-end px-3 py-2 text-base font-mono text-gray-300 hover:text-gray-100 hover:bg-gray-800/50 rounded-md transition-colors w-full"
              >
                <span>disconnect</span>
                <div className="inline-flex items-center ml-[10px]">
                  <span className={cn(
                    statusDotClasses,
                    "bg-yellow-500 after:bg-yellow-500/50"
                  )} />
                </div>
              </button>
            </div>
          </div>
        )}
      </div>
    </div>
  )
}
````

## File: src/components/layout/DeclarativeHero.tsx
````typescript
export function DeclarativeHero() {
  return (
    <section className="relative z-10 pt-12 pb-8">
      <div className="bg-gradient-to-b from-transparent via-[rgba(var(--background-rgb),0.95)] to-[rgb(var(--background-rgb))] backdrop-blur-sm">
        <div className="container mx-auto px-4">
          <div className="max-w-2xl mx-auto pt-6 pb-2 text-center space-y-4">
            <h1 className="text-5xl font-bold font-grotesk">
              ensurance
            </h1>
            <p className="text-2xl font-grotesk">
              ensuring the stocks & flows of natural capital
            </p>
          </div>
        </div>
      </div>
    </section>
  )
}
````

## File: src/components/layout/DeclarativeSection.tsx
````typescript
export function DeclarativeSection() {
  return (
    <section className="relative z-10 pt-8 pb-20">
      <div className="bg-[rgb(var(--background-rgb))]">
        <div className="container mx-auto px-4">
          <div className="max-w-2xl mx-auto text-xl text-[rgba(var(--foreground-rgb),0.85)] leading-relaxed text-center space-y-8">
            <p>
              the foundation of all wealth—physical, financial, and spiritual—depends on nature.
            </p>
            <p>
              natural capital ensurance, by basin, transforms how we value and fund nature—securing the benefits it provides to all beings.
            </p>
            <p>
              ensurance investments protect natural assets, fund 15 critical ecosystems, 19 vital ecosystem services, and support the people who care for them.
            </p>
            <p className="text-xl font-bold mt-14 tracking-wide">
              ⚡ reduced risk · increased resilience · greater well-being ⚡
            </p>
          </div>
        </div>
      </div>
    </section>
  )
}
````

## File: src/components/layout/EnsureButtonsGeneral.tsx
````typescript
'use client'

import { PlusCircle, RefreshCw, Flame, ChevronDown, Send } from 'lucide-react'
import { usePrivy, useWallets } from '@privy-io/react-auth'
import { useGeneralService } from '@/modules/general/service/hooks'
import { useState, useEffect, useCallback, useMemo } from 'react'
import { 
  parseEther, 
  formatEther,
  type Address,
  createWalletClient,
  custom,
  http,
  createPublicClient,
  type PublicClient,
  type WalletClient,
  concat,
  numberToHex,
  toHex,
  encodeFunctionData,
  maxUint256
} from 'viem'
import { base } from 'viem/chains'
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"
import { Input } from "@/components/ui/input"
import { Button } from "@/components/ui/button"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import {
  Tooltip,
  TooltipProvider,
  TooltipTrigger,
  TooltipContent,
} from "@/components/ui/tooltip"
import ZORA_COIN_ABI from '@/abi/ZoraCoin.json'
import { toast } from 'react-toastify'
import Image from 'next/image'
import { useDebounce } from '@/hooks/useDebounce'
import { executeSwap } from '@/modules/0x/executeSwap'
import AccountImage from '@/modules/accounts/AccountImage'

interface TokenInfo {
  symbol: string
  address: Address
  decimals: number
  balance?: string
  type?: 'native' | 'currency' | 'certificate'
  imageUrl?: string
}

// Add interface for account search results
interface AccountSearchResult {
  name: string
  path: string
  type: 'account'
  is_agent: boolean
  is_ensurance: boolean
  token_id: number
}

// Add intermediate type for mapped tokens
interface MappedToken {
  symbol: string
  address: Address
  decimals: number
  type: 'currency' | 'certificate'
}

interface EnsureButtonsGeneralProps {
  contractAddress: Address
  showMinus?: boolean
  showBurn?: boolean
  showSend?: boolean
  size?: 'sm' | 'lg'
  imageUrl?: string
  showBalance?: boolean
  tokenName?: string
}

// Update trade type to be a union of all possible values
type TradeType = 'buy' | 'sell' | 'burn' | 'send'

const PERMIT2_ADDRESS = '0x000000000022D473030F116dDEE9F6B43aC78BA3'

// Add formatNumber helper function at the top level
const formatNumber = (num: number, decimals: number = 18) => {
  if (num === 0) return '0'
  if (num < 0.000001) return '< 0.000001'
  
  // For tokens with lower decimals (like USDC), show more precise amounts
  if (decimals <= 8) {
    if (num < 0.01) return num.toFixed(6)
    if (num < 1) return num.toFixed(4)
    return num.toLocaleString('en-US', {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    })
  }
  
  // For tokens with high decimals (like ETH)
  if (num < 0.01) return num.toFixed(6)
  if (num < 1) return num.toFixed(4)
  if (num < 1000) {
    const fixed = num.toFixed(2)
    return fixed.endsWith('.00') ? fixed.slice(0, -3) : fixed
  }
  return num.toLocaleString('en-US', { maximumFractionDigits: 0 })
}

const formatTokenBalance = (balance: string | undefined, decimals: number): number => {
  if (!balance) return 0
  const divisor = Math.pow(10, decimals)
  return Number(BigInt(balance)) / divisor
}

// Add these utility functions before the component
const CACHE_KEY = 'token_images_cache'
const CACHE_EXPIRY = 3600000 // 1 hour in milliseconds

interface CachedImage {
  url: string
  timestamp: number
}

const getFromCache = (address: string): string | null => {
  try {
    const cache = localStorage.getItem(CACHE_KEY)
    if (!cache) return null

    const images = JSON.parse(cache) as Record<string, CachedImage>
    const cached = images[address]

    if (!cached) return null

    // Check if cache is expired
    if (Date.now() - cached.timestamp > CACHE_EXPIRY) {
      return null
    }

    return cached.url
  } catch (error) {
    console.error('Error reading from cache:', error)
    return null
  }
}

const saveToCache = (address: string, url: string) => {
  try {
    const cache = localStorage.getItem(CACHE_KEY)
    const images = cache ? JSON.parse(cache) : {}
    
    images[address] = {
      url,
      timestamp: Date.now()
    }

    localStorage.setItem(CACHE_KEY, JSON.stringify(images))
  } catch (error) {
    console.error('Error saving to cache:', error)
  }
}

// Add parseAmount helper function before executeSwap
const parseAmount = (amount: string, decimals: number = 18): bigint => {
  // Remove commas from the amount string
  const cleanAmount = amount.replace(/,/g, '')
  // Convert to base units
  const [whole, fraction = ''] = cleanAmount.split('.')
  const paddedFraction = fraction.padEnd(decimals, '0')
  const trimmedFraction = paddedFraction.slice(0, decimals)
  const combined = whole + trimmedFraction
  return BigInt(combined)
}

// Add helper function for truncating addresses
const truncateAddress = (address: string) => {
  if (!address) return ''
  return `${address.slice(0, 6)}...${address.slice(-4)}`
}

export function EnsureButtonsGeneral({ 
  contractAddress,
  showMinus = true,
  showBurn = false,
  showSend = true,
  size = 'lg',
  imageUrl = '/assets/no-image-found.png',
  showBalance = true,
  tokenName
}: EnsureButtonsGeneralProps) {
  const { login, authenticated } = usePrivy()
  const { wallets } = useWallets()
  const { userAddress } = useGeneralService()
  const [isLoading, setIsLoading] = useState(false)
  const [modalOpen, setModalOpen] = useState(false)
  const [tradeType, setTradeType] = useState<TradeType>('buy')
  const [amount, setAmount] = useState('')
  const [formattedAmount, setFormattedAmount] = useState('')
  const [tokenBalance, setTokenBalance] = useState<bigint>(BigInt(0))
  const [tokenSymbol, setTokenSymbol] = useState<string>('')
  const debouncedAmount = useDebounce(amount, 500)
  const [selectedToken, setSelectedToken] = useState<TokenInfo | null>(null)
  const [availableTokens, setAvailableTokens] = useState<TokenInfo[]>([])
  const [estimatedOutput, setEstimatedOutput] = useState<string>('0')
  const [isSimulating, setIsSimulating] = useState(false)
  const [isApproving, setIsApproving] = useState(false)
  const [isLoadingTokens, setIsLoadingTokens] = useState(false)
  const [amountError, setAmountError] = useState<string>('')
  const [tokenImages, setTokenImages] = useState<Record<string, string>>({})
  const [accountSearchQuery, setAccountSearchQuery] = useState('')
  const [accountSearchResults, setAccountSearchResults] = useState<AccountSearchResult[]>([])
  const [isSearching, setIsSearching] = useState(false)
  const [selectedAccount, setSelectedAccount] = useState<AccountSearchResult | null>(null)
  const debouncedAccountSearch = useDebounce(accountSearchQuery, 300)

  // Create a single publicClient instance
  const publicClient = useMemo(() => createPublicClient({
    chain: base,
    transport: http()
  }), [])

  // Add effect to fetch token details
  useEffect(() => {
    const fetchTokenDetails = async () => {
      if (!contractAddress || !modalOpen) return
      
      try {
        const symbol = await publicClient.readContract({
          address: contractAddress,
          abi: ZORA_COIN_ABI,
          functionName: 'symbol'
        }) as string
        
        setTokenSymbol(symbol)
      } catch (error) {
        console.error('Error fetching token details:', error)
      }
    }

    fetchTokenDetails()
  }, [contractAddress, modalOpen, publicClient])

  // Add effect to fetch token balance when needed
  useEffect(() => {
    const fetchBalance = async () => {
      if (!contractAddress || !userAddress) {
        console.log('Skipping balance fetch - missing address:', { contractAddress, userAddress })
        return
      }
      
      // Fetch balance if we're showing it or if it's needed for the modal
      if (showBalance || (modalOpen && (tradeType === 'sell' || tradeType === 'burn'))) {
        try {
          console.log('Fetching balance for:', { contractAddress, userAddress, showBalance, modalOpen, tradeType })
          const balance = await publicClient.readContract({
            address: contractAddress,
            abi: ZORA_COIN_ABI,
            functionName: 'balanceOf',
            args: [userAddress]
          }) as bigint
          console.log('Balance fetched:', formatEther(balance))
          setTokenBalance(balance)
        } catch (error) {
          console.error('Error fetching balance:', error)
        }
      } else {
        console.log('Skipping balance fetch - conditions not met:', { showBalance, modalOpen, tradeType })
      }
    }

    fetchBalance()
  }, [contractAddress, userAddress, modalOpen, showBalance, tradeType, publicClient])

  const handleOpenModal = async (type: TradeType) => {
    if (!authenticated) {
      login()
      return
    }
    
    // Reset all states
    setAmount('')
    setFormattedAmount('')
    setEstimatedOutput('0')
    setSelectedToken(null)
    setAmountError('')
    setIsSimulating(false)
    setAccountSearchQuery('')
    setAccountSearchResults([])
    setIsSearching(false)
    setSelectedAccount(null)
    
    // Then set new type and open modal
    setTradeType(type)
    setModalOpen(true)
    
    try {
      if (authenticated && userAddress) {
        setIsLoadingTokens(true)
        try {
          // Get all supported tokens first (needed for both buy and sell)
          const [currenciesRes, certificatesRes] = await Promise.all([
            fetch('/api/currencies'),
            fetch('/api/general')
          ])

          if (!currenciesRes.ok || !certificatesRes.ok) {
            throw new Error('Failed to fetch supported tokens')
          }

          const [currencies, certificates] = await Promise.all([
            currenciesRes.json(),
            certificatesRes.json()
          ])

          if (type === 'buy') {
            // Create a map of supported token addresses (lowercase for comparison)
            const supportedTokens = new Set([
              ...currencies.map((c: any) => c.address.toLowerCase()),
              ...certificates.map((c: any) => c.contract_address.toLowerCase())
            ])

            // Get operator's wallet balances from Alchemy
            const alchemyRes = await fetch(`/api/alchemy/fungible?address=${userAddress}`)
            if (!alchemyRes.ok) throw new Error('Failed to fetch wallet balances')
            
            const alchemyData = await alchemyRes.json()
            
            // Filter and map tokens
            const tokens: TokenInfo[] = alchemyData.data.tokens
              .filter((t: any) => {
                // Always include ETH
                if (!t.tokenAddress) return true
                // For other tokens:
                // 1. Must be in supported list
                // 2. Must not be the destination token
                return supportedTokens.has(t.tokenAddress.toLowerCase()) &&
                       t.tokenAddress.toLowerCase() !== contractAddress.toLowerCase()
              })
              .map((t: any): TokenInfo | null => {
                // Handle native ETH
                if (!t.tokenAddress) {
                  return {
                    symbol: 'ETH',
                    address: '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE' as Address,
                    decimals: 18,
                    balance: t.tokenBalance,
                    type: 'native'
                  }
                }
                // Handle other tokens
                if (t.tokenMetadata?.decimals != null && t.tokenMetadata?.symbol) {
                  // Find token type from supported lists
                  const isCurrency = currencies.some((c: any) => 
                    c.address.toLowerCase() === t.tokenAddress.toLowerCase()
                  )
                  return {
                    symbol: t.tokenMetadata.symbol,
                    address: t.tokenAddress as Address,
                    decimals: t.tokenMetadata.decimals,
                    balance: t.tokenBalance,
                    type: isCurrency ? 'currency' : 'certificate'
                  }
                }
                return null
              })
              .filter((t: TokenInfo | null): t is TokenInfo => t !== null)
              .sort((a: TokenInfo, b: TokenInfo) => {
                // Always put ETH first
                const ETH_ADDRESS = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE'.toLowerCase()
                if (a.address.toLowerCase() === ETH_ADDRESS) return -1
                if (b.address.toLowerCase() === ETH_ADDRESS) return 1

                // Then sort by type: currencies before certificates
                if (a.type !== b.type) {
                  if (a.type === 'currency') return -1
                  if (b.type === 'currency') return 1
                }

                // Within same type, sort by balance first
                const balanceA = formatTokenBalance(a.balance, a.decimals)
                const balanceB = formatTokenBalance(b.balance, b.decimals)
                if (Math.abs(balanceB - balanceA) > 0.000001) { // Use small epsilon for float comparison
                  return balanceB - balanceA
                }

                // If balances are effectively equal, sort by symbol
                return a.symbol.localeCompare(b.symbol)
              })

            setAvailableTokens(tokens)
            // Set initial selected token to ETH if available
            const ethToken = tokens.find((t) => t.type === 'native')
            if (ethToken) {
              setSelectedToken(ethToken)
            }
          } else if (type === 'sell') {
            // For sell/transform, show all supported tokens as targets
            const tokens: TokenInfo[] = [
              // Add native ETH first
              {
                symbol: 'ETH',
                address: '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE' as Address,
                decimals: 18,
                type: 'native'
              },
              // Add currencies sorted by symbol
              ...currencies
                .map((c: any) => ({
                  symbol: c.symbol,
                  address: c.address as Address,
                  decimals: c.decimals,
                  type: 'currency' as const
                }))
                .sort((a: MappedToken, b: MappedToken) => a.symbol.localeCompare(b.symbol)),
              // Add certificates (except the current one) sorted by symbol
              ...certificates
                .filter((c: any) => c.contract_address.toLowerCase() !== contractAddress.toLowerCase())
                .map((c: any) => ({
                  symbol: c.symbol,
                  address: c.contract_address as Address,
                  decimals: 18, // Certificates are always 18 decimals
                  type: 'certificate' as const
                }))
                .sort((a: MappedToken, b: MappedToken) => a.symbol.localeCompare(b.symbol))
            ]

            setAvailableTokens(tokens)
            // Set initial selected token to ETH
            setSelectedToken(tokens[0])
          }
        } catch (error) {
          console.error('Error fetching tokens:', error)
          toast.error('Failed to load available tokens')
        } finally {
          setIsLoadingTokens(false)
        }
      }
    } catch (error) {
      console.error('Error opening modal:', error)
      toast.error('Failed to open modal')
    }
  }

  // Add validation for amount against balance
  const validateAmount = (value: string) => {
    if (!value) {
      setAmountError('')
      return
    }
    
    try {
      if (tradeType === 'buy' && selectedToken?.balance) {
        // For buy, check selected token's balance
        const decimals = getTokenDecimals(selectedToken)
        const inputAmount = BigInt(Math.floor(Number(value) * Math.pow(10, decimals)))
        const currentBalance = BigInt(selectedToken.balance)
        
        if (inputAmount > currentBalance) {
          setAmountError('Insufficient balance')
        } else {
          setAmountError('')
        }
      } else if (tradeType === 'sell' || tradeType === 'burn') {
        // For sell/burn, check token balance
        const inputAmount = parseEther(value)
        if (inputAmount > tokenBalance) {
          setAmountError('Insufficient balance')
        } else {
          setAmountError('')
        }
      }
    } catch (error) {
      setAmountError('Invalid amount')
    }
  }

  // Add effect to validate amount when selected token changes
  useEffect(() => {
    if (amount && selectedToken) {
      validateAmount(amount)
    }
  }, [selectedToken, amount])

  // Modify handleAmountChange to respect token decimals
  const handleAmountChange = (value: string) => {
    // Remove existing commas first
    const withoutCommas = value.replace(/,/g, '')
    
    // Only allow numbers and one decimal point
    const cleanValue = withoutCommas.replace(/[^\d.]/g, '')
    
    // Prevent multiple decimal points
    const decimalCount = (cleanValue.match(/\./g) || []).length
    if (decimalCount > 1) return

    // Get max decimals based on token
    const maxDecimals = tradeType === 'buy' && selectedToken 
      ? selectedToken.decimals 
      : 18

    // Handle decimal places
    if (cleanValue.includes('.')) {
      const [whole, fraction] = cleanValue.split('.')
      // Limit decimal places to token's decimals
      if (fraction.length > maxDecimals) return
    }

    // Store the clean value for calculations
    setAmount(cleanValue)
    validateAmount(cleanValue)

    // Format with commas for display
    if (cleanValue) {
      const parts = cleanValue.split('.')
      const integerPart = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ',')
      const formattedValue = parts.length > 1 
        ? `${integerPart}.${parts[1]}`
        : integerPart
      setFormattedAmount(formattedValue)
    } else {
      setFormattedAmount('')
    }
  }

  // Add helper function for token decimals
  const getTokenDecimals = (token: TokenInfo | null) => {
    if (!token) return 18 // Default to 18 decimals
    if (token.symbol === 'USDC') return 6
    if (token.decimals) return token.decimals
    return 18 // Default for most tokens
  }

  // Add helper function to check if address is ETH
  const isEthAddress = (address: string): boolean => {
    return address.toLowerCase() === '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE'.toLowerCase()
  }

  // Modify getQuote useEffect
  useEffect(() => {
    const getQuote = async () => {
      if (!authenticated || 
          !selectedToken || 
          !debouncedAmount || 
          !userAddress || 
          Number(debouncedAmount) <= 0 ||
          !modalOpen ||
          tradeType === 'send' || // Skip quote for send operations
          tradeType === 'burn') { // Skip quote for burn operations
        setEstimatedOutput('0')
        return
      }

      // Check balance before proceeding
      try {
        // Convert amount based on token decimals
        const rawAmount = Number(debouncedAmount.replace(/[^\d.]/g, ''))
        if (isNaN(rawAmount)) {
          setEstimatedOutput('0')
          return
        }

        let sellAmountWei: string
        if (tradeType === 'buy' && selectedToken) {
          // For buy, use selected token's decimals
          const multiplier = Math.pow(10, selectedToken.decimals)
          sellAmountWei = BigInt(Math.floor(rawAmount * multiplier)).toString()
        } else {
          // For selling our token (always 18 decimals)
          sellAmountWei = parseEther(debouncedAmount).toString()
        }

        // Balance checks
        if (tradeType === 'buy') {
          if (selectedToken.address.toLowerCase() === '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE'.toLowerCase()) {
            const ethBalance = await publicClient.getBalance({ address: userAddress })
            if (BigInt(sellAmountWei) > ethBalance) {
              setEstimatedOutput('0')
              return
            }
          } else if (selectedToken.balance && BigInt(selectedToken.balance) < BigInt(sellAmountWei)) {
            setEstimatedOutput('0')
            return
          }
        } else if (tradeType === 'sell' && BigInt(sellAmountWei) > tokenBalance) {
          setEstimatedOutput('0')
          return
        }

        setIsSimulating(true)
        try {
          console.log('Quote request:', {
            tradeType,
            sellToken: tradeType === 'buy' ? selectedToken?.address : contractAddress,
            buyToken: tradeType === 'buy' ? contractAddress : selectedToken?.address,
            sellAmount: sellAmountWei,
            taker: userAddress,
            tokenSymbol: selectedToken?.symbol,
            decimals: selectedToken?.decimals
          })

          // Use our backend proxy with correct parameter names
          const params = new URLSearchParams({
            action: 'quote',
            sellToken: tradeType === 'buy' ? selectedToken?.address : contractAddress,
            buyToken: tradeType === 'buy' ? contractAddress : selectedToken?.address,
            sellAmount: sellAmountWei,
            taker: userAddress,
            swapFeeToken: tradeType === 'buy' ? selectedToken?.address : contractAddress,
            slippageBps: '200', // 2% slippage
            swapFeeBps: '100'   // 1% fee
          })

          const response = await fetch(`/api/0x?${params}`)
          if (!response.ok) {
            const errorData = await response.json()
            console.error('Quote error details:', errorData)
            
            // Handle v2 API error structure
            const details = errorData.details || {};
            if (details.validationErrors?.length > 0) {
              toast.error(`Invalid trade parameters: ${details.validationErrors[0]}`);
            } else if (details.code === 'INSUFFICIENT_LIQUIDITY') {
              toast.error('Insufficient liquidity for this trade.');
            } else if (details.code === 'INVALID_TOKEN') {
              toast.error('One or more tokens are not supported.');
            } else if (details.code === 'INSUFFICIENT_BALANCE') {
              toast.error('Insufficient balance for this trade.');
            } else {
              toast.error(details.message || errorData.error || 'Failed to get quote')
            }
            setEstimatedOutput('0')
            return
          }
          
          const data = await response.json()
          console.log('Quote response:', data)

          // Check for liquidity first
          if (!data.liquidityAvailable) {
            console.log('No liquidity available for this trade')
            toast.error('Insufficient liquidity for this trade amount')
            setEstimatedOutput('0')
            return
          }
          
          // Handle v2 API response format
          if (data.buyAmount) {
            // Get the decimals for the output token
            const decimals = tradeType === 'buy' ? 18 : selectedToken.decimals
            
            // Convert to proper decimal representation
            const rawAmount = BigInt(data.buyAmount)
            const amount = Number(rawAmount) / Math.pow(10, decimals)
            
            console.log('Raw amount:', rawAmount.toString())
            console.log('Decimals:', decimals)
            console.log('Converted amount:', amount)
            
            // Format the amount using our new utility
            const formattedAmount = formatNumber(amount, decimals)
            
            console.log('Final formatted amount:', formattedAmount)
            setEstimatedOutput(formattedAmount)
          } else {
            console.error('Unexpected quote response format:', data)
            toast.error('Received invalid quote response')
            setEstimatedOutput('0')
          }
        } catch (error) {
          console.error('Error getting quote:', error)
          toast.error(error instanceof Error ? error.message : 'Failed to get price quote')
          setEstimatedOutput('0')
        } finally {
          setIsSimulating(false)
        }
      } catch (error) {
        console.error('Error checking balance:', error)
        setEstimatedOutput('0')
        return
      }
    }

    getQuote()
  }, [debouncedAmount, selectedToken, authenticated, userAddress, contractAddress, tradeType, modalOpen])

  // Only log estimatedOutput changes when modal is open
  useEffect(() => {
    if (modalOpen) {
      console.log('estimatedOutput changed:', estimatedOutput)
    }
  }, [estimatedOutput, modalOpen])

  // Add these utility functions before the component
  const fetchTokenImage = useCallback(async (address: string): Promise<string | null> => {
    // Check cache first
    const cached = getFromCache(address)
    if (cached) return cached

    try {
      const response = await fetch(`/api/utilities/image?address=${address}`)
      const data = await response.json()
      if (data.url) {
        // Save to cache
        saveToCache(address, data.url)
        return data.url
      }
    } catch (error) {
      console.error('Error fetching token image:', error)
    }
    return null
  }, [])

  useEffect(() => {
    const fetchImages = async () => {
      // Only fetch for tokens we don't have images for yet
      const tokensToFetch = availableTokens.filter(
        token => !tokenImages[token.address]
      )

      if (tokensToFetch.length === 0) return

      // Batch requests in groups of 5
      const batchSize = 5
      for (let i = 0; i < tokensToFetch.length; i += batchSize) {
        const batch = tokensToFetch.slice(i, i + batchSize)
        
        // Fetch images in parallel
        const results = await Promise.all(
          batch.map(token => fetchTokenImage(token.address))
        )

        // Update state with new images
        setTokenImages(prev => {
          const newImages = { ...prev }
          batch.forEach((token, index) => {
            if (results[index]) {
              newImages[token.address] = results[index]!
            }
          })
          return newImages
        })
      }
    }

    if (availableTokens.length > 0) {
      fetchImages()
    }
  }, [availableTokens, fetchTokenImage])

  const handleTrade = async () => {
    if (!authenticated || !userAddress) {
      login()
      return
    }

    const pendingToast = toast.loading('setting everything up...')

    try {
      setIsLoading(true)
      const activeWallet = wallets[0]
      if (!activeWallet) {
        toast.dismiss(pendingToast)
        toast.error('No wallet connected')
        return
      }

      const provider = await activeWallet.getEthereumProvider()

      if (tradeType === 'send') {
        if (!selectedToken?.address) {
          toast.dismiss(pendingToast)
          toast.error('Please enter a recipient address')
          return
        }

        const tokenAmountInWei = parseEther(amount)
        if (tokenAmountInWei > tokenBalance) {
          toast.dismiss(pendingToast)
          toast.error('Insufficient token balance')
          return
        }

        try {
          toast.update(pendingToast, {
            render: 'confirming transfer...',
            type: 'info',
            isLoading: true
          })

          const walletClient = createWalletClient({
            chain: base,
            transport: custom(provider)
          })

          // Use the selected account's TBA address as the recipient
          const recipientAddress = selectedToken.address

          const hash = await walletClient.writeContract({
            address: contractAddress,
            abi: ZORA_COIN_ABI,
            functionName: 'transfer',
            args: [recipientAddress, tokenAmountInWei],
            chain: base,
            account: userAddress as `0x${string}`
          })
          
          await publicClient.waitForTransactionReceipt({ hash })
          
          toast.update(pendingToast, {
            render: 'transfer successful',
            type: 'success',
            isLoading: false,
            autoClose: 5000,
            className: '!bg-amber-500/20 !text-amber-200 !border-amber-500/30'
          })
          
          setModalOpen(false)
          return
        } catch (error: any) {
          console.error('Transfer failed:', error)
          if (error?.code === 4001 || error?.message?.includes('rejected')) {
            toast.dismiss(pendingToast)
            toast.error('transaction cancelled')
          } else {
            toast.update(pendingToast, {
              render: 'transfer failed',
              type: 'error',
              isLoading: false,
              autoClose: 5000
            })
          }
          return
        }
      } else if (tradeType === 'burn') {
        const tokenAmountInWei = parseEther(amount)
        if (tokenAmountInWei > tokenBalance) {
          toast.dismiss(pendingToast)
          toast.error('Insufficient token balance')
          return
        }

        try {
          toast.update(pendingToast, {
            render: 'confirming burn...',
            type: 'info',
            isLoading: true
          })

          const walletClient = createWalletClient({
            chain: base,
            transport: custom(provider)
          })

          const hash = await walletClient.writeContract({
            address: contractAddress,
            abi: ZORA_COIN_ABI,
            functionName: 'burn',
            args: [tokenAmountInWei],
            chain: base,
            account: userAddress as `0x${string}`
          })
          
          await publicClient.waitForTransactionReceipt({ hash })
          
          toast.update(pendingToast, {
            render: 'tokens burned successfully',
            type: 'success',
            isLoading: false,
            autoClose: 5000,
            className: '!bg-orange-500/20 !text-orange-200 !border-orange-500/30'
          })
          
          setModalOpen(false)
          return
        } catch (error: any) {
          console.error('Burn failed:', error)
          if (error?.code === 4001 || error?.message?.includes('rejected')) {
            toast.dismiss(pendingToast)
            toast.error('transaction cancelled')
          } else {
            toast.update(pendingToast, {
              render: 'burn failed',
              type: 'error',
              isLoading: false,
              autoClose: 5000
            })
          }
          return
        }
      } else {
        // For buy/sell, need selected token
        if (!selectedToken) {
          toast.dismiss(pendingToast)
          toast.error('Please select a token')
          return
        }

        const sellToken = tradeType === 'buy' ? selectedToken.address : contractAddress
        const buyToken = tradeType === 'buy' ? contractAddress : selectedToken.address

        try {
          // Execute the swap using our updated function (no direct SDK calls)
          const result = await executeSwap({
            sellToken,
            buyToken,
            amount: tradeType === 'buy' 
              ? (selectedToken?.decimals 
                ? parseAmount(amount, selectedToken.decimals).toString()
                : parseEther(amount).toString())
              : parseEther(amount).toString(), // For selling, we use 18 decimals as it's our token
            userAddress,
            provider,
            onStatus: (message, type = 'info') => {
              toast.update(pendingToast, {
                render: message,
                type,
                isLoading: type === 'info'
              })
            }
          })

          // Check if result indicates success
          if (!result.success) {
            console.error('Swap returned without success flag:', result);
            toast.update(pendingToast, {
              render: 'Transaction may have encountered issues',
              type: 'warning',
              isLoading: false,
              autoClose: 5000
            });
            setModalOpen(false);
            return;
          }

          // Get the token symbols for the message
          const toSymbol = String(tradeType === 'buy' ? tokenSymbol : selectedToken?.symbol ?? 'tokens')
          const fromSymbol = String(tradeType === 'buy' ? selectedToken?.symbol ?? 'tokens' : tokenSymbol)
          
          const successMessage = tradeType === 'buy' 
            ? 'success! you have ensured what matters'
            : `success! ${fromSymbol} transformed to ${toSymbol}`

          // Create HTML content for toast with transaction link
          const toastContent = (
            <div>
              <div>{successMessage}</div>
              <a 
                href={`https://basescan.org/tx/${result.txHash}`}
                target="_blank"
                rel="noopener noreferrer"
                className="text-sm text-blue-400 hover:text-blue-300 underline mt-1 block"
              >
                View transaction
              </a>
            </div>
          )

          toast.update(pendingToast, {
            render: toastContent,
            type: 'success',
            isLoading: false,
            autoClose: 5000
          })

          // Refresh balances after successful transaction
          const fetchBalances = async () => {
            if (!userAddress) return
            try {
              const publicClient = createPublicClient({
                chain: base,
                transport: http()
              })
              const balance = await publicClient.readContract({
                address: contractAddress,
                abi: ZORA_COIN_ABI,
                functionName: 'balanceOf',
                args: [userAddress]
              }) as bigint
              setTokenBalance(balance)
            } catch (error) {
              console.error('Failed to refresh balance:', error)
            }
          }
          fetchBalances()

          setModalOpen(false)
        } catch (error: any) {
          console.error('Trade failed:', error)
          toast.dismiss(pendingToast)
          
          // Handle different error types
          const errorMessage = error?.message || 'Failed to execute trade';
          
          // Create a more user-friendly error message
          let userMessage = errorMessage;
          
          if (error?.code === 4001 || errorMessage.includes('rejected')) {
            userMessage = 'Transaction cancelled';
          } else if (errorMessage.includes('failed on-chain')) {
            userMessage = 'Transaction failed on-chain. This may be due to slippage or contract issues.';
          } else if (errorMessage.includes('insufficient funds')) {
            userMessage = 'Insufficient funds to complete this transaction';
          } else if (errorMessage.includes('gas')) {
            userMessage = 'Transaction failed due to gas estimation issues';
          }
          
          toast.error(userMessage);
        }
      }
    } catch (error: any) {
      console.error('Trade failed:', error)
      toast.dismiss(pendingToast)
      if (error?.code === 4001 || error?.message?.includes('rejected')) {
        toast.error('Transaction cancelled')
      } else {
        toast.error(error?.message || 'Failed to execute trade')
      }
    } finally {
      setIsLoading(false)
    }
  }

  const iconSize = size === 'sm' ? 'w-6 h-6' : 'w-10 h-10'

  // Update formatBalance to use the new helper
  const formatBalance = (balance: bigint) => {
    if (balance === BigInt(0)) return '0'
    return formatNumber(Number(formatEther(balance)))
  }

  // Format input value with appropriate decimals
  const formatInputValue = (value: string) => {
    const num = Number(value)
    if (num === 0 || isNaN(num)) return '0'
    
    if (num < 1) {
      return num.toLocaleString('en-US', {
        minimumFractionDigits: 0,
        maximumFractionDigits: 6
      })
    } else if (num < 1000) {
      return num.toLocaleString('en-US', {
        minimumFractionDigits: 0,
        maximumFractionDigits: 4
      })
    } else {
      return num.toLocaleString('en-US', {
        minimumFractionDigits: 0,
        maximumFractionDigits: 2
      })
    }
  }

  // Add effect for account search
  useEffect(() => {
    const searchAccounts = async () => {
      if (!debouncedAccountSearch || debouncedAccountSearch.length < 2) {
        setAccountSearchResults([])
        return
      }

      setIsSearching(true)
      try {
        const response = await fetch(`/api/search?q=${encodeURIComponent(debouncedAccountSearch)}`)
        if (!response.ok) throw new Error('Search failed')
        
        const data = await response.json()
        // Filter to only account results
        const accountResults = data.filter((item: any) => item.type === 'account')
        setAccountSearchResults(accountResults)
      } catch (error) {
        console.error('Error searching accounts:', error)
        setAccountSearchResults([])
      } finally {
        setIsSearching(false)
      }
    }

    searchAccounts()
  }, [debouncedAccountSearch])

  // Add effect to fetch tba_address when account is selected
  useEffect(() => {
    const fetchAccountDetails = async () => {
      if (!selectedAccount) return

      try {
        const response = await fetch(`/api/accounts/${encodeURIComponent(selectedAccount.name)}`)
        if (!response.ok) throw new Error('Failed to fetch account details')
        
        const data = await response.json()
        if (data.tba_address) {
          setSelectedToken({ 
            address: data.tba_address as Address,
            symbol: selectedAccount.name,
            decimals: 18,
            type: 'native'
          })
        }
      } catch (error) {
        console.error('Error fetching account details:', error)
        toast.error('Failed to fetch account details')
      }
    }

    fetchAccountDetails()
  }, [selectedAccount])

  return (
    <>
      <div className="flex gap-8">
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <button
                onClick={() => handleOpenModal('buy')}
                className="flex items-center gap-2 text-gray-300 hover:text-gray-100 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
              >
                <PlusCircle className={`${iconSize} stroke-[1.5] stroke-green-500 hover:stroke-green-400 transition-colors`} />
              </button>
            </TooltipTrigger>
            <TooltipContent>
              <p>ensure (buy)</p>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>

        {showMinus && (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <button
                  onClick={() => handleOpenModal('sell')}
                  className="flex items-center gap-2 text-gray-300 hover:text-gray-100 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  <RefreshCw className={`${iconSize} stroke-[1.5] stroke-blue-500 hover:stroke-blue-400 transition-colors`} />
                </button>
              </TooltipTrigger>
              <TooltipContent>
                <p>transform (swap)</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        )}

        {showBurn && (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <button
                  onClick={() => handleOpenModal('burn')}
                  className="flex items-center gap-2 text-gray-300 hover:text-gray-100 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  <Flame className={`${iconSize} stroke-[1.5] stroke-orange-500 hover:stroke-orange-400 transition-colors`} />
                </button>
              </TooltipTrigger>
              <TooltipContent>
                <p>burn</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        )}

        {showSend && (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <button
                  onClick={() => handleOpenModal('send')}
                  className="flex items-center gap-2 text-gray-300 hover:text-gray-100 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  <Send className={`${iconSize} stroke-[1.5] stroke-amber-500 hover:stroke-amber-400 transition-colors`} />
                </button>
              </TooltipTrigger>
              <TooltipContent>
                <p>send</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        )}
      </div>

      {/* Add balance display */}
      {showBalance && (
        <div className="mt-2 text-sm text-gray-400 text-center">
          balance: {formatBalance(tokenBalance)} {tokenSymbol}
        </div>
      )}

      <Dialog open={modalOpen} onOpenChange={setModalOpen}>
        <DialogContent className="sm:max-w-[500px] bg-black/95 border border-gray-800 shadow-xl backdrop-blur-xl">
          <DialogHeader className="border-b border-gray-800 pb-4">
            <div className="flex items-center justify-between">
              <div className="flex flex-col gap-2">
                <DialogTitle className="text-xl font-bold text-white">
                  {tradeType === 'buy' ? 'ensure' : 
                   tradeType === 'sell' ? 'transform' : 
                   tradeType === 'send' ? 'send' :
                   'burn'}
                </DialogTitle>
                <div className="text-3xl font-bold text-white">
                  {tokenName || tokenSymbol || 'Token'}
                </div>
              </div>
              <div className="relative w-20 h-20 rounded-lg overflow-hidden">
                <Image
                  src={imageUrl}
                  alt={tokenSymbol || 'Token'}
                  fill
                  className="object-cover"
                />
              </div>
            </div>
          </DialogHeader>

          <div className="py-6">
            {tokenBalance === BigInt(0) && tradeType !== 'buy' ? (
              // Show guidance when no balance
              <div className="space-y-6 text-center">
                <div className="text-lg text-gray-300">
                  {tradeType === 'sell' 
                    ? 'buy to transform' 
                    : 'buy to burn'}
                </div>
                <Button
                  onClick={() => {
                    setModalOpen(false)
                    setTimeout(() => {
                      handleOpenModal('buy')
                    }, 100)
                  }}
                  className="bg-green-600 hover:bg-green-500"
                >
                  ENSURE NOW
                </Button>
              </div>
            ) : (
              <div className="space-y-6">
                {/* Main content grid */}
                <div className="space-y-4">
                  {/* Amount Input */}
                  <div className="space-y-2">
                    <label className="text-sm font-medium text-gray-300">
                      AMOUNT
                    </label>
                    <Input
                      type="text"
                      value={formattedAmount}
                      onChange={(e) => handleAmountChange(e.target.value)}
                      placeholder="enter amount"
                      className={`bg-gray-900/50 border-gray-800 text-white placeholder:text-gray-500 h-12 text-lg font-medium ${
                        amountError ? 'border-red-500' : ''
                      }`}
                    />
                    {amountError && (
                      <div className="text-sm text-red-500">
                        {amountError}
                      </div>
                    )}
                    {tradeType !== 'buy' && (
                      <div className="text-sm text-gray-400 flex items-center gap-2">
                        <span>your balance: {formatBalance(tokenBalance)}</span>
                        <div className="w-6 h-6 rounded-full overflow-hidden bg-gray-800 flex items-center justify-center">
                          <Image
                            src={imageUrl}
                            alt={tokenSymbol}
                            width={24}
                            height={24}
                            className="object-cover"
                          />
                        </div>
                      </div>
                    )}
                  </div>

                  {/* Token Selection for Buy/Sell */}
                  {(tradeType === 'buy' || tradeType === 'sell') && (
                    <div className="space-y-2">
                      <label className="text-sm font-medium text-gray-300">
                        {tradeType === 'buy' ? 'PAY WITH' : 'TRANSFORM TO'}
                      </label>
                      <Select
                        value={selectedToken?.address}
                        onValueChange={(value) => {
                          const token = availableTokens.find(t => t.address === value)
                          if (token) setSelectedToken(token)
                        }}
                      >
                        <SelectTrigger className="bg-gray-900/50 border-gray-800 text-white h-12 text-lg font-medium">
                          <SelectValue placeholder="Select token" />
                        </SelectTrigger>
                        <SelectContent className="bg-gray-900 border-gray-800">
                          {isLoadingTokens ? (
                            <div className="flex items-center justify-center p-4">
                              <div className="w-5 h-5 border-2 border-gray-400 border-t-transparent rounded-full animate-spin" />
                            </div>
                          ) : (
                            availableTokens.map((token) => (
                              <SelectItem
                                key={token.address}
                                value={token.address}
                                className="text-white hover:bg-gray-800 focus:bg-gray-800"
                              >
                                <div className="flex items-center gap-2">
                                  <div className="w-6 h-6 rounded-full overflow-hidden bg-gray-800 flex items-center justify-center">
                                    {tokenImages[token.address] ? (
                                      <Image
                                        src={tokenImages[token.address]}
                                        alt={token.symbol}
                                        width={24}
                                        height={24}
                                        className="object-cover"
                                      />
                                    ) : (
                                      <div className="w-6 h-6 bg-gray-700 rounded-full" />
                                    )}
                                  </div>
                                  <div className="flex flex-col">
                                    <span className="font-medium">{token.symbol}</span>
                                    {token.balance && (
                                      <span className="text-xs text-gray-400">
                                        Balance: {formatNumber(formatTokenBalance(token.balance, token.decimals), token.decimals)}
                                      </span>
                                    )}
                                  </div>
                                </div>
                              </SelectItem>
                            ))
                          )}
                        </SelectContent>
                      </Select>
                    </div>
                  )}

                  {/* Estimated Output for Buy/Sell */}
                  {(tradeType === 'buy' || tradeType === 'sell') && selectedToken && amount && (
                    <div className="space-y-2">
                      <label className="text-sm font-medium text-gray-300">
                        ESTIMATED OUTPUT
                      </label>
                      <div className="bg-gray-900/50 border border-gray-800 rounded-lg p-4">
                        <div className="flex items-center justify-between">
                          <div className="flex items-center gap-2">
                            <div className="w-6 h-6 rounded-full overflow-hidden bg-gray-800 flex items-center justify-center">
                              <Image
                                src={tradeType === 'buy' ? imageUrl : tokenImages[selectedToken.address] || '/assets/no-image-found.png'}
                                alt={tradeType === 'buy' ? tokenSymbol : selectedToken.symbol}
                                width={24}
                                height={24}
                                className="object-cover"
                              />
                            </div>
                            <span className="text-lg font-medium">
                              {isSimulating ? (
                                <div className="w-5 h-5 border-2 border-gray-400 border-t-transparent rounded-full animate-spin" />
                              ) : (
                                estimatedOutput
                              )}
                            </span>
                          </div>
                          <span className="text-gray-400">{tradeType === 'buy' ? tokenSymbol : selectedToken.symbol}</span>
                        </div>
                      </div>
                    </div>
                  )}

                  {/* Recipient Input for Send */}
                  {tradeType === 'send' && (
                    <div className="space-y-2">
                      <label className="text-sm font-medium text-gray-300">
                        TO
                      </label>
                      <div className="relative">
                        <Input
                          type="text"
                          value={accountSearchQuery}
                          onChange={(e) => {
                            setAccountSearchQuery(e.target.value)
                            setSelectedAccount(null)
                          }}
                          placeholder="Search for an account..."
                          className="w-full bg-gray-900/50 border-gray-800 text-white placeholder:text-gray-500 h-12 text-lg font-medium"
                        />
                        {isSearching && (
                          <div className="absolute right-3 top-1/2 -translate-y-1/2">
                            <div className="w-5 h-5 border-2 border-gray-400 border-t-transparent rounded-full animate-spin" />
                          </div>
                        )}
                        {accountSearchResults.length > 0 && !selectedAccount && (
                          <div className="absolute z-10 w-full mt-1 bg-gray-900 border border-gray-800 rounded-lg shadow-lg max-h-60 overflow-auto">
                            {accountSearchResults.map((result) => (
                              <button
                                key={result.name}
                                onClick={() => {
                                  setSelectedAccount(result)
                                  setAccountSearchQuery(result.name)
                                }}
                                className="w-full px-4 py-2 text-left hover:bg-gray-800 transition-colors flex items-center gap-2"
                              >
                                <div className="w-6 h-6 rounded-full overflow-hidden bg-gray-800 flex items-center justify-center">
                                  <AccountImage
                                    tokenId={result.token_id}
                                    groupName={result.name.split('.')[1]}
                                    variant="circle"
                                    className="w-6 h-6"
                                  />
                                </div>
                                <span className="font-mono">{result.name}</span>
                                {result.is_agent && (
                                  <span className="text-xs px-2 py-1 bg-blue-500/20 text-blue-400 rounded">
                                    agent
                                  </span>
                                )}
                              </button>
                            ))}
                          </div>
                        )}
                      </div>
                      {selectedAccount && selectedToken?.address && (
                        <div className="flex items-center gap-3 mt-2">
                          <div className="flex-1 space-y-1">
                            <div className="text-sm text-gray-400">
                              {selectedAccount.name}
                            </div>
                            <div className="text-xs text-gray-500 font-mono">
                              {truncateAddress(selectedToken.address)}
                            </div>
                          </div>
                          <div className="w-8 h-8 rounded-full overflow-hidden bg-gray-800 flex items-center justify-center">
                            <AccountImage
                              tokenId={selectedAccount.token_id}
                              groupName={selectedAccount.name.split('.')[1]}
                              variant="circle"
                              className="w-8 h-8"
                            />
                          </div>
                        </div>
                      )}
                    </div>
                  )}
                </div>
              </div>
            )}
          </div>

          {/* Action Buttons */}
          <div className="flex justify-end gap-3 pt-6 border-t border-gray-800">
            <Button 
              variant="ghost" 
              onClick={() => setModalOpen(false)}
              className="text-gray-400 hover:text-gray-300"
            >
              Cancel
            </Button>
            <Button
              onClick={handleTrade}
              disabled={isLoading || (tradeType === 'burn' || tradeType === 'send' ? !amount || Number(amount) <= 0 : !selectedToken || !amount || Number(amount) <= 0)}
              className={`min-w-[120px] ${
                tradeType === 'buy' 
                  ? 'bg-green-600 hover:bg-green-500' 
                  : tradeType === 'sell'
                  ? 'bg-blue-600 hover:bg-blue-500'
                  : tradeType === 'send'
                  ? 'bg-amber-600 hover:bg-amber-500'
                  : 'bg-orange-600 hover:bg-orange-500'
              }`}
            >
              {isLoading ? (
                <div className="flex items-center gap-2">
                  <div className="w-4 h-4 border-2 border-white/30 border-t-white rounded-full animate-spin" />
                  <span>Processing...</span>
                </div>
              ) : (
                tradeType === 'buy' ? 'ENSURE' : 
                tradeType === 'sell' ? 'TRANSFORM' : 
                tradeType === 'send' ? 'SEND' :
                'BURN'
              )}
            </Button>
          </div>
        </DialogContent>
      </Dialog>
    </>
  )
}
````

## File: src/components/layout/EnsureButtonsSpecific.tsx
````typescript
'use client'

import { PlusCircle, RefreshCw, Flame, ExternalLink, Send } from 'lucide-react'
import { useState, useEffect } from 'react'
import Image from 'next/image'
import { usePrivy, useWallets } from '@privy-io/react-auth'
import { 
  type Address,
  createWalletClient,
  custom,
  http,
  createPublicClient,
  type PublicClient,
  type WalletClient,
  maxUint256
} from 'viem'
import { base } from 'viem/chains'
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"
import { Input } from "@/components/ui/input"
import { Button } from "@/components/ui/button"
import {
  Tooltip,
  TooltipProvider,
  TooltipTrigger,
  TooltipContent,
} from "@/components/ui/tooltip"
import { toast } from 'react-toastify'
import ZORA_1155_ABI from '@/abi/Zora1155proxy.json'
import ZORA_ERC20_MINTER_ABI from '@/abi/ZoraERC20Minter.json'
import { mintToken } from '@/modules/specific/collect'
import { formatUsdcAmount, parseUsdcAmount, SUPPORTED_TOKENS, CONTRACTS, PERMIT2_ADDRESS } from '@/modules/specific/config'
import AccountImage from '@/modules/accounts/AccountImage'
import { useDebounce } from '@/hooks/useDebounce'

interface EnsureButtonsSpecificProps {
  contractAddress: Address
  tokenId: bigint
  showMinus?: boolean
  showBurn?: boolean
  size?: 'sm' | 'lg'
  imageUrl?: string
  showBalance?: boolean
  tokenName?: string
  tokenSymbol?: string
  maxSupply?: bigint
  totalMinted?: bigint
  pricePerToken?: bigint
  primaryMintActive?: boolean
}

interface AccountSearchResult {
  name: string
  path: string
  type: 'account'
  is_agent: boolean
  is_ensurance: boolean
  token_id: number
}

type TradeType = 'buy' | 'sell' | 'burn' | 'send'

const PROCEEDS_ADDRESS = '0xa187F8CBdd36D63967c33f5BD4dD4B9ECA51270e' as `0x${string}`

// Add helper function for truncating addresses
const truncateAddress = (address: string) => {
  if (!address) return ''
  return `${address.slice(0, 6)}...${address.slice(-4)}`
}

export function EnsureButtonsSpecific({ 
  contractAddress,
  tokenId,
  showMinus = true,
  showBurn = false,
  size = 'lg',
  imageUrl = '/assets/no-image-found.png',
  showBalance = true,
  tokenName,
  tokenSymbol = 'TOKEN',
  maxSupply,
  totalMinted,
  pricePerToken,
  primaryMintActive = false
}: EnsureButtonsSpecificProps) {
  const { login, authenticated, user } = usePrivy()
  const { wallets } = useWallets()
  const [isLoading, setIsLoading] = useState(false)
  const [modalOpen, setModalOpen] = useState(false)
  const [burnModalOpen, setBurnModalOpen] = useState(false)
  const [sendModalOpen, setSendModalOpen] = useState(false)
  const [tradeType, setTradeType] = useState<TradeType>('buy')
  const [amount, setAmount] = useState('')
  const [formattedAmount, setFormattedAmount] = useState('')
  const [amountError, setAmountError] = useState<string>('')
  const [tokenBalance, setTokenBalance] = useState<bigint>(BigInt(0))
  const [usdcBalance, setUsdcBalance] = useState<bigint>(BigInt(0))
  const [sendRecipient, setSendRecipient] = useState('')
  const [sendRecipientError, setSendRecipientError] = useState('')
  const [accountSearchQuery, setAccountSearchQuery] = useState('')
  const [accountSearchResults, setAccountSearchResults] = useState<AccountSearchResult[]>([])
  const [isSearching, setIsSearching] = useState(false)
  const [selectedAccount, setSelectedAccount] = useState<AccountSearchResult | null>(null)
  const debouncedAccountSearch = useDebounce(accountSearchQuery, 300)

  // Create a single publicClient instance
  const publicClient = createPublicClient({
    chain: base,
    transport: http()
  })

  // Function to fetch balances
  const fetchBalances = async () => {
    try {
      const activeWallet = user?.wallet
      if (!activeWallet?.address) return

      // Fetch token balance
      const tokenBalance = await publicClient.readContract({
        address: contractAddress,
        abi: ZORA_1155_ABI,
        functionName: 'balanceOf',
        args: [activeWallet.address, tokenId]
      }) as bigint
      setTokenBalance(tokenBalance)

      // Fetch USDC balance
      const usdcBalance = await publicClient.readContract({
        address: CONTRACTS.usdc,
        abi: [
          {
            inputs: [{ name: 'account', type: 'address' }],
            name: 'balanceOf',
            outputs: [{ type: 'uint256' }],
            stateMutability: 'view',
            type: 'function'
          }
        ],
        functionName: 'balanceOf',
        args: [activeWallet.address as `0x${string}`]
      }) as bigint
      setUsdcBalance(usdcBalance)
    } catch (error) {
      console.error('Error fetching balances:', error)
    }
  }

  // Fetch balances on mount and when wallet changes
  useEffect(() => {
    if (authenticated && user?.wallet?.address) {
      fetchBalances()
    }
  }, [authenticated, user?.wallet?.address])

  // Add account search effect
  useEffect(() => {
    const searchAccounts = async () => {
      if (!debouncedAccountSearch || debouncedAccountSearch.length < 2) {
        setAccountSearchResults([])
        return
      }

      setIsSearching(true)
      try {
        const response = await fetch(`/api/search?q=${encodeURIComponent(debouncedAccountSearch)}`)
        if (!response.ok) throw new Error('Search failed')
        
        const data = await response.json()
        // Filter to only account results
        const accountResults = data.filter((item: any) => item.type === 'account')
        setAccountSearchResults(accountResults)
      } catch (error) {
        console.error('Error searching accounts:', error)
        setAccountSearchResults([])
      } finally {
        setIsSearching(false)
      }
    }

    searchAccounts()
  }, [debouncedAccountSearch])

  // Add effect to fetch tba_address when account is selected
  useEffect(() => {
    const fetchAccountDetails = async () => {
      if (!selectedAccount) return

      try {
        const response = await fetch(`/api/accounts/${encodeURIComponent(selectedAccount.name)}`)
        if (!response.ok) throw new Error('Failed to fetch account details')
        
        const data = await response.json()
        if (data.tba_address) {
          setSendRecipient(data.tba_address)
        }
      } catch (error) {
        console.error('Error fetching account details:', error)
        toast.error('Failed to fetch account details')
      }
    }

    fetchAccountDetails()
  }, [selectedAccount])

  const iconSize = size === 'sm' ? 'w-6 h-6' : 'w-10 h-10'

  const handleOpenModal = (type: TradeType) => {
    if (!authenticated) {
      login()
      return
    }

    if (type === 'buy' && !primaryMintActive) {
      toast.error('This policy is no longer issuing certificates')
      return
    }

    // Reset states
    setAmount('')
    setFormattedAmount('')
    setAmountError('')
    setTradeType(type)
    setSendRecipient('')
    setSendRecipientError('')

    // Fetch balances when opening modal
    fetchBalances()

    if (type === 'burn') {
      setBurnModalOpen(true)
    } else if (type === 'send') {
      setSendModalOpen(true)
    } else {
      setModalOpen(true)
    }
  }

  const handleAmountChange = (value: string) => {
    // Remove existing commas first
    const withoutCommas = value.replace(/,/g, '')
    
    // Only allow whole numbers
    const cleanValue = withoutCommas.replace(/[^\d]/g, '')
    
    // Store the clean value for calculations
    setAmount(cleanValue)

    // Format with commas for display
    if (cleanValue) {
      const formattedValue = cleanValue.replace(/\B(?=(\d{3})+(?!\d))/g, ',')
      setFormattedAmount(formattedValue)
    } else {
      setFormattedAmount('')
    }
  }

  const handleTrade = async () => {
    if (!authenticated) {
      login()
      return
    }

    const pendingToast = toast.loading('setting everything up...')

    try {
      setIsLoading(true)
      const activeWallet = user?.wallet
      if (!activeWallet?.address) {
        toast.dismiss(pendingToast)
        toast.error('No wallet connected')
        return
      }

      if (tradeType === 'burn') {
        const tokenAmount = BigInt(Math.floor(Number(amount)))
        if (tokenAmount > tokenBalance) {
          toast.dismiss(pendingToast)
          toast.error('Insufficient token balance')
          return
        }

        try {
          toast.update(pendingToast, {
            render: 'sending to ensurance proceeds...',
            type: 'info',
            isLoading: true
          })

          const walletClient = createWalletClient({
            chain: base,
            transport: custom(window.ethereum)
          })

          const hash = await walletClient.writeContract({
            address: contractAddress,
            abi: ZORA_1155_ABI,
            functionName: 'safeTransferFrom',
            args: [
              activeWallet.address,
              PROCEEDS_ADDRESS,
              tokenId,
              tokenAmount,
              '0x' // No data needed
            ],
            chain: base,
            account: activeWallet.address as `0x${string}`
          })
          
          await publicClient.waitForTransactionReceipt({ hash })
          
          toast.update(pendingToast, {
            render: 'certificates sent to ensurance proceeds',
            type: 'success',
            isLoading: false,
            autoClose: 5000,
            className: '!bg-orange-500/20 !text-orange-200 !border-orange-500/30'
          })
          
          setModalOpen(false)
          await fetchBalances()
          return
        } catch (error: any) {
          console.error('Transfer failed:', error)
          if (error?.code === 4001 || error?.message?.includes('rejected')) {
            toast.dismiss(pendingToast)
            toast.error('transaction cancelled')
          } else {
            toast.update(pendingToast, {
              render: 'transfer failed',
              type: 'error',
              isLoading: false,
              autoClose: 5000
            })
          }
          return
        }
      } else if (tradeType === 'buy') {
        if (!primaryMintActive) {
          toast.dismiss(pendingToast)
          toast.error('This policy is no longer issuing certificates')
          return
        }

        const quantity = BigInt(Math.floor(Number(amount)))
        if (maxSupply && totalMinted && quantity + totalMinted > maxSupply) {
          toast.dismiss(pendingToast)
          toast.error('Exceeds maximum supply')
          return
        }

        try {
          const walletClient = createWalletClient({
            chain: base,
            transport: custom(window.ethereum)
          })

          // Get mint parameters and check if approval is needed
          const { parameters, needsApproval } = await mintToken(
            contractAddress,
            tokenId.toString(),
            Number(quantity),
            activeWallet.address as `0x${string}`,
            walletClient
          )

          // If approval is needed, handle it first
          if (needsApproval) {
            toast.update(pendingToast, {
              render: 'approving USDC...',
              type: 'info',
              isLoading: true
            })

            // Approve USDC
            const approveHash = await walletClient.writeContract({
              address: CONTRACTS.usdc,
              abi: [
                {
                  inputs: [
                    { name: 'spender', type: 'address' },
                    { name: 'amount', type: 'uint256' }
                  ],
                  name: 'approve',
                  outputs: [{ type: 'bool' }],
                  stateMutability: 'nonpayable',
                  type: 'function'
                }
              ],
              functionName: 'approve',
              args: [CONTRACTS.erc20Minter, maxUint256],
              account: activeWallet.address as `0x${string}`
            })

            await publicClient.waitForTransactionReceipt({ hash: approveHash })

            toast.update(pendingToast, {
              render: 'USDC approved! Click ENSURE again to mint.',
              type: 'success',
              isLoading: false,
              autoClose: 5000
            })
            
            setModalOpen(false)
            await fetchBalances()
            return
          }

          // Proceed with mint
          toast.update(pendingToast, {
            render: 'confirming purchase...',
            type: 'info',
            isLoading: true
          })

          if (!pricePerToken) {
            toast.dismiss(pendingToast)
            toast.error('Price per token not found')
            return
          }

          // Calculate total price
          const totalPrice = pricePerToken * BigInt(quantity)

          console.log('Mint contract call:', {
            address: CONTRACTS.erc20Minter,
            functionName: 'mint',
            args: [
              activeWallet.address,    // 1. mintTo
              BigInt(quantity),        // 2. quantity
              contractAddress,         // 3. tokenAddress
              tokenId,                 // 4. tokenId
              totalPrice,              // 5. totalValue
              CONTRACTS.usdc,          // 6. currency
              CONTRACTS.mintReferral,  // 7. mintReferral
              ''                       // 8. comment
            ]
          })

          const hash = await walletClient.writeContract({
            address: CONTRACTS.erc20Minter,
            abi: ZORA_ERC20_MINTER_ABI,
            functionName: 'mint',
            args: [
              activeWallet.address,    // 1. mintTo
              BigInt(quantity),        // 2. quantity
              contractAddress,         // 3. tokenAddress
              tokenId,                 // 4. tokenId
              totalPrice,              // 5. totalValue
              CONTRACTS.usdc,          // 6. currency
              CONTRACTS.mintReferral,  // 7. mintReferral
              ''                       // 8. comment
            ],
            chain: base,
            account: activeWallet.address as `0x${string}`
          })
          
          await publicClient.waitForTransactionReceipt({ hash })
          
          toast.update(pendingToast, {
            render: 'purchase successful',
            type: 'success',
            isLoading: false,
            autoClose: 5000,
            className: '!bg-green-500/20 !text-green-200 !border-green-500/30'
          })
          
          setModalOpen(false)
          await fetchBalances()
          return
        } catch (error: any) {
          console.error('Trade failed:', error)
          toast.dismiss(pendingToast)
          if (error?.code === 4001 || error?.message?.includes('rejected')) {
            toast.error('Transaction cancelled')
          } else if (error?.status === 429 || error?.message?.includes('429')) {
            toast.error('Rate limit exceeded. Please try again in a few seconds.')
          } else if (error?.message?.includes('insufficient funds')) {
            toast.error('Insufficient USDC balance')
          } else {
            toast.error(error?.message || 'Failed to execute trade')
          }
        }
      }
    } catch (error: any) {
      console.error('Trade failed:', error)
      toast.dismiss(pendingToast)
      if (error?.code === 4001 || error?.message?.includes('rejected')) {
        toast.error('Transaction cancelled')
      } else {
        toast.error(error?.message || 'Failed to execute trade')
      }
    } finally {
      setIsLoading(false)
    }
  }

  const handleSend = async () => {
    if (!authenticated) {
      login()
      return
    }

    const pendingToast = toast.loading('setting everything up...')

    try {
      setIsLoading(true)
      const activeWallet = user?.wallet
      if (!activeWallet?.address) {
        toast.dismiss(pendingToast)
        toast.error('No wallet connected')
        return
      }

      // Validate recipient
      if (!sendRecipient || !/^0x[a-fA-F0-9]{40}$/.test(sendRecipient)) {
        toast.dismiss(pendingToast)
        toast.error('Invalid recipient address')
        setSendRecipientError('Invalid address')
        return
      }

      const tokenAmount = BigInt(Math.floor(Number(amount)))
      if (tokenAmount > tokenBalance) {
        toast.dismiss(pendingToast)
        toast.error('Insufficient token balance')
        return
      }
      if (tokenAmount <= 0) {
        toast.dismiss(pendingToast)
        toast.error('Amount must be greater than zero')
        return
      }

      try {
        toast.update(pendingToast, {
          render: 'sending tokens...',
          type: 'info',
          isLoading: true
        })

        const walletClient = createWalletClient({
          chain: base,
          transport: custom(window.ethereum)
        })

        const hash = await walletClient.writeContract({
          address: contractAddress,
          abi: ZORA_1155_ABI,
          functionName: 'safeTransferFrom',
          args: [
            activeWallet.address,
            sendRecipient,
            tokenId,
            tokenAmount,
            '0x'
          ],
          chain: base,
          account: activeWallet.address as `0x${string}`
        })

        await publicClient.waitForTransactionReceipt({ hash })

        toast.update(pendingToast, {
          render: 'tokens sent successfully',
          type: 'success',
          isLoading: false,
          autoClose: 5000,
          className: '!bg-amber-500/20 !text-amber-200 !border-amber-500/30'
        })

        setSendModalOpen(false)
        await fetchBalances()
        return
      } catch (error: any) {
        console.error('Send failed:', error)
        if (error?.code === 4001 || error?.message?.includes('rejected')) {
          toast.dismiss(pendingToast)
          toast.error('transaction cancelled')
        } else {
          toast.update(pendingToast, {
            render: 'send failed',
            type: 'error',
            isLoading: false,
            autoClose: 5000
          })
        }
        return
      }
    } catch (error: any) {
      console.error('Send failed:', error)
      toast.dismiss(pendingToast)
      if (error?.code === 4001 || error?.message?.includes('rejected')) {
        toast.error('Transaction cancelled')
      } else {
        toast.error(error?.message || 'Failed to send tokens')
      }
    } finally {
      setIsLoading(false)
    }
  }

  // Format balance for display
  const formatBalance = (balance: bigint) => {
    if (balance === BigInt(0)) return '0'
    return balance.toString()
  }

  return (
    <>
      <div className="flex gap-8">
        {/* Ensure (buy) button - green */}
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <button
                onClick={() => handleOpenModal('buy')}
                className="flex items-center gap-2 text-gray-300 hover:text-gray-100 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                disabled={!primaryMintActive}
              >
                <PlusCircle className={`${iconSize} stroke-[1.5] stroke-green-500 hover:stroke-green-400 transition-colors`} />
              </button>
            </TooltipTrigger>
            <TooltipContent>
              <p>ensure (buy)</p>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>

        {/* Transform (swap) button - blue (commented out, TODO) */}
        {/**
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <button
                onClick={() => handleOpenModal('sell')}
                className="flex items-center gap-2 text-gray-300 hover:text-gray-100 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                disabled
              >
                <RefreshCw className={`${iconSize} stroke-[1.5] stroke-blue-500 hover:stroke-blue-400 transition-colors`} />
              </button>
            </TooltipTrigger>
            <TooltipContent>
              <p>transform (swap)</p>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
        */}
        {/* TODO: add exchange functionality later for 1155 to erc20 */}

        {/* Send button - amber */}
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <button
                onClick={() => handleOpenModal('send')}
                className="flex items-center gap-2 text-gray-300 hover:text-gray-100 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
              >
                <Send className={`${iconSize} stroke-[1.5] stroke-amber-500 hover:stroke-amber-400 transition-colors`} />
              </button>
            </TooltipTrigger>
            <TooltipContent>
              <p>send</p>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>

        {showBurn && (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <button
                  onClick={() => handleOpenModal('burn')}
                  className="flex items-center gap-2 text-gray-300 hover:text-gray-100 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  <Flame className={`${iconSize} stroke-[1.5] stroke-orange-500 hover:stroke-orange-400 transition-colors`} />
                </button>
              </TooltipTrigger>
              <TooltipContent>
                <p>burn</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        )}
      </div>

      {showBalance && (
        <div className="mt-2 text-sm text-gray-400 text-center">
          balance: {formatBalance(tokenBalance)}
          <div className="text-xs text-gray-500 font-mono mt-0.5">{tokenName || 'Certificate'}</div>
        </div>
      )}

      {/* Buy/Mint Modal */}
      <Dialog open={modalOpen} onOpenChange={setModalOpen}>
        <DialogContent className="sm:max-w-[500px] bg-black/95 border border-gray-800 shadow-xl backdrop-blur-xl">
          <DialogHeader className="border-b border-gray-800 pb-4">
            <div className="flex items-center justify-between">
              <div className="flex flex-col gap-2">
                <DialogTitle className="text-xl font-bold text-white">
                  ensure
                </DialogTitle>
                <div className="text-3xl font-bold text-white">
                  {tokenName || tokenSymbol}
                </div>
              </div>
              <div className="relative w-20 h-20 rounded-lg overflow-hidden mr-4">
                <Image 
                  src={imageUrl}
                  alt={tokenSymbol}
                  fill
                  className="object-cover"
                />
              </div>
            </div>
          </DialogHeader>

          <div className="py-6">
            <div className="space-y-6">
              <div className="flex items-center justify-between">
                <div className="text-lg font-bold text-white flex items-center gap-2">
                  <div className="w-6 h-6 rounded-full overflow-hidden bg-gray-800 flex items-center justify-center">
                    <span className="text-sm font-bold text-gray-600">U</span>
                  </div>
                  USDC
                </div>
                <div className="flex items-center gap-3">
                  <div className="text-4xl font-black text-gray-400 hover:text-gray-300 transition-colors">→</div>
                  <div className="text-lg font-bold text-white flex items-center gap-2">
                    <div className="w-6 h-6 rounded-full overflow-hidden bg-gray-800 flex items-center justify-center">
                      <Image
                        src={imageUrl}
                        alt={tokenSymbol}
                        width={24}
                        height={24}
                        className="object-cover"
                      />
                    </div>
                    {tokenSymbol}
                  </div>
                </div>
              </div>

              <div className="space-y-3">
                <Input
                  type="text"
                  value={formattedAmount}
                  onChange={(e) => handleAmountChange(e.target.value)}
                  placeholder="enter amount"
                  className={`bg-gray-900/50 border-gray-800 text-white placeholder:text-gray-500 h-12 text-lg font-medium ${
                    amountError ? 'border-red-500' : ''
                  }`}
                />
                {amountError && (
                  <div className="text-sm text-red-500">
                    {amountError}
                  </div>
                )}
                <div className="text-sm text-gray-400">
                  your balance: {formatUsdcAmount(usdcBalance)}
                  <div className="text-xs text-gray-500 font-mono mt-0.5">USDC</div>
                </div>
                
                {pricePerToken && (
                  <div className="mt-4 p-4 bg-gray-900/50 rounded-lg border border-gray-800">
                    <div className="flex justify-between items-center mb-2">
                      <span className="text-gray-400">Price per token:</span>
                      <span className="text-white">${formatUsdcAmount(pricePerToken)} USDC</span>
                    </div>
                    <div className="flex justify-between items-center mb-2">
                      <span className="text-gray-400">Total price:</span>
                      <span className="text-white">
                        {amount && !isNaN(Number(amount)) && Number.isInteger(Number(amount)) && Number(amount) > 0
                          ? `$${formatUsdcAmount(pricePerToken * BigInt(Number(amount)))} USDC` 
                          : '$0.00 USDC'}
                      </span>
                    </div>
                    <div className="flex justify-between items-center pt-2 border-t border-gray-800">
                      <span className="text-gray-400">You will receive:</span>
                      <span className="text-white">
                        {amount ? `${formattedAmount} ${tokenSymbol}` : `0 ${tokenSymbol}`}
                      </span>
                    </div>
                  </div>
                )}
              </div>
            </div>
          </div>

          <div className="flex justify-end gap-3 pt-6 border-t border-gray-800">
            <Button 
              variant="ghost" 
              onClick={() => setModalOpen(false)}
              className="text-gray-400 hover:text-gray-300"
            >
              Cancel
            </Button>
            <Button
              onClick={handleTrade}
              disabled={isLoading || !amount || Number(amount) <= 0 || !primaryMintActive}
              className="min-w-[120px] bg-green-600 hover:bg-green-500"
            >
              {isLoading ? (
                <div className="flex items-center gap-2">
                  <div className="w-4 h-4 border-2 border-white/30 border-t-white rounded-full animate-spin" />
                  <span>Processing...</span>
                </div>
              ) : (
                'ENSURE'
              )}
            </Button>
          </div>
        </DialogContent>
      </Dialog>

      {/* Burn Modal */}
      <Dialog open={burnModalOpen} onOpenChange={setBurnModalOpen}>
        <DialogContent className="sm:max-w-[500px] bg-black/95 border border-gray-800 shadow-xl backdrop-blur-xl">
          <DialogHeader className="border-b border-gray-800 pb-4">
            <div className="flex items-center justify-between">
              <div className="flex flex-col gap-2">
                <DialogTitle className="text-xl font-bold text-white">
                  burn
                </DialogTitle>
                <div className="text-3xl font-bold text-white">
                  {tokenName || 'Certificate'}
                </div>
              </div>
              <div className="relative w-20 h-20 rounded-lg overflow-hidden mr-4">
                <Image 
                  src={imageUrl}
                  alt={tokenName || 'Certificate'}
                  fill
                  className="object-cover"
                />
              </div>
            </div>
          </DialogHeader>

          <div className="py-6">
            {tokenBalance === BigInt(0) ? (
              <div className="space-y-6 text-center">
                <div className="text-lg text-gray-300">
                  buy to burn
                </div>
                <Button
                  onClick={() => {
                    setBurnModalOpen(false)
                    setTimeout(() => {
                      handleOpenModal('buy')
                    }, 100)
                  }}
                  className="bg-green-600 hover:bg-green-500"
                  disabled={!primaryMintActive}
                >
                  ENSURE NOW
                </Button>
              </div>
            ) : (
              <div className="space-y-6">
                <div className="flex items-center justify-between">
                  <div className="text-lg font-bold text-white flex items-center gap-2">
                    <div className="w-6 h-6 rounded-full overflow-hidden bg-gray-800 flex items-center justify-center">
                      <Image
                        src={imageUrl}
                        alt={tokenName || 'Certificate'}
                        width={24}
                        height={24}
                        className="object-cover"
                      />
                    </div>
                    {tokenName || 'Certificate'}
                  </div>
                </div>

                <div className="space-y-3">
                  <label className="text-sm font-medium text-gray-300">
                    quantity to burn
                  </label>
                  <Input
                    type="text"
                    value={formattedAmount}
                    onChange={(e) => handleAmountChange(e.target.value)}
                    placeholder="enter amount"
                    className={`bg-gray-900/50 border-gray-800 text-white placeholder:text-gray-500 h-12 text-lg font-medium ${
                      amountError ? 'border-red-500' : ''
                    }`}
                  />
                  {amountError && (
                    <div className="text-sm text-red-500">
                      {amountError}
                    </div>
                  )}
                  <div className="text-sm text-gray-400">
                    your balance: {formatBalance(tokenBalance)}
                    <div className="text-xs text-gray-500 font-mono mt-0.5">{tokenName || 'Certificate'}</div>
                  </div>

                  <div className="mt-4 p-4 bg-gray-900/50 rounded-lg border border-gray-800">
                    <div className="flex justify-between items-center">
                      <span className="text-gray-400">You will send:</span>
                      <span className="text-white">
                        {amount ? `${formattedAmount} ${tokenName || 'Certificate'}` : `0 ${tokenName || 'Certificate'}`}
                      </span>
                    </div>
                  </div>

                  <div className="text-sm text-gray-400 flex items-center gap-2">
                    <Flame className="w-4 h-4 text-orange-500" />
                    <span>
                      burn locks these assets in the protocol to create{' '}
                      <a 
                        href="https://ensurance.app/proceeds/0xa187F8CBdd36D63967c33f5BD4dD4B9ECA51270e" 
                        target="_blank" 
                        rel="noopener noreferrer"
                        className="text-orange-400 hover:text-orange-300 inline-flex items-center gap-1"
                      >
                        ensurance proceeds
                        <ExternalLink className="w-3 h-3" />
                      </a>
                    </span>
                  </div>
                </div>
              </div>
            )}
          </div>

          <div className="flex justify-end gap-3 pt-6 border-t border-gray-800">
            <Button 
              variant="ghost" 
              onClick={() => setBurnModalOpen(false)}
              className="text-gray-400 hover:text-gray-300"
            >
              Cancel
            </Button>
            <Button
              onClick={handleTrade}
              disabled={isLoading || !amount || Number(amount) <= 0}
              className="min-w-[120px] bg-orange-600 hover:bg-orange-500"
            >
              {isLoading ? (
                <div className="flex items-center gap-2">
                  <div className="w-4 h-4 border-2 border-white/30 border-t-white rounded-full animate-spin" />
                  <span>Processing...</span>
                </div>
              ) : (
                'BURN'
              )}
            </Button>
          </div>
        </DialogContent>
      </Dialog>

      {/* Send Modal */}
      <Dialog open={sendModalOpen} onOpenChange={setSendModalOpen}>
        <DialogContent className="sm:max-w-[500px] bg-black/95 border border-gray-800 shadow-xl backdrop-blur-xl">
          <DialogHeader className="border-b border-gray-800 pb-4">
            <div className="flex items-center justify-between">
              <div className="flex flex-col gap-2">
                <DialogTitle className="text-xl font-bold text-white">
                  send
                </DialogTitle>
                <div className="text-3xl font-bold text-white">
                  {tokenName || 'Certificate'}
                </div>
              </div>
              <div className="relative w-20 h-20 rounded-lg overflow-hidden mr-4">
                <Image 
                  src={imageUrl}
                  alt={tokenName || 'Certificate'}
                  fill
                  className="object-cover"
                />
              </div>
            </div>
          </DialogHeader>

          <div className="py-6 space-y-6">
            <div className="space-y-3">
              <label className="text-sm font-medium text-gray-300">
                recipient
              </label>
              <div className="relative">
                <Input
                  type="text"
                  value={accountSearchQuery}
                  onChange={(e) => {
                    setAccountSearchQuery(e.target.value)
                    setSelectedAccount(null)
                  }}
                  placeholder="Search for an account..."
                  className="w-full bg-gray-900/50 border-gray-800 text-white placeholder:text-gray-500 h-12 text-lg font-medium"
                />
                {isSearching && (
                  <div className="absolute right-3 top-1/2 -translate-y-1/2">
                    <div className="w-5 h-5 border-2 border-gray-400 border-t-transparent rounded-full animate-spin" />
                  </div>
                )}
                {accountSearchResults.length > 0 && !selectedAccount && (
                  <div className="absolute z-10 w-full mt-1 bg-gray-900 border border-gray-800 rounded-lg shadow-lg max-h-60 overflow-auto">
                    {accountSearchResults.map((result) => (
                      <button
                        key={result.name}
                        onClick={() => {
                          setSelectedAccount(result)
                          setAccountSearchQuery(result.name)
                        }}
                        className="w-full px-4 py-2 text-left hover:bg-gray-800 transition-colors flex items-center gap-2"
                      >
                        <div className="w-6 h-6 rounded-full overflow-hidden bg-gray-800 flex items-center justify-center">
                          <AccountImage
                            tokenId={result.token_id}
                            groupName={result.name.split('.')[1]}
                            variant="circle"
                            className="w-6 h-6"
                          />
                        </div>
                        <span className="font-mono">{result.name}</span>
                        {result.is_agent && (
                          <span className="text-xs px-2 py-1 bg-blue-500/20 text-blue-400 rounded">
                            agent
                          </span>
                        )}
                      </button>
                    ))}
                  </div>
                )}
              </div>
              {selectedAccount && sendRecipient && (
                <div className="flex items-center gap-3 mt-2">
                  <div className="flex-1 space-y-1">
                    <div className="text-sm text-gray-400">
                      {selectedAccount.name}
                    </div>
                    <div className="text-xs text-gray-500 font-mono">
                      {truncateAddress(sendRecipient)}
                    </div>
                  </div>
                  <div className="w-8 h-8 rounded-full overflow-hidden bg-gray-800 flex items-center justify-center">
                    <AccountImage
                      tokenId={selectedAccount.token_id}
                      groupName={selectedAccount.name.split('.')[1]}
                      variant="circle"
                      className="w-8 h-8"
                    />
                  </div>
                </div>
              )}
            </div>
            <div className="space-y-3">
              <label className="text-sm font-medium text-gray-300">
                quantity to send
              </label>
              <Input
                type="text"
                value={formattedAmount}
                onChange={e => handleAmountChange(e.target.value)}
                placeholder="enter amount"
                className={`bg-gray-900/50 border-gray-800 text-white placeholder:text-gray-500 h-12 text-lg font-medium ${amountError ? 'border-red-500' : ''}`}
              />
              {amountError && (
                <div className="text-sm text-red-500">
                  {amountError}
                </div>
              )}
              <div className="text-sm text-gray-400">
                your balance: {formatBalance(tokenBalance)}
                <div className="text-xs text-gray-500 font-mono mt-0.5">{tokenName || 'Certificate'}</div>
              </div>
            </div>
            <div className="mt-4 p-4 bg-gray-900/50 rounded-lg border border-gray-800">
              <div className="flex justify-between items-center">
                <span className="text-gray-400">You will send:</span>
                <span className="text-white">
                  {amount ? `${formattedAmount} ${tokenName || 'Certificate'}` : `0 ${tokenName || 'Certificate'}`}
                </span>
              </div>
            </div>
          </div>

          <div className="flex justify-end gap-3 pt-6 border-t border-gray-800">
            <Button 
              variant="ghost" 
              onClick={() => setSendModalOpen(false)}
              className="text-gray-400 hover:text-gray-300"
            >
              Cancel
            </Button>
            <Button
              onClick={handleSend}
              disabled={isLoading || !amount || Number(amount) <= 0 || !sendRecipient}
              className="min-w-[120px] bg-amber-600 hover:bg-amber-500"
            >
              {isLoading ? (
                <div className="flex items-center gap-2">
                  <div className="w-4 h-4 border-2 border-white/30 border-t-white rounded-full animate-spin" />
                  <span>Processing...</span>
                </div>
              ) : (
                'SEND'
              )}
            </Button>
          </div>
        </DialogContent>
      </Dialog>
    </>
  )
}
````

## File: src/components/layout/footer.tsx
````typescript
import { ReferralButton } from '@/modules/rewards/RewardsLink';
import { GroupLinks } from '@/modules/groups/GroupLinks';
import { FooterNavigation } from '@/components/layout/FooterNavigation';
import { UtilityLinks } from '@/components/layout/UtilityLinks';
import Image from 'next/image';
import Link from 'next/link';

interface FooterColumnProps {
  logoContent: React.ReactNode;
  links: Array<{ href: string; label: string }>;
}

function FooterColumn({ logoContent, links }: FooterColumnProps) {
  return (
    <div className="flex flex-col items-center justify-center">
      <div className="text-center h-[120px] flex items-center justify-center w-72">
        {logoContent}
      </div>
      <div className="flex flex-col items-center gap-1.5 w-72">
        {/* Gradient Divider */}
        <div className="w-full h-px bg-gradient-to-r from-transparent via-gray-800 to-transparent mb-1.5" />
        <div className="flex flex-col items-center gap-1.5">
          {links.map((link, index) => (
            <Link
              key={index}
              href={link.href}
              target="_blank"
              rel="noopener noreferrer"
              className="text-[11px] font-mono text-gray-400 hover:text-gray-200 transition-colors"
            >
              {link.label}
            </Link>
          ))}
        </div>
      </div>
    </div>
  );
}

export default function Footer() {
  return (
    <footer className="w-full border-t border-gray-800 mt-auto relative z-10">
      <div className="container mx-auto px-4 py-8">
        <div className="flex flex-col">
          <div className="flex items-center justify-center mb-6">
            <ReferralButton />
          </div>
          <div className="flex items-center justify-center">
            <FooterNavigation />
          </div>
          <div className="mb-6">
            <GroupLinks />
          </div>
          
          {/* Natural Assets Link */}
          <div className="max-w-2xl mx-auto mb-6">
            <div className="flex justify-center items-center">
              <Link 
                href="https://binder.ensurance.app/"
                target="_blank"
                rel="noopener noreferrer"
                className="text-lg text-gray-500 hover:text-gray-300 transition-colors"
              >
                natural assets
              </Link>
            </div>
          </div>

          {/* Upper Gradient Divider */}
          <div className="w-full h-px bg-gradient-to-r from-transparent via-gray-800 to-transparent mb-8" />
          
          <div className="mb-8">
            <UtilityLinks />
          </div>
          
          {/* Lower Gradient Divider */}
          <div className="w-full h-px bg-gradient-to-r from-transparent via-gray-800 to-transparent mb-8" />
          
          {/* Bottom Footer */}
          <div className="max-w-3xl mx-auto w-full">
            <div className="grid grid-cols-2 gap-8">
              {/* Left Column - BASIN */}
              <FooterColumn 
                logoContent={
                  <Link href="/" className="opacity-60 hover:opacity-100 transition-opacity">
                    <Image
                      src="/assets/logos/basin-blue-circle%20300.png"
                      alt="BASIN"
                      width={65}
                      height={65}
                    />
                  </Link>
                }
                links={[
                  { href: "https://github.com/basin-global", label: "github" },
                  { href: "https://docs.basin.global", label: "field manual" },
                  { href: "https://dispatches.basin.global", label: "dispatches" }
                ]}
              />

              {/* Right Column - Tech Stack & Legal */}
              <FooterColumn 
                logoContent={
                  <div className="flex flex-col items-center justify-center h-full">
                    <div className="opacity-60 hover:opacity-100 transition-opacity mb-4">
                      <Image
                        src="/assets/logos/builtOnEthereum.png"
                        alt="Built on Ethereum - Jack Butcher"
                        width={50}
                        height={23}
                        className="w-auto h-auto"
                      />
                    </div>
                    <Link
                      href="https://elizaos.github.io/eliza/"
                      target="_blank"
                      rel="noopener noreferrer"
                      className="opacity-60 hover:opacity-100 transition-opacity"
                    >
                      <Image
                        src="/assets/logos/eliza-os_logo-mark_light.png"
                        alt="ELIZA OS"
                        width={42}
                        height={42}
                        className="w-auto h-auto"
                      />
                    </Link>
                  </div>
                }
                links={[
                  { href: "https://github.com/basin-global/ensurance-app/blob/main/LICENSE", label: "license" },
                  { href: "https://docs.basin.global/dossier/formalities/disclaimer", label: "terms" },
                  { href: "https://docs.basin.global/dossier/formalities/privacy", label: "privacy" }
                ]}
              />
            </div>
          </div>

          {/* Bottom Padding */}
          <div className="h-8" />
        </div>
      </div>
    </footer>
  )
}
````

## File: src/components/layout/FooterNavigation.tsx
````typescript
import Link from 'next/link';

export function FooterNavigation() {
  return (
    <div className="flex flex-col items-center w-full max-w-5xl">
      {/* Header */}
      <Link href="/" className="mb-6 hover:text-gray-100 transition-colors">
        <span className="font-bold text-5xl text-gray-100">ensurance</span>
      </Link>
      <div className="mb-12">
        <span className="text-gray-400 text-lg font-light tracking-wide">markets for what matters</span>
      </div>
      
      {/* Gradient Divider */}
      <div className="w-full h-px bg-gradient-to-r from-transparent via-gray-800 to-transparent mb-12" />
      
      {/* Two Columns */}
      <div className="grid grid-cols-2 gap-48 mb-12">
        {/* Left Column - Natural Capital */}
        <div className="flex flex-col items-center">
          <span className="text-sm text-gray-400 mb-4">ensuring the</span>
          <div className="flex flex-col items-center text-2xl text-gray-300">
            <div className="flex items-center gap-2">
              <Link href="/natural-capital/stocks" className="hover:text-gray-100 transition-colors">
                stocks
              </Link>
              <span className="text-gray-400">&</span>
              <Link href="/natural-capital/flows" className="hover:text-gray-100 transition-colors">
                flows
              </Link>
            </div>
            <span className="text-gray-400 text-xl my-1">of</span>
            <Link href="/natural-capital" className="hover:text-gray-100 transition-colors">
              natural capital
            </Link>
          </div>
        </div>

        {/* Right Column - Operations */}
        <div className="flex flex-col items-center justify-center text-base text-gray-300">
        <Link href="/exposure" className="hover:text-gray-100 transition-colors mb-2">
            exposure
          </Link>
          <Link href="/markets" className="hover:text-gray-100 transition-colors mb-2">
            markets
          </Link>
          <Link href="/syndicates" className="hover:text-gray-100 transition-colors mb-2">
            syndicates
          </Link>
          <Link href="/proceeds" className="hover:text-gray-100 transition-colors mb-2">
            proceeds
          </Link>
          <Link href="/pools" className="hover:text-gray-100 transition-colors mb-2">
            pools
          </Link>
        </div>
      </div>
    </div>
  );
}
````

## File: src/components/layout/header.tsx
````typescript
'use client'

import { HeaderSearch } from './HeaderSearch'
import { ConnectOperator } from './ConnectOperator'
import { HeaderLogo } from './HeaderLogo'
import { SubNavigation } from './SubNavigation'
import { usePathname } from 'next/navigation'
import { useEffect, useState } from 'react'

export default function Header() {
  const pathname = usePathname()
  const [isVisible, setIsVisible] = useState(true)

  // Determine if and what type of sub-navigation to show
  const getSubNavConfig = () => {
    // For groups pages - extract group name from path
    if (pathname.startsWith('/groups/')) {
      const groupName = pathname.split('/')[2] // gets the group name from /groups/[group]/...
      return { show: true, type: 'og' as const, groupName }
    }

    // For certificates pages
    if (pathname.startsWith('/certificates/')) {
      return { show: true, type: 'certificates' as const }
    }

    // For account pages (including root level all/create/mine)
    if (pathname.startsWith('/(accounts)') || 
        pathname === '/all' || 
        pathname === '/create' || 
        pathname === '/mine') {
      return { show: true, type: 'accounts' as const }
    }

    // Default - no sub-navigation
    return { show: false, type: 'accounts' as const } // Provide default type even when not shown
  }

  useEffect(() => {
    const handleScroll = () => {
      // Only apply scroll-based visibility on the home page
      if (pathname === '/') {
        const scrollPosition = window.scrollY
        const windowHeight = window.innerHeight
        
        // Show header after scrolling past the first section (Ensure)
        setIsVisible(scrollPosition > windowHeight * 0.5)
      } else {
        // Always show header on other pages
        setIsVisible(true)
      }
    }

    // Set initial visibility
    handleScroll()

    window.addEventListener('scroll', handleScroll)
    return () => window.removeEventListener('scroll', handleScroll)
  }, [pathname])

  const navConfig = getSubNavConfig()

  return (
    <header className={`w-full border-b border-gray-800 relative z-10 transition-opacity duration-500 ${isVisible ? 'opacity-100' : 'opacity-0'}`}>
      <div className="container mx-auto px-6 py-4">
        <nav className="flex items-center">
          <HeaderLogo />
          <div className="flex-1 flex items-center justify-end">
            {/* Sub Navigation */}
            {navConfig.show && (
              <div className="mr-8">
                <SubNavigation 
                  type={navConfig.type}
                  groupName={navConfig.groupName}
                  compact={true}
                />
              </div>
            )}
            <div className="flex items-center">
              <HeaderSearch />
              <span className="text-sm font-mono opacity-50 mr-8">⌘K</span>
            </div>
            <ConnectOperator />
          </div>
        </nav>
      </div>
    </header>
  )
}
````

## File: src/components/layout/HeaderLogo.tsx
````typescript
'use client'

import Image from 'next/image'
import Link from 'next/link'
import { usePathname, useParams } from 'next/navigation'
import { cn } from '@/lib/utils'

interface Params {
  group?: string
  account?: string
}

export function HeaderLogo() {
  const pathname = usePathname()
  const params = useParams() as Params
  
  // Get group name from either group page or account page
  let groupName = null
  
  if (pathname.includes('/groups/')) {
    groupName = `.${params.group}`
  } else if (params.account?.includes('.')) {
    groupName = `.${params.account.split('.')[1]}`
  }

  // Special case for natural capital routes and .ensurance accounts
  const isNaturalCapital = pathname.includes('/natural-capital') || 
    (groupName && groupName.endsWith('.ensurance'))

  // Determine logo source
  const logoSrc = isNaturalCapital
    ? "/groups/orbs/ensurance-orb.png"
    : groupName 
      ? `/groups/orbs/${groupName.replace(/^\./, '')}-orb.png`
      : "/groups/orbs/ensurance-orb.png"

  // Get header text and tagline based on path
  let headerText = 'ensurance'
  let tagline = 'markets for what matters'

  if (isNaturalCapital) {
    headerText = 'natural capital ensurance'
    tagline = ''
  } else if (pathname.includes('/proceeds')) {
    headerText = 'ensurance proceeds'
    tagline = 'perpetual funding for what matters'
  } else if (pathname.includes('/exposure')) {
    headerText = 'ensurance exposure'
    tagline = 'nature risk by economic sector'
  } else if (groupName) {
    headerText = `${groupName} ensurance agents`
    tagline = ''
  }

  // Determine URLs
  const homeUrl = '/'
  const groupUrl = isNaturalCapital
    ? '/natural-capital'
    : groupName 
      ? `/groups/${groupName.replace(/^\./, '')}`
      : '/'

  return (
    <div className="flex items-center gap-4 font-grotesk font-bold text-lg tracking-wide">
      <Link href={homeUrl} className="hover:opacity-80 transition-opacity">
        <Image 
          src={logoSrc}
          alt="Logo"
          width={40}
          height={40}
        />
      </Link>
      <div>
        {groupName || isNaturalCapital ? (
          <Link href={groupUrl} className={cn(
            "hover:opacity-80 transition-opacity",
            isNaturalCapital && "bg-clip-text text-transparent bg-gradient-to-r from-amber-300 via-yellow-500 to-amber-600"
          )}>
            {headerText}
          </Link>
        ) : (
          <>
            <Link href={homeUrl} className="hover:opacity-80 transition-opacity">
              {headerText}
            </Link>
            {tagline && (
              <div className="text-sm opacity-80 mt-1">{tagline}</div>
            )}
          </>
        )}
      </div>
    </div>
  )
}
````

## File: src/components/layout/HeaderSearch.tsx
````typescript
'use client'

import React, { useState, useEffect, useRef } from 'react'
import { Search } from 'lucide-react'
import { AssetSearch } from '@/modules/assets/AssetSearch'
import { cn } from '@/lib/utils'
import Link from 'next/link'
import { useDebounce } from '@/hooks/useDebounce'
import { createPortal } from 'react-dom'
import { TypewriterEffect } from '@/components/ui/typewriter-effect'

interface SearchResult {
  name: string
  path: string
  type: string
  chain?: string
  is_agent?: boolean
  is_ensurance?: boolean
  doc_section?: string
}

export function HeaderSearch() {
  const isDev = process.env.NODE_ENV === 'development'

  const [isOpen, setIsOpen] = useState(false)
  const [searchQuery, setSearchQuery] = useState('')
  const [results, setResults] = useState<SearchResult[]>([])
  const [isLoading, setIsLoading] = useState(false)
  const debouncedSearch = useDebounce(searchQuery, 200)
  const [selectedIndex, setSelectedIndex] = useState(-1)
  const abortControllerRef = useRef<AbortController | null>(null)
  const [lastKeyTime, setLastKeyTime] = useState(0)
  const [lastKey, setLastKey] = useState('')

  // Keyboard shortcuts map
  const shortcuts = {
    'g': '/groups',            // g g - groups
    'a': '/all',               // g a - agents
    'm': '/markets',  // g m - markets
    'p': '/proceeds',             // g p - proceeds
    's': '/syndicates',        // g s - syndicates
    'b': 'https://binder.ensurance.app', // g b - binder
    'd': '/docs',              // g d - docs
    'h': '/' // g h home
  } as const

  type ShortcutKey = keyof typeof shortcuts

  // Handle keyboard shortcuts
  useEffect(() => {
    function handleKeyDown(event: KeyboardEvent) {
      // Don't handle shortcuts if any search input is focused
      const activeElement = document.activeElement
      if (activeElement instanceof HTMLInputElement || activeElement instanceof HTMLTextAreaElement) {
        return
      }

      if (!isOpen) {
        // Handle ⌘K to open search
        if ((event.metaKey || event.ctrlKey) && event.key === 'k') {
          event.preventDefault()
          setIsOpen(true)
          return
        }

        const now = Date.now()
        
        // If 'g' was pressed in the last 500ms, check for shortcuts
        if (lastKey === 'g' && (now - lastKeyTime) < 500) {
          const key = event.key.toLowerCase() as ShortcutKey
          const shortcutPath = shortcuts[key]
          if (shortcutPath) {
            event.preventDefault()
            if (shortcutPath.includes('coinbase.com') || shortcutPath.includes('binder.ensurance.app')) {
              window.open(shortcutPath, '_blank')
            } else {
              window.location.href = shortcutPath
            }
          }
          setLastKey('')
          return
        }

        // If 'g' is pressed, start the shortcut sequence
        if (event.key === 'g') {
          setLastKeyTime(now)
          setLastKey('g')
          return
        }

        setLastKey('')
      }
    }

    document.addEventListener('keydown', handleKeyDown)
    return () => document.removeEventListener('keydown', handleKeyDown)
  }, [isOpen, lastKey, lastKeyTime])

  // Load initial results when opened
  const loadInitialResults = async () => {
    setIsLoading(true)
    try {
      const response = await fetch('/api/search?q=')
      const data = await response.json()
      setResults(Array.isArray(data) ? data : [])
    } catch (error) {
      console.error('Initial search failed:', error)
      setResults([])
    }
    setIsLoading(false)
  }

  // Load nav items when opened
  useEffect(() => {
    if (isOpen) {
      loadInitialResults()
    }
  }, [isOpen])

  // Clear search when closed
  useEffect(() => {
    if (!isOpen) {
      setSearchQuery('')
    }
  }, [isOpen])

  useEffect(() => {
    function handleKeyDown(event: KeyboardEvent) {
      if (!isOpen) return

      switch (event.key) {
        case 'ArrowDown':
          event.preventDefault()
          setSelectedIndex(prev => 
            prev < results.length - 1 ? prev + 1 : prev
          )
          break
        case 'ArrowUp':
          event.preventDefault()
          setSelectedIndex(prev => 
            prev > 0 ? prev - 1 : prev
          )
          break
        case 'Enter':
          event.preventDefault()
          if (selectedIndex >= 0 && results[selectedIndex]) {
            window.location.href = results[selectedIndex].path
            setIsOpen(false)
          }
          break
      }
    }

    document.addEventListener('keydown', handleKeyDown)
    return () => document.removeEventListener('keydown', handleKeyDown)
  }, [isOpen, results, selectedIndex])

  useEffect(() => {
    setSelectedIndex(-1)
  }, [searchQuery])

  React.useEffect(() => {
    async function performSearch() {
      // If search is empty, load initial nav items
      if (!debouncedSearch) {
        loadInitialResults()
        return
      }

      if (abortControllerRef.current) {
        abortControllerRef.current.abort()
      }

      abortControllerRef.current = new AbortController()

      setIsLoading(true)
      try {
        const response = await fetch(
          `/api/search?q=${encodeURIComponent(debouncedSearch)}`,
          { 
            signal: abortControllerRef.current.signal,
            headers: {
              'Accept': 'application/json',
              'Content-Type': 'application/json',
            }
          }
        )
        
        if (!response.ok) {
          const errorData = await response.json()
          console.error('Search API error:', errorData)
          throw new Error(errorData.error || 'Search failed')
        }
        
        const data = await response.json()
        console.log('Search API response:', data)
        
        if (abortControllerRef.current) {
          setResults(Array.isArray(data) ? data : [])
        }
      } catch (error: unknown) {
        if (error instanceof Error && error.name !== 'AbortError') {
          console.error('Search failed:', error)
          setResults([])
        }
      } finally {
        setIsLoading(false)
      }
    }

    performSearch()

    return () => {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort()
        abortControllerRef.current = null
      }
    }
  }, [debouncedSearch])

  const sortedResults = React.useMemo(() => {
    if (!Array.isArray(results)) {
      console.warn('Results is not an array:', results)
      return []
    }
    return [...results].sort((a, b) => {
      const typeOrder = {
        group: 1,
        account: a.is_ensurance ? 2 : (a.is_agent ? 3 : 4),
        certificate: 5,
        doc: 6
      } as const

      type ResultType = keyof typeof typeOrder
      const aType = a.type as ResultType
      const bType = b.type as ResultType
      
      return (typeOrder[aType] || 99) - (typeOrder[bType] || 99)
    })
  }, [results])

  const searchPlaceholderWords = [
    { text: "what do you want to ensure?" },
    { text: "ensure natural capital" },
    { text: "markets for what matters" },
    { text: "invest in natural assets" }
  ]

  const modalContent = isOpen && (
    <>
      <div 
        className="fixed inset-0 bg-black/50"
        style={{ position: 'fixed', zIndex: 2147483647 }}
        onClick={() => setIsOpen(false)}
      />
      <div 
        className="fixed top-4 left-1/2 -translate-x-1/2 w-full max-w-xl"
        style={{ position: 'fixed', zIndex: 2147483647 }}
      >
        <div className="bg-[rgb(var(--background-rgb))] rounded-lg shadow-xl p-6 border border-white/20">
          <div className="max-w-md mx-auto">
            <AssetSearch
              searchQuery={searchQuery}
              setSearchQuery={setSearchQuery}
              placeholder={searchQuery ? "what do you want to ensure?" : undefined}
              autoFocus={isOpen}
              typewriterWords={!searchQuery ? searchPlaceholderWords : undefined}
              className="[&_.motion-span]:!text-sm"
            />
          </div>
          
          <div className="mt-4 max-h-96 overflow-y-auto">
            {isLoading ? (
              <div className="text-center py-4 text-[rgba(var(--foreground-rgb),0.5)] text-lg">
                searching...
              </div>
            ) : searchQuery && debouncedSearch && !isLoading && sortedResults.length === 0 ? (
              <div className="text-center py-4 text-[rgba(var(--foreground-rgb),0.5)] text-lg">
                No results found
              </div>
            ) : sortedResults.length > 0 ? (
              sortedResults.map((result, i) => (
                <Link
                  key={i}
                  href={result.path}
                  onClick={() => setIsOpen(false)}
                  target={result.path.includes('coinbase.com') || result.path.includes('binder.ensurance.app') ? '_blank' : undefined}
                  rel={result.path.includes('coinbase.com') || result.path.includes('binder.ensurance.app') ? 'noopener noreferrer' : undefined}
                  className={cn(
                    "block px-4 py-2 hover:bg-[rgba(var(--foreground-rgb),0.1)]",
                    "text-[rgba(var(--foreground-rgb),0.7)] rounded-lg",
                    "transition-colors duration-200",
                    "flex items-center justify-between",
                    "text-lg font-grotesk",
                    i === selectedIndex && "bg-[rgba(var(--foreground-rgb),0.1)]"
                  )}
                >
                  <div className="flex items-center gap-2">
                    <span className={cn(
                      result.type === 'nav' ? 'font-bold' : '',
                      'text-[rgba(var(--foreground-rgb),0.8)]'
                    )}>
                      {result.name}
                    </span>
                    {result.type === 'nav' && Object.entries(shortcuts).map(([key, path]) => {
                      if (path === result.path) {
                        return (
                          <span key={key} className="text-xs px-2 py-1 rounded bg-[rgba(var(--foreground-rgb),0.05)] text-[rgba(var(--foreground-rgb),0.5)]">
                            g {key}
                          </span>
                        )
                      }
                      return null
                    })}
                  </div>
                  <div className="flex items-center gap-2">
                    {result.type === 'nav' && (
                      <span className="text-xs px-2 py-1 rounded bg-[rgba(var(--foreground-rgb),0.1)] text-[rgba(var(--foreground-rgb),0.7)]">
                        NAV
                      </span>
                    )}
                    {result.type === 'group' && (
                      <span className="text-xs px-2 py-1 rounded bg-[rgba(var(--foreground-rgb),0.1)] text-[rgba(var(--foreground-rgb),0.7)]">
                        GROUP
                      </span>
                    )}
                    {result.type === 'general' && (
                      <span className="text-xs px-2 py-1 rounded bg-green-500/20 text-green-400">
                        GENERAL
                      </span>
                    )}
                    {result.type === 'specific' && (
                      <span className="text-xs px-2 py-1 rounded bg-emerald-500/20 text-emerald-400">
                        SPECIFIC
                      </span>
                    )}
                    {result.type === 'syndicate' && (
                      <span className="text-xs px-2 py-1 rounded bg-yellow-500/20 text-yellow-500">
                        SYNDICATE
                      </span>
                    )}
                    {result.type === 'account' && (
                      <>
                        {result.is_ensurance ? (
                          <span className="text-xs px-2 py-1 rounded" style={{ background: 'rgba(255, 215, 0, 0.20)', color: 'rgba(255, 215, 0, 0.95)', border: '1px solid rgba(255, 215, 0, 0.8)' }}>
                            ENSURANCE
                          </span>
                        ) : result.is_agent ? (
                          <span className="text-xs px-2 py-1 rounded bg-purple-500/20 text-purple-400">
                            AGENT
                          </span>
                        ) : (
                          <span className="text-xs px-2 py-1 rounded bg-blue-500/20 text-blue-400">
                            ACCOUNT
                          </span>
                        )}
                      </>
                    )}
                    {result.type === 'certificate' && (
                      <span className="text-xs px-2 py-1 rounded bg-gradient-to-r from-amber-300/20 to-amber-600/20 text-amber-500">
                        CERTIFICATE
                      </span>
                    )}
                    {result.type === 'doc' && (
                      <div className="flex items-center gap-1">
                        {result.doc_section && (
                          <span className="text-xs px-2 py-1 rounded bg-[rgba(var(--foreground-rgb),0.1)] text-[rgba(var(--foreground-rgb),0.7)]">
                            {result.doc_section}
                          </span>
                        )}
                        <span className="text-xs px-2 py-1 rounded bg-indigo-500/20 text-indigo-400">
                          DOC
                        </span>
                      </div>
                    )}
                  </div>
                </Link>
              ))
            ) : debouncedSearch && (
              <div className="text-center py-4 text-[rgba(var(--foreground-rgb),0.5)] text-lg">
                No results found
              </div>
            )}
          </div>
        </div>
      </div>
    </>
  )

  return (
    <>
      <button
        onClick={() => setIsOpen(true)}
        className="p-2 hover:bg-[rgba(var(--foreground-rgb),0.1)] rounded-full transition-colors"
      >
        <Search className="w-5 h-5" />
      </button>
      {typeof document !== 'undefined' && createPortal(
        modalContent,
        document.getElementById('modal-root') || document.body
      )}
    </>
  )
}
````

## File: src/components/layout/PageHeader.tsx
````typescript
import { AssetSearch } from '@/modules/assets/AssetSearch'
import { cn } from '@/lib/utils'
import Link from 'next/link'
import { ArrowLeft } from 'lucide-react'

interface Tab {
  value: string
  display: string
  href: string
}

interface PageHeaderProps {
  title: string
  description?: string
  searchQuery?: string
  setSearchQuery?: (query: string) => void
  searchPlaceholder?: string
  showSearch?: boolean
  tabs?: Tab[]
  activeTab?: string
  onTabChange?: (value: string) => void
  variant?: 'default' | 'compact'
  onSearch?: (query: string) => void
  backLink?: string
  showBackArrow?: boolean
}

export function PageHeader({ 
  title, 
  description,
  searchQuery = '', 
  setSearchQuery,
  searchPlaceholder = "Search...",
  showSearch = true,
  tabs,
  activeTab,
  onTabChange,
  variant = 'default',
  onSearch,
  backLink,
  showBackArrow = false
}: PageHeaderProps) {
  // Handle search input
  const handleSearch = (query: string) => {
    if (setSearchQuery) {
      setSearchQuery(query);
    }
    if (onSearch) {
      onSearch(query);
    }
  };

  const headerContent = (
    <>
      <h1 className={cn(
        "font-bold text-center",
        variant === 'compact' ? "text-xl md:text-2xl" : "text-2xl md:text-4xl mb-3 md:mb-4"
      )}>{title}</h1>
      {description && (
        <p className={cn(
          "text-gray-400 text-center max-w-2xl mx-auto text-sm md:text-base",
          variant === 'compact' ? "md:text-left" : "mb-6 md:mb-8"
        )}>{description}</p>
      )}
    </>
  );

  const wrappedContent = showBackArrow && backLink ? (
    <Link href={backLink} className="block">
      <div className="flex justify-center items-center gap-3 group">
        <ArrowLeft className="w-6 h-6 text-gray-400 group-hover:text-white transition-colors" />
        {headerContent}
      </div>
    </Link>
  ) : headerContent;

  if (variant === 'compact') {
    return (
      <div className="flex flex-col md:flex-row items-center justify-center gap-4 md:gap-8 mb-2 px-4 pt-8">
        {wrappedContent}
      </div>
    )
  }

  return (
    <div className="px-4 md:px-6 pt-8">
      {wrappedContent}
      {tabs && (
        <nav className="mb-6 md:mb-8 overflow-x-auto">
          <div className="container mx-auto flex flex-col items-center min-w-full">
            <div className="border-b border-gray-800 w-full">
              <ul className="flex gap-4 md:gap-8 justify-start md:justify-center px-2 md:px-0 whitespace-nowrap">
                {tabs.map((tab) => (
                  <li key={tab.value}>
                    <button
                      onClick={() => onTabChange?.(tab.value)}
                      className={cn(
                        "inline-block py-3 md:py-4 text-sm md:text-base font-medium transition-colors",
                        activeTab === tab.value
                          ? "text-white border-b-2 border-white"
                          : "text-gray-400 hover:text-white"
                      )}
                    >
                      {tab.display}
                    </button>
                  </li>
                ))}
              </ul>
            </div>
          </div>
        </nav>
      )}
      {showSearch && (
        <div className="w-full flex justify-center mb-6 md:mb-8 px-2 md:px-0">
          <AssetSearch 
            searchQuery={searchQuery} 
            setSearchQuery={handleSearch}
            placeholder={searchPlaceholder}
          />
        </div>
      )}
    </div>
  )
}
````

## File: src/components/layout/SubNavigation.tsx
````typescript
'use client'

import Link from 'next/link'
import { usePathname } from 'next/navigation'
import { cn } from '@/lib/utils'

interface SubNavigationProps {
  type: 'accounts' | 'og' | 'assets' | 'certificates';
  groupName?: string;
  compact?: boolean;
}

export function SubNavigation({ type, groupName, compact = false }: SubNavigationProps) {
  const pathname = usePathname()
  
  let links;
  
  if (groupName) {
    links = [
      { href: `/groups/${groupName}/all`, label: 'all' },
      { href: `/groups/${groupName}/create`, label: 'create' },
      { href: `/groups/${groupName}/mine`, label: 'mine' }
    ]
  } else if (type === 'certificates') {
    links = [
      { href: '/certificates/all', label: 'all' },
      { href: '/certificates/create', label: 'create' },
      { href: '/certificates/mine', label: 'mine' }
    ]
  } else {
    links = [
      { href: '/all', label: 'all' },
      { href: '/create', label: 'create' },
      { href: '/mine', label: 'mine' }
    ]
  }

  return (
    <nav className={cn("relative", compact ? "z-10" : "z-20")}>
      <div className={cn(
        "flex justify-center",
        compact ? "" : "container mx-auto px-4"
      )}>
        <ul className={cn(
          "flex",
          compact ? "space-x-4" : "space-x-8"
        )}>
          {links.map(({ href, label }) => {
            const isActive = pathname === href
            return (
              <li key={href} className="block">
                <Link
                  href={href}
                  className={cn(
                    "block transition-colors",
                    compact ? "px-2 py-1 text-sm" : "px-4 py-2",
                    isActive 
                      ? "font-bold text-white" 
                      : "font-normal text-gray-500 hover:text-gray-300"
                  )}
                >
                  {label}
                </Link>
              </li>
            )
          })}
        </ul>
      </div>
    </nav>
  )
}
````

## File: src/components/layout/TokenBalanceDisplay.tsx
````typescript
import { useEffect, useState } from 'react'
import { usePrivy } from '@privy-io/react-auth'
import { createPublicClient, http } from 'viem'
import { base } from 'viem/chains'
import ZORA_1155_ABI from '@/abi/Zora1155proxy.json'

interface TokenBalanceDisplayProps {
  contractAddress: `0x${string}`
  tokenId: bigint
  tokenName?: string
}

export function TokenBalanceDisplay({ contractAddress, tokenId, tokenName }: TokenBalanceDisplayProps) {
  const { user, authenticated } = usePrivy()
  const [balance, setBalance] = useState<bigint>(BigInt(0))

  useEffect(() => {
    const fetchBalance = async () => {
      if (!authenticated || !user?.wallet?.address) return
      try {
        const publicClient = createPublicClient({
          chain: base,
          transport: http()
        })
        const bal = await publicClient.readContract({
          address: contractAddress,
          abi: ZORA_1155_ABI,
          functionName: 'balanceOf',
          args: [user.wallet.address, tokenId]
        }) as bigint
        setBalance(bal)
      } catch (e) {
        setBalance(BigInt(0))
      }
    }
    fetchBalance()
  }, [authenticated, user?.wallet?.address, contractAddress, tokenId])

  return (
    <div className="text-sm text-gray-400 text-center">
      balance: {balance.toString()}
      <div className="text-xs text-gray-500 font-mono mt-0.5">{tokenName || 'Certificate'}</div>
    </div>
  )
}
````

## File: src/components/layout/TokenPriceDisplay.tsx
````typescript
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import { cn } from "@/lib/utils";
import { ArrowUpRight } from "lucide-react";

interface TokenPriceDisplayProps {
  averagePrice?: number | null;
  averagePriceUsd?: number | null;
  floorPrice?: number | null;
  floorPriceUsd?: number | null;
  className?: string;
  configuredPrice?: number | null; // Add configured price for comparison
  alignDollarSign?: boolean; // New prop for columnar alignment
  dollarWidth?: string; // Optional width for $ column
  numberWidth?: string; // Optional width for number column
}

export function TokenPriceDisplay({
  averagePrice,
  averagePriceUsd,
  floorPrice,
  floorPriceUsd,
  className,
  configuredPrice,
  alignDollarSign = false,
  dollarWidth = '1.2em',
  numberWidth = '4em'
}: TokenPriceDisplayProps) {
  const formatUsdValue = (value: number | null) => {
    if (!value) return '-';
    
    return value.toLocaleString('en-US', {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2,
      useGrouping: false
    });
  };

  const formatEthValue = (value: number | null) => {
    if (!value) return '-';
    
    return value.toLocaleString('en-US', {
      minimumFractionDigits: 4,
      maximumFractionDigits: 4
    }) + ' ETH';
  };

  const getValueTooltip = () => {
    let tooltipContent = [];
    
    // Always show average sale price, even if null
    tooltipContent.push(
      `Average Sale: ${averagePrice ? formatEthValue(averagePrice) : 'N/A'} (${averagePriceUsd ? formatUsdValue(averagePriceUsd) : 'N/A'})`
    );
    
    // Always show floor price, even if null
    tooltipContent.push(
      `Floor Price: ${floorPrice ? formatEthValue(floorPrice) : 'N/A'} (${floorPriceUsd ? formatUsdValue(floorPriceUsd) : 'N/A'})`
    );

    // Add arbitrage info if we have both prices
    if (configuredPrice && averagePriceUsd) {
      const priceDiff = averagePriceUsd - configuredPrice;
      const percentDiff = (priceDiff / configuredPrice) * 100;
      tooltipContent.push(
        `\nArbitrage: ${priceDiff > 0 ? '+' : ''}${formatUsdValue(priceDiff)} (${percentDiff > 0 ? '+' : ''}${percentDiff.toFixed(1)}%)`
      );
    }
    
    return tooltipContent.join('\n');
  };

  // Use average price if available, otherwise fall back to floor price
  const displayValue = averagePriceUsd || floorPriceUsd;

  if (!displayValue) return null;

  // Calculate price difference if we have both prices
  const hasArbitrage = configuredPrice && displayValue && displayValue > configuredPrice;
  const priceDiff = hasArbitrage ? displayValue - configuredPrice : 0;
  const percentDiff = hasArbitrage ? (priceDiff / configuredPrice) * 100 : 0;

  return (
    <div className={className}>
      <TooltipProvider>
        <Tooltip>
          <TooltipTrigger asChild>
            {alignDollarSign ? (
              <div className={cn(
                "font-medium flex items-baseline tabular-nums gap-x-1",
                hasArbitrage && "text-green-400"
              )}>
                <span className="inline-block text-right" style={{ width: dollarWidth }}>$</span>
                <span className="inline-block text-right" style={{ width: numberWidth }}>{formatUsdValue(displayValue)}</span>
                {hasArbitrage && (
                  <span className="ml-1 text-xs text-green-400">(+{percentDiff.toFixed(1)}%)</span>
                )}
              </div>
            ) : (
              <div className={cn(
                "font-medium flex items-center gap-1",
                hasArbitrage && "text-green-400"
              )}>
                {formatUsdValue(displayValue)}
                {hasArbitrage && (
                  <span className="text-xs text-green-400">
                    (+{percentDiff.toFixed(1)}%)
                  </span>
                )}
              </div>
            )}
          </TooltipTrigger>
          <TooltipContent>
            <p className="whitespace-pre-line">{getValueTooltip()}</p>
          </TooltipContent>
        </Tooltip>
      </TooltipProvider>
    </div>
  );
}
````

## File: src/components/layout/UtilityLinks.tsx
````typescript
import Link from "next/link"

export function UtilityLinks() {
  return (
    <div className="max-w-3xl mx-auto">
      <div className="flex flex-col items-center gap-4">
        <Link 
          href="http://ensurance.wtf"
          target="_blank"
          rel="noopener noreferrer"
          className="font-space-mono tracking-wider text-blue-400/90 hover:text-blue-300 transition-all duration-300 relative px-3 py-1 rounded-md border border-blue-400/20 hover:border-blue-300/40 animate-pulse-subtle"
        >
          ensurance.wtf
        </Link>
        <Link 
          href="/docs"
          className="font-space-mono tracking-wider text-gray-500 hover:text-gray-300 transition-colors"
        >
          docs
        </Link>
      </div>
    </div>
  )
}
````

## File: src/components/ui/button.tsx
````typescript
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-input hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    return (
      <button
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }
````

## File: src/components/ui/card.tsx
````typescript
import React from 'react';

export const Card: React.FC<React.HTMLAttributes<HTMLDivElement>> = ({ children, className, ...props }) => (
  <div className={`bg-primary-dark border border-gray-800 shadow-sm rounded-lg ${className}`} {...props}>
    {children}
  </div>
);

export const CardContent: React.FC<React.HTMLAttributes<HTMLDivElement>> = ({ children, className, ...props }) => (
  <div className={`p-4 ${className}`} {...props}>
    {children}
  </div>
);

export const CardHeader: React.FC<React.HTMLAttributes<HTMLDivElement>> = ({ children, className, ...props }) => (
  <div className={`px-4 py-5 border-b border-gray-800 ${className}`} {...props}>
    {children}
  </div>
);

export const CardTitle: React.FC<React.HTMLAttributes<HTMLHeadingElement>> = ({ children, className, ...props }) => (
  <h3 className={`text-lg leading-6 font-medium text-gray-100 ${className}`} {...props}>
    {children}
  </h3>
);

export const CardDescription: React.FC<React.HTMLAttributes<HTMLParagraphElement>> = ({ children, className, ...props }) => (
  <p className={`text-sm text-gray-400 ${className}`} {...props}>
    {children}
  </p>
);
````

## File: src/components/ui/dialog.tsx
````typescript
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}
````

## File: src/components/ui/dropdown-menu.tsx
````typescript
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}
````

## File: src/components/ui/input.tsx
````typescript
import * as React from "react"
import { cn } from "@/lib/utils"

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-9 w-full rounded-md border border-gray-800 bg-transparent px-3 py-1 text-sm shadow-sm transition-colors",
          "file:border-0 file:bg-transparent file:text-sm file:font-medium",
          "placeholder:text-gray-500",
          "focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-blue-400",
          "disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }
````

## File: src/components/ui/select.tsx
````typescript
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}
````

## File: src/components/ui/skeleton.tsx
````typescript
import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  )
}

export { Skeleton }
````

## File: src/components/ui/tooltip.tsx
````typescript
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"
import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider
const Tooltip = TooltipPrimitive.Root
const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md bg-black/90 px-3 py-1.5 text-xs text-white animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }
````

## File: src/components/ui/typewriter-effect.tsx
````typescript
'use client'

import { useEffect, useState } from 'react'
import { motion, AnimatePresence } from 'framer-motion'
import { cn } from '@/lib/utils'

interface TypewriterEffectProps {
  words: {
    text: string
  }[]
  className?: string
}

export function TypewriterEffect({ words, className }: TypewriterEffectProps) {
  const [currentIndex, setCurrentIndex] = useState(0)
  const [isVisible, setIsVisible] = useState(true)

  useEffect(() => {
    const intervalId = setInterval(() => {
      setIsVisible(false)
      setTimeout(() => {
        setCurrentIndex((prev) => (prev + 1) % words.length)
        setIsVisible(true)
      }, 400) // Faster fade out
    }, 2000) // More time to read each word

    return () => clearInterval(intervalId)
  }, [words.length])

  return (
    <div className={cn('flex items-center justify-start', className)}>
      <AnimatePresence mode="wait">
        {isVisible && (
          <motion.span
            key={currentIndex}
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -20 }}
            transition={{ 
              duration: 0.4,
              ease: [0.4, 0, 0.2, 1]
            }}
            className={cn("text-2xl md:text-3xl tracking-wide text-white/80 motion-span")}
          >
            {words[currentIndex].text}
          </motion.span>
        )}
      </AnimatePresence>
    </div>
  )
}
````

## File: src/components/ui/typewriter-input.tsx
````typescript
'use client'

import { useEffect, useState } from 'react'
import { motion } from 'framer-motion'
import { cn } from '@/lib/utils'

interface TypewriterWord {
  text: string
  typingSpeed?: number
  deletingSpeed?: number
  pauseTime?: number
}

interface TypewriterInputProps {
  words: TypewriterWord[]
  className?: string
  size?: 'default' | 'small'
}

export function TypewriterInput({ words, className, size = 'default' }: TypewriterInputProps) {
  const [currentWordIndex, setCurrentWordIndex] = useState(0)
  const [currentText, setCurrentText] = useState('')
  const [isDeleting, setIsDeleting] = useState(false)

  useEffect(() => {
    const currentWord = words[currentWordIndex]
    const typingSpeed = currentWord.typingSpeed ?? 100
    const deletingSpeed = currentWord.deletingSpeed ?? 50
    const pauseTime = currentWord.pauseTime ?? 1000

    let timeout: NodeJS.Timeout

    if (!isDeleting) {
      // Typing phase
      if (currentText.length < currentWord.text.length) {
        timeout = setTimeout(() => {
          setCurrentText(currentWord.text.slice(0, currentText.length + 1))
        }, typingSpeed)
      } else {
        // Finished typing, wait then start deleting
        timeout = setTimeout(() => {
          setIsDeleting(true)
        }, pauseTime)
      }
    } else {
      // Deleting phase
      if (currentText.length > 0) {
        timeout = setTimeout(() => {
          setCurrentText(currentWord.text.slice(0, currentText.length - 1))
        }, deletingSpeed)
      } else {
        // Finished deleting, move to next word
        setCurrentWordIndex((prev) => (prev + 1) % words.length)
        setIsDeleting(false)
      }
    }

    return () => {
      if (timeout) {
        clearTimeout(timeout)
      }
    }
  }, [currentText, currentWordIndex, isDeleting, words])

  return (
    <div className={cn('flex items-center justify-center', className)}>
      <motion.span
        key={currentWordIndex}
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        className={cn(
          "text-white/80",
          size === 'default' ? "text-4xl md:text-5xl" : "text-2xl md:text-3xl"
        )}
      >
        {currentText}
        <span className="inline-block w-[2px] h-[1.2em] bg-white/80 animate-blink align-middle ml-[2px]"></span>
      </motion.span>
    </div>
  )
}
````

## File: src/components/ErrorBoundary.tsx
````typescript
// ErrorBoundary Component
// This component catches JavaScript errors anywhere in its child component tree,
// logs those errors, and displays a fallback UI instead of the component tree that crashed.
// It's used to prevent the entire app from crashing when an error occurs in a part of the UI.

import React, { ErrorInfo, ReactNode } from 'react';

interface ErrorBoundaryProps {
  children: ReactNode;
}

interface ErrorBoundaryState {
  hasError: boolean;
  error?: Error;
}

class ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error("Uncaught error:", error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return <h1>Something went wrong: {this.state.error?.message}</h1>;
    }

    return this.props.children;
  }
}

export default ErrorBoundary;
````

## File: src/config/admin.ts
````typescript
const APP_ADMIN_ADDRESSES = [
  '0xEAF9830bB7a38A3CEbcaCa3Ff9F626C424F3fB55',
  '0x79c2D72552Df1C5d551B812Eca906a90Ce9D840A',
  '0xcb598dD4770b06E744EbF5B31Bb3D6a538FBE4fE',
  '0xf843373b1561A362d1410316C8C215719a2FA44b',
  '0x7EdDce062a290c59feb95E2Bd7611eeE24610A6b'
];

export const isAppAdmin = (address: string | undefined): boolean => {
  return address ? APP_ADMIN_ADDRESSES.map(a => a.toLowerCase()).includes(address.toLowerCase()) : false;
};

export const getAppAdminAddresses = (): string[] => {
  return APP_ADMIN_ADDRESSES;
};
````

## File: src/config/chains.ts
````typescript
import { Chain } from 'viem';

interface PrivyChain extends Chain {
  isTestnet: boolean;
  isActive: boolean;
  iconPath: string;
  viemName: string;
}

export const chainOrder = ['base', 'zora', 'arbitrum', 'optimism', 'celo', 'polygon', 'ethereum'];

export const supportedChains: PrivyChain[] = [
  {
    id: 8453,
    name: 'Base',
    viemName: 'base',
    nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
    rpcUrls: {
      default: { http: ['https://mainnet.base.org'] },
    },
    blockExplorers: {
      default: { name: 'BaseScan', url: 'https://basescan.org' },
    },
    isTestnet: false,
    isActive: true,
    iconPath: '/assets/icons/base.svg',
  },
  {
    id: 1,
    name: 'Ethereum',
    viemName: 'mainnet',
    nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
    rpcUrls: {
      default: { http: ['https://ethereum.publicnode.com'] },
      public: { http: ['https://ethereum.publicnode.com'] },
    },
    blockExplorers: {
      default: { name: 'Etherscan', url: 'https://etherscan.io' },
    },
    isTestnet: false,
    isActive: true,
    iconPath: '/assets/icons/ethereum.svg',
  },
  {
    id: 10,
    name: 'Optimism',
    viemName: 'optimism',
    nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
    rpcUrls: {
      default: { http: ['https://mainnet.optimism.io'] },
    },
    blockExplorers: {
      default: { name: 'OptimismScan', url: 'https://optimism.io' },
    },
    isTestnet: false,
    isActive: true,
    iconPath: '/assets/icons/optimism.svg',
  },
  {
    id: 42161,
    name: 'Arbitrum',
    viemName: 'arbitrum',
    nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
    rpcUrls: {
      default: { http: ['https://arb1.arbitrum.io/rpc'] },
    },
    blockExplorers: {
      default: { name: 'ArbitrumScan', url: 'https://arbiscan.io' },
    },
    isTestnet: false,
    isActive: true,
    iconPath: '/assets/icons/arbitrum.png',
  },
  {
    id: 7777777,
    name: 'Zora',
    viemName: 'zora',
    nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
    rpcUrls: {
      default: { http: ['https://rpc.zora.energy'] },
    },
    blockExplorers: {
      default: { name: 'ZoraScan', url: 'https://zorascan.io' },
    },
    isTestnet: false,
    isActive: true,
    iconPath: '/assets/icons/zora.png',
  },
  {
    id: 42220,
    name: 'Celo',
    viemName: 'celo',
    nativeCurrency: { name: 'CELO', symbol: 'CELO', decimals: 18 },
    rpcUrls: {
      default: { http: ['https://forno.celo.org'] },
    },
    blockExplorers: {
      default: { name: 'CeloScan', url: 'https://celoscan.org' },
    },
    isTestnet: false,
    isActive: false,
    iconPath: '/assets/icons/celo.svg',
  },
  {
    id: 137,
    name: 'Polygon',
    viemName: 'polygon',
    nativeCurrency: { name: 'MATIC', symbol: 'MATIC', decimals: 18 },
    rpcUrls: {
      default: { http: ['https://polygon-rpc.com'] },
    },
    blockExplorers: {
      default: { name: 'PolygonScan', url: 'https://polygonscan.com' },
    },
    isTestnet: false,
    isActive: true,
    iconPath: '/assets/icons/polygon.svg',
  },
];

export const getChainById = (id: number) => supportedChains.find(chain => chain.id === id);
export const getChainByName = (name: string) => supportedChains.find(chain => chain.viemName === name);

export const getActiveChains = () => {
  const activeChains = supportedChains.filter(chain => chain.isActive);
  return activeChains;
}

export const getActiveChainNames = () => getActiveChains().map(chain => chain.viemName).join(',');

export const getOrderedActiveChains = () => {
  const activeChains = getActiveChains();
  return chainOrder.filter(chain => activeChains.some(ac => ac.viemName === chain));
}

export const getChainIcon = (chain: string): string => {
  const chainConfig = getChainByName(chain);
  return chainConfig ? chainConfig.iconPath : '';
};
````

## File: src/config/routes.ts
````typescript
// Simple config for domain
export const siteConfig = {
    prodDomain: 'ensurance.app',
    appDir: '/app'
}

// Get the API prefix for requests
export function getApiPrefix(): string {
    return '/api'
}

// Simple helper to get the URL prefix for client routes
export function getBasePath(): string {
    return ''
}
````

## File: src/config/tokenbound.ts
````typescript
import { type WalletClient, type Account, type Chain } from 'viem'
import { base } from 'viem/chains'
import { TokenboundClient } from '@tokenbound/sdk'

// @keep TokenBound requires either a signer or walletClient for initialization
interface TokenBoundWalletConfig {
  walletClient: WalletClient;
  chain?: Chain;
}

// @keep Base chain configuration for TokenBound
export const tokenboundConfig = {
  chain: base,
  chainId: base.id
};

// @keep Helper function for TokenBound client configuration
export const getTokenBoundClientConfig = (wallet?: TokenBoundWalletConfig) => ({
  chainId: tokenboundConfig.chainId,
  chain: tokenboundConfig.chain,
  walletClient: wallet?.walletClient
});

// @keep Create a standardized TokenboundClient instance
export const createTokenboundClient = (walletClient: WalletClient) => {
  return new TokenboundClient({
    chainId: tokenboundConfig.chainId,
    chain: tokenboundConfig.chain,
    walletClient
  });
};

// @keep Validate we are operating on Base chain
export const isTokenBoundSupportedChain = (chainId: number) => 
  chainId === tokenboundConfig.chainId;
````

## File: src/config/zora.ts
````typescript
import { setApiKey } from '@zoralabs/coins-sdk'

// Set Zora API key from environment variable
if (process.env.ZORA_COINS_API_KEY) {
  setApiKey(process.env.ZORA_COINS_API_KEY)
  console.log('Zora API key configured')
} else {
  console.warn('ZORA_COINS_API_KEY not found in environment variables')
}
````

## File: src/hooks/useDebounce.ts
````typescript
import { useState, useEffect } from 'react'

export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value)

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value)
    }, delay)

    return () => {
      clearTimeout(handler)
    }
  }, [value, delay])

  return debouncedValue
}
````

## File: src/hooks/useEnsureData.ts
````typescript
import { useState, useEffect } from 'react'

// Types for different certificate types
export interface GeneralCertificate {
  contract_address: string
  name: string
  description?: string
  image_url?: string
  type: 'general'
}

export interface SpecificCertificate {
  tokenURI: string
  type: 'specific'
  metadata?: {
    name?: string
    description?: string
    image?: string
    error?: boolean
  }
}

export interface Account {
  full_account_name: string
  token_id: number
  group_name: string
  is_agent: boolean
  description?: string
  type: 'account'
}

export interface Group {
  group_name: string
  name_front: string | null
  tagline: string | null
  description?: string
  total_supply: number
  contract_address: string
  is_active: boolean
  type: 'group'
}

export interface Syndicate {
  name: string
  description?: string
  media?: {
    banner?: string
  }
  image_url?: string
  type: 'syndicate'
}

export type Certificate = GeneralCertificate | SpecificCertificate | Account | Group | Syndicate

// Type guard functions
export function isGeneralCertificate(item: Certificate): item is GeneralCertificate {
  return item.type === 'general'
}

export function isSpecificCertificate(item: Certificate): item is SpecificCertificate {
  return item.type === 'specific'
}

export function isAccount(item: Certificate): item is Account {
  return item.type === 'account'
}

export function isGroup(item: Certificate): item is Group {
  return item.type === 'group'
}

export function isSyndicate(item: Certificate): item is Syndicate {
  return item.type === 'syndicate'
}

export function useEnsureData({ waitForAll = false }: { waitForAll?: boolean } = {}) {
  const [items, setItems] = useState<Certificate[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [tokenMetadata, setTokenMetadata] = useState<Record<string, any>>({})

  useEffect(() => {
    let mounted = true
    setLoading(true)
    setError(null)

    const fetchData = async () => {
      try {
        // Use the new unified endpoint
        const url = waitForAll ? '/api/ensure?metadata=true' : '/api/ensure?metadata=false'
        const response = await fetch(url)
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`)
        }
        
        const data = await response.json()
        
        if (data.error) {
          throw new Error(data.error)
        }

        if (mounted) {
          setItems(data.items || [])
          setTokenMetadata(data.tokenMetadata || {})
          
          // If not waiting for all metadata, fetch it in background
          if (!waitForAll && data.items?.some((item: Certificate) => item.type === 'specific')) {
            // Fetch metadata in background
            fetch('/api/ensure?metadata=true')
              .then(res => res.json())
              .then(backgroundData => {
                if (mounted && backgroundData.tokenMetadata) {
                  setTokenMetadata(backgroundData.tokenMetadata)
                }
              })
              .catch(err => console.error('Background metadata fetch failed:', err))
          }
          
          setLoading(false)
        }
      } catch (err) {
        console.error('Error fetching ensure data:', err)
        if (mounted) {
          setError(err instanceof Error ? err.message : 'Failed to load data')
          setLoading(false)
        }
      }
    }

    fetchData()
    
    return () => {
      mounted = false
    }
  }, [waitForAll])

  return { 
    items, 
    loading, 
    error, 
    tokenMetadata,
    // Remove setSearchQuery as filtering will be handled by the component
  }
}
````

## File: src/hooks/useIsAdmin.ts
````typescript
import { usePrivy } from '@privy-io/react-auth'

// List of admin wallet addresses
const ADMIN_ADDRESSES = [
  '0x6F7C23F9E5cF62E6Bf8f63d4Be94624F2B7C4D94'.toLowerCase() // Replace with actual admin addresses
]

export function useIsAdmin() {
  const { user, authenticated } = usePrivy()
  
  if (!authenticated || !user?.wallet?.address) return false
  
  return ADMIN_ADDRESSES.includes(user.wallet.address.toLowerCase())
}
````

## File: src/lib/database/admin/export.ts
````typescript
import { accounts } from '../accounts'
import { groups } from '../groups'
import { sql } from '@vercel/postgres'

export interface TableInfo {
  table_name: string
  columns: string[]
  primary_key: string
}

// Get list of tables and their columns that are available for export
export async function getExportableTables(): Promise<TableInfo[]> {
  const tables: TableInfo[] = [
    {
      table_name: 'groups',
      primary_key: 'group_name',
      columns: ['group_name', 'name_front', 'tagline', 'description', 'email', 'website', 'chat', 'situs_account', 'contract_address', 'total_supply']
    }
  ]

  // Get all tables from our schemas
  const { rows: allTables } = await sql`
    SELECT table_schema, table_name 
    FROM information_schema.tables 
    WHERE table_schema IN ('agents', 'binder', 'certificates', 'market', 'members', 'proceeds', 'syndicates')
    AND table_type = 'BASE TABLE'
    ORDER BY table_schema, table_name
  `

  // For each table, get its columns
  for (const { table_schema, table_name } of allTables) {
    // Skip groups since we handle it separately
    if (table_schema === 'members' && table_name === 'groups') continue

    // Get columns for this table
    const { rows: columns } = await sql`
      SELECT column_name
      FROM information_schema.columns
      WHERE table_schema = ${table_schema}
      AND table_name = ${table_name}
      ORDER BY ordinal_position
    `
    
    tables.push({
      table_name: `${table_schema}.${table_name}`,
      primary_key: table_name.startsWith('accounts_') ? 'token_id' : columns[0]?.column_name,
      columns: columns.map(col => col.column_name)
    })
  }

  return tables
}

// Export table data based on selected columns
export async function exportTableData(table: string, columns: string[]): Promise<any[]> {
  // Handle schema-qualified table names
  const [schema, tableName] = table.includes('.') ? table.split('.') : ['members', table]

  // Special handling for groups
  if (schema === 'members' && tableName === 'groups') {
    return await groups.getAll(true) // Include inactive groups
  }

  // For all other tables, use dynamic SQL
  const columnsStr = columns.map(c => `"${c}"`).join(', ')
  const schemaTable = `"${schema}"."${tableName}"`
  
  // Execute the query
  const result = await sql.query(
    `SELECT ${columnsStr} FROM ${schemaTable} ORDER BY ${columns[0]}`
  )
  return result.rows
}
````

## File: src/lib/database/certificates/general.ts
````typescript
import { sql } from '@vercel/postgres';
import { getCoin } from '@zoralabs/coins-sdk';
import { client } from '@/modules/admin/sync/service';
import ZORA_COIN_ABI from '@/abi/ZoraCoin.json';
import type { SyncResult, GeneralCertificateData } from '@/modules/admin/sync/types';

interface GeneralCertificate {
  contract_address: string;
  chain: string;
  name: string | null;
  symbol: string | null;
  decimals: number;
  token_uri: string | null;
  description: string | null;
  pool_address: string | null;
  total_volume?: string;
  volume_24h?: string;
  market_cap?: string;
  creator_earnings?: any[];
  unique_holders?: number;
  last_market_update?: string;
  payout_recipient?: string;
}

interface UpdateFromChainData {
  name: string;
  symbol: string;
  token_uri: string;
  description?: string;
  pool_address: string;
  payout_recipient: string;
}

// Helper function to convert IPFS URLs
const convertIpfsUrl = (url: string) => {
  if (!url) return undefined;
  if (url.startsWith('ipfs://')) {
    return url.replace('ipfs://', 'https://magic.decentralized-content.com/ipfs/');
  }
  return url;
};

// Helper function to fetch metadata from token URI
const fetchMetadataFromUri = async (tokenUri: string): Promise<{ description?: string }> => {
  try {
    const metadataUrl = convertIpfsUrl(tokenUri);
    if (!metadataUrl) return {};
    
    const response = await fetch(metadataUrl);
    if (!response.ok) return {};
    
    const metadata = await response.json();
    return {
      description: metadata.description || undefined
    };
  } catch (error) {
    console.error('Failed to fetch metadata:', error);
    return {};
  }
};

export const generalCertificates = {
  /**
   * Get all certificates that need syncing
   */
  async getCertificatesForSync(empty_only: boolean = false): Promise<GeneralCertificate[]> {
    const query = empty_only 
      ? sql`SELECT * FROM certificates.general WHERE chain = 'base' AND (name IS NULL OR symbol IS NULL OR token_uri IS NULL OR pool_address IS NULL OR payout_recipient IS NULL OR description IS NULL)`
      : sql`SELECT * FROM certificates.general WHERE chain = 'base'`;

    const { rows } = await query;
    return rows as GeneralCertificate[];
  },

  /**
   * Update certificate data from chain
   */
  async updateFromChain(cert: GeneralCertificate, data: {
    name: string;
    symbol: string;
    token_uri: string;
    description?: string;
    pool_address?: string;
    payout_recipient: string;
  }): Promise<void> {
    await sql`
      UPDATE certificates.general
      SET 
        name = ${data.name},
        symbol = ${data.symbol},
        token_uri = ${data.token_uri},
        description = ${data.description || null},
        pool_address = ${data.pool_address},
        payout_recipient = ${data.payout_recipient}
      WHERE contract_address = ${cert.contract_address}
    `;
  },

  /**
   * Update certificate with market data
   */
  async updateMarketData(cert: GeneralCertificate, data: {
    total_supply: string;
    total_volume: string;
    volume_24h: string;
    market_cap: string;
    creator_earnings: any[];
    unique_holders: number;
  }): Promise<void> {
    await sql`
      UPDATE certificates.general 
      SET 
        total_supply = ${data.total_supply},
        total_volume = ${data.total_volume},
        volume_24h = ${data.volume_24h},
        market_cap = ${data.market_cap},
        creator_earnings = ${JSON.stringify(data.creator_earnings)},
        unique_holders = ${data.unique_holders},
        last_market_update = NOW()
      WHERE 
        contract_address = ${cert.contract_address} 
        AND chain = ${cert.chain}
    `;
  },

  /**
   * Get all certificates with optional market data
   */
  async getAll(): Promise<GeneralCertificate[]> {
    const { rows } = await sql`SELECT * FROM certificates.general`;
    return rows as GeneralCertificate[];
  },

  /**
   * Get single certificate by contract address
   */
  async getByContractAddress(contract_address: string): Promise<GeneralCertificate | null> {
    const { rows } = await sql`
      SELECT * FROM certificates.general 
      WHERE contract_address = ${contract_address}
    `;
    return rows[0] as GeneralCertificate || null;
  },

  /**
   * Sync a single certificate's data from the blockchain
   */
  async syncFromChain(cert: GeneralCertificate): Promise<SyncResult> {
    try {
      // Get basic data from chain (these are common to both V3 and V4)
      const [name, symbol, tokenUri, payoutRecipient] = await Promise.all([
        client.readContract({
          address: cert.contract_address as `0x${string}`,
          abi: ZORA_COIN_ABI,
          functionName: 'name'
        }) as Promise<string>,
        client.readContract({
          address: cert.contract_address as `0x${string}`,
          abi: ZORA_COIN_ABI,
          functionName: 'symbol'
        }) as Promise<string>,
        client.readContract({
          address: cert.contract_address as `0x${string}`,
          abi: ZORA_COIN_ABI,
          functionName: 'tokenURI'
        }) as Promise<string>,
        client.readContract({
          address: cert.contract_address as `0x${string}`,
          abi: ZORA_COIN_ABI,
          functionName: 'payoutRecipient'
        }) as Promise<string>
      ]);

      // Try to get pool address (V3 only)
      let poolAddress: string | undefined;
      try {
        poolAddress = await client.readContract({
          address: cert.contract_address as `0x${string}`,
          abi: ZORA_COIN_ABI,
          functionName: 'poolAddress'
        }) as string;
      } catch (err) {
        // If poolAddress() fails, it's likely a V4 contract
        console.log(`No pool address for ${cert.contract_address} (likely V4 contract)`);
      }

      // Fetch description from token URI metadata
      let description: string | undefined;
      try {
        const metadata = await fetchMetadataFromUri(tokenUri);
        description = metadata.description;
      } catch (err) {
        console.log(`Failed to fetch metadata for ${cert.contract_address}:`, err);
      }

      // Update certificate in database
      await this.updateFromChain(cert, {
        name,
        symbol,
        token_uri: tokenUri,
        description,
        pool_address: poolAddress,
        payout_recipient: payoutRecipient
      });

      const data: GeneralCertificateData = {
        contract_address: cert.contract_address,
        chain: cert.chain,
        name,
        symbol,
        token_uri: tokenUri,
        description,
        pool_address: poolAddress,
        payout_recipient: payoutRecipient
      };

      return {
        id: cert.contract_address,
        status: 'success',
        data
      };

    } catch (err: any) {
      return {
        id: cert.contract_address,
        status: 'failed',
        error: err.message
      };
    }
  },

  /**
   * Sync multiple certificates with rate limiting
   */
  async syncBatch(certificates: GeneralCertificate[], options: { batchSize?: number; batchDelay?: number } = {}): Promise<SyncResult[]> {
    const { batchSize = 3, batchDelay = 500 } = options;
    const results: SyncResult[] = [];

    console.log(`Processing ${certificates.length} certificates in batches of ${batchSize}...`);

    for (let i = 0; i < certificates.length; i += batchSize) {
      const batch = certificates.slice(i, i + batchSize);
      const batchNumber = Math.floor(i / batchSize) + 1;
      const totalBatches = Math.ceil(certificates.length / batchSize);
      
      console.log(`\nProcessing batch ${batchNumber}/${totalBatches} (${batch.length} certificates)...`);
      console.log(`Addresses: ${batch.map(c => c.contract_address).join(', ')}`);
      
      // Process each certificate in the current batch in parallel
      const batchPromises = batch.map(cert => this.syncFromChain(cert));
      const batchResults = await Promise.all(batchPromises);
      results.push(...batchResults);

      // Log batch results
      const batchSuccess = batchResults.filter(r => r.status === 'success').length;
      const batchFailed = batchResults.filter(r => r.status === 'failed').length;
      console.log(`Batch ${batchNumber} complete: ${batchSuccess} success, ${batchFailed} failed`);

      // Add delay between batches (except for the last batch)
      if (i + batchSize < certificates.length) {
        console.log(`Waiting ${batchDelay}ms before next batch...`);
        await new Promise(resolve => setTimeout(resolve, batchDelay));
      }
    }

    return results;
  }
};
````

## File: src/lib/database/certificates/specific.ts
````typescript
import { sql } from '@vercel/postgres';
import { CONTRACTS } from '@/modules/specific/config';
import type { SpecificMetadata } from '@/modules/specific/types';

interface SpecificCertificate {
  token_id: number;
  contract_address: string;
  chain: string;
  name: string;
  description: string | null;
  image: string;
  animation_url: string | null;
  mime_type: string;
  attributes: Record<string, any> | null;
  created_at: string;
  updated_at: string;
}

export const specificCertificates = {
  /**
   * Store metadata for a specific certificate
   */
  async storeMetadata(
    tokenId: string,
    metadata: SpecificMetadata
  ): Promise<void> {
    await sql`
      INSERT INTO certificates.specific (
        token_id,
        contract_address,
        chain,
        name,
        description,
        image,
        animation_url,
        mime_type,
        attributes
      ) VALUES (
        ${Number(tokenId)},
        ${CONTRACTS.specific},
        'base',
        ${metadata.name},
        ${metadata.description},
        ${metadata.image},
        ${metadata.animation_url || null},
        ${metadata.content?.mime || 'image/png'},
        ${metadata.attributes ? JSON.stringify(metadata.attributes) : null}
      )
      ON CONFLICT (token_id, contract_address) 
      DO UPDATE SET
        name = EXCLUDED.name,
        description = EXCLUDED.description,
        image = EXCLUDED.image,
        animation_url = EXCLUDED.animation_url,
        mime_type = EXCLUDED.mime_type,
        attributes = EXCLUDED.attributes,
        updated_at = NOW()
    `;
  },

  /**
   * Get metadata for a specific certificate
   */
  async getMetadata(tokenId: string): Promise<SpecificCertificate | null> {
    const { rows } = await sql`
      SELECT * FROM certificates.specific 
      WHERE token_id = ${Number(tokenId)}
      AND contract_address = ${CONTRACTS.specific}
    `;
    return rows[0] as SpecificCertificate || null;
  },

  /**
   * Get all specific certificates
   */
  async getAll(): Promise<SpecificCertificate[]> {
    const { rows } = await sql`
      SELECT * FROM certificates.specific 
      WHERE contract_address = ${CONTRACTS.specific}
    `;
    return rows as SpecificCertificate[];
  }
};
````

## File: src/lib/database/config/currencies.ts
````typescript
import { sql } from '@vercel/postgres';
import { getCoin } from '@zoralabs/coins-sdk';
import { base } from 'viem/chains';

interface Currency {
  address: string;
  chain: string;
  symbol: string;
  name: string;
  decimals: number;
  is_active: boolean;
  token_uri?: string;
  img_fallback?: string;
  last_market_update?: string;
  market_data?: any;
}

export const currencies = {
  /**
   * Get all active currencies
   */
  async getAll(): Promise<Currency[]> {
    const { rows } = await sql`
      SELECT contract_address as address, symbol, decimals 
      FROM config.currencies 
      WHERE chain = 'base'
      ORDER BY symbol
    `;
    return rows as Currency[];
  },

  /**
   * Get single currency by address
   */
  async getByAddress(address: string): Promise<Currency | null> {
    const { rows } = await sql`
      SELECT * FROM config.currencies 
      WHERE contract_address = ${address}
    `;
    return rows[0] as Currency || null;
  },

  /**
   * Update currency market data
   */
  async updateMarketData(currency: Currency, data: {
    market_data: any;
  }): Promise<void> {
    await sql`
      UPDATE config.currencies 
      SET 
        market_data = ${JSON.stringify(data.market_data)},
        last_market_update = NOW()
      WHERE 
        address = ${currency.address} 
        AND chain = ${currency.chain}
    `;
  }
};
````

## File: src/lib/database/accounts.ts
````typescript
import { sql } from '@vercel/postgres';
import { TokenboundClient } from "@tokenbound/sdk";
import { getTokenBoundClientConfig } from '@/config/tokenbound';
import { Group, GroupAccount } from '@/types';

export const accounts = {
    // Get ALL accounts across active groups
    getAll: async () => {
        try {
            // Get active groups from database
            const groups = await sql`
                SELECT group_name 
                FROM members.groups 
                WHERE is_active = true 
                ORDER BY group_name
            `;
            
            let allAccounts: Array<{
                full_account_name: string;
                token_id: string;
                is_agent: boolean;
                group_name: string;
            }> = [];
            
            // Query each active group's table
            for (const group of groups.rows) {
                const tableName = `accounts_${group.group_name.startsWith('.') ? group.group_name.substring(1) : group.group_name}`; // Handle both formats
                try {
                    console.log(`Querying table: members.${tableName}`);
                    const result = await sql.query(
                        `SELECT 
                            full_account_name,
                            token_id,
                            is_agent,
                            tba_address,
                            '${group.group_name}' as group_name
                        FROM members.${tableName}`
                    );
                    allAccounts = [...allAccounts, ...result.rows];
                } catch (error: unknown) {
                    if (error instanceof Error) {
                        console.error(`Error querying ${tableName}:`, error.message);
                    }
                    continue;
                }
            }
            
            // Sort results: agents first, then alphabetically
            return allAccounts.sort((a, b) => {
                // First sort by is_agent
                if (a.is_agent !== b.is_agent) return a.is_agent ? -1 : 1;
                
                // Then handle null names and sort alphabetically
                if (!a.full_account_name && !b.full_account_name) return 0;
                if (!a.full_account_name) return 1;  // null values go to end
                if (!b.full_account_name) return -1;
                return a.full_account_name.localeCompare(b.full_account_name);
            });
            
        } catch (error: unknown) {
            if (error instanceof Error) {
                console.error('Database query error:', error);
            }
            throw error;
        }
    },

    // Get minimal data for search results
    getSearchResults: async () => {
        try {
            // Get active groups from database
            const groups = await sql`
                SELECT group_name 
                FROM members.groups 
                WHERE is_active = true 
                ORDER BY group_name
            `;
            
            let allAccounts: Array<{
                full_account_name: string;
                is_agent: boolean;
                group_name: string;
            }> = [];
            
            // Query each active group's table
            for (const group of groups.rows) {
                const tableName = `accounts_${group.group_name.startsWith('.') ? group.group_name.substring(1) : group.group_name}`; // Handle both formats
                try {
                    const result = await sql.query(
                        `SELECT DISTINCT
                            full_account_name,
                            is_agent,
                            token_id,
                            tba_address,
                            '${group.group_name}' as group_name
                        FROM members.${tableName}
                        WHERE is_active = true`
                    );
                    allAccounts = [...allAccounts, ...result.rows];
                } catch (error: unknown) {
                    if (error instanceof Error) {
                        console.error(`Error querying ${tableName}:`, error.message);
                    }
                    continue; // Skip failed tables and continue with others
                }
            }
            
            // Sort results: agents first, then alphabetically
            return allAccounts.sort((a, b) => {
                // First sort by is_agent
                if (a.is_agent !== b.is_agent) return a.is_agent ? -1 : 1;
                
                // Then handle null names and sort alphabetically
                if (!a.full_account_name && !b.full_account_name) return 0;
                if (!a.full_account_name) return 1;  // null values go to end
                if (!b.full_account_name) return -1;
                return a.full_account_name.localeCompare(b.full_account_name);
            });
        } catch (error: unknown) {
            if (error instanceof Error) {
                console.error('Error fetching search results:', error);
            }
            return [];
        }
    },

    // Get single account by full name (e.g., "alice.earth")
    getByFullName: async (fullAccountName: string) => {
        // Ensure we're working with the decoded version of the account name
        const decodedName = decodeURIComponent(fullAccountName);
        const parts = decodedName.split('.');
        if (parts.length !== 2) {
            console.log('Invalid account name format:', decodedName);
            return null;
        }

        const groupName = parts[1];
        const tableName = `accounts_${groupName}`;
        const isEnsurance = groupName === 'ensurance';
        
        try {
            // Keep schema for groups table
            const groupResult = await sql`
                SELECT contract_address
                FROM members.groups
                WHERE group_name = ${`.${groupName}`}
                LIMIT 1
            `;

            if (!groupResult.rows.length) {
                console.log('No group found for:', groupName);
                return null;
            }
            
            // Query by full_account_name - use the decoded name for comparison
            const query = `
                SELECT 
                    full_account_name,
                    tba_address,
                    token_id,
                    is_agent,
                    account_name,
                    ${isEnsurance ? 'stock_or_flow, display_name,' : ''}
                    description,
                    specific_asset_id,
                    $2 as group_name
                FROM members.${tableName}
                WHERE full_account_name = $1
                LIMIT 1
            `;
            
            const result = await sql.query(query, [decodedName, groupName]);
            
            if (!result.rows.length) {
                console.log('No account found for:', decodedName);
                return null;
            }
            
            const row = result.rows[0];
            
            // Return the account data
            const returnObj = {
                full_account_name: row.full_account_name,
                tba_address: row.tba_address,
                token_id: row.token_id,
                is_agent: row.is_agent,
                description: row.description,
                specific_asset_id: row.specific_asset_id,
                group_name: groupName,
                ...(isEnsurance && { 
                    stock_or_flow: row.stock_or_flow,
                    display_name: row.display_name
                })
            };
            console.log('Returning object:', returnObj);
                        
            return returnObj;
        } catch (error) {
            console.error('Error fetching account:', error);
            return null;
        }
    },

    // Get accounts for a specific group
    getByGroup: async (groupName: string): Promise<GroupAccount[]> => {
        try {
            // Remove leading dot if present
            const cleanGroupName = groupName.startsWith('.') ? groupName.substring(1) : groupName;
            const tableName = `accounts_${cleanGroupName}`;
            const isEnsurance = cleanGroupName === 'ensurance';
            
            console.log(`Querying group table: members.${tableName}`);
            const result = await sql.query(
                `SELECT 
                    full_account_name,
                    token_id,
                    is_agent,
                    tba_address,
                    '.${cleanGroupName}' as group_name
                    ${isEnsurance ? ', stock_or_flow, display_name' : ''}
                FROM members.${tableName}`
            );
            
            // Sort results: agents first, then alphabetically
            return result.rows.sort((a, b) => {
                // First sort by is_agent
                if (a.is_agent !== b.is_agent) return a.is_agent ? -1 : 1;
                
                // Then handle null names and sort alphabetically
                if (!a.full_account_name && !b.full_account_name) return 0;
                if (!a.full_account_name) return 1;  // null values go to end
                if (!b.full_account_name) return -1;
                return a.full_account_name.localeCompare(b.full_account_name);
            });
            
        } catch (error: unknown) {
            if (error instanceof Error) {
                console.error(`Error fetching accounts for group ${groupName}:`, error);
            }
            throw error;
        }
    }
};
````

## File: src/lib/database/groups.ts
````typescript
import { sql } from '@vercel/postgres';

// All group operations in one place
export const groups = {
    // Get minimal data for search results
    getSearchResults: async () => {
        try {
            const result = await sql`
                SELECT 
                    group_name,
                    name_front
                FROM members.groups 
                WHERE is_active = true
                ORDER BY group_name
            `;
            return result.rows;
        } catch (error) {
            console.error('Database query error:', error);
            throw error;
        }
    },
    
    // Get all groups
    getAll: async (includeInactive = false) => {
        const result = await sql`
            SELECT * FROM members.groups 
            WHERE is_active = true 
            ORDER BY group_name`;
        return result.rows;
    },
    
    // Get single group
    getByName: async (groupName: string) => {
        const result = await sql`
            WITH group_data AS (
                SELECT 
                    group_name,
                    name_front,
                    tagline,
                    description,
                    email,
                    website,
                    chat,
                    situs_account,
                    contract_address,
                    total_supply
                FROM members.groups 
                WHERE group_name = ${groupName}
            )
            SELECT 
                g.*,
                s.tba_address
            FROM group_data g
            LEFT JOIN members.accounts_situs s ON s.full_account_name = g.situs_account
            LIMIT 1`;
        return result.rows[0];
    },
    
    // Create group
    // Note: This is for initial group creation only. contract_address (which is NOT NULL in DB) 
    // must be added separately after contract deployment. For groups found during sync,
    // we'll need a different approach that includes contract_address.
    create: async (data: {
        group_name: string,
        name_front?: string,
        tagline?: string,
        description?: string,
        email?: string,
        website?: string,
        chat?: string,
        situs_account?: string
    }) => {
        const result = await sql`
            INSERT INTO members.groups (
                group_name, 
                name_front, 
                tagline, 
                description, 
                email, 
                website, 
                chat,
                situs_account
            ) VALUES (
                ${data.group_name},
                ${data.name_front},
                ${data.tagline},
                ${data.description},
                ${data.email},
                ${data.website},
                ${data.chat},
                ${data.situs_account}
            ) 
            RETURNING *`;
        return result.rows[0];
    }
};
````

## File: src/lib/database/metadata.ts
````typescript
import { sql } from '@vercel/postgres';
import { ImageGenerator } from '@/modules/metadata/ImageGenerator';
import { sync } from '@/modules/admin/sync/service';
import { createPublicClient, http } from 'viem';
import { base } from 'viem/chains';
import { CONTRACTS } from '@/modules/specific/config';

// Initialize Viem client
const client = createPublicClient({
    chain: base,
    transport: http()
});

// Contract ABI for checking token existence
const GROUP_ABI = [
    {
        "inputs": [{"type": "uint256"}],
        "name": "domainIdsNames",
        "outputs": [{"type": "string"}],
        "stateMutability": "view",
        "type": "function"
    }
] as const;

// Helper to check if image exists
async function checkImageExists(url: string): Promise<boolean> {
    try {
        const response = await fetch(url, { method: 'HEAD' });
        return response.ok;
    } catch {
        return false;
    }
}

// Helper to check if table exists
async function checkTableExists(tableName: string): Promise<boolean> {
    try {
        const result = await sql`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_schema = 'members'
                AND table_name = ${tableName}
            );
        `;
        return result.rows[0].exists;
    } catch {
        return false;
    }
}

export const metadata = {
    // Get NFT metadata by contract and token ID
    getByContractAndToken: async (contract: string, tokenId: string) => {
        try {
            // Check if this is a specific token
            if (contract.toLowerCase() === CONTRACTS.specific.toLowerCase()) {
                // Get specific token data
                const { rows: [token] } = await sql`
                    SELECT * FROM certificates.specific 
                    WHERE token_id = ${Number(tokenId)}
                    LIMIT 1
                `;

                if (!token) {
                    return {
                        error: `Token ${tokenId} not found`,
                        status: 404
                    };
                }

                return {
                    name: token.name,
                    description: token.description || 'A Specific Certificate for Natural Capital',
                    image: token.image,
                    animation_url: token.animation_url || null,
                    content: {
                        mime: token.mime_type || null,
                        uri: token.animation_url || token.image
                    },
                    attributes: token.attributes || []
                };
            }

            // Get group info from contract address
            const { rows: [group] } = await sql`
                SELECT * FROM members.groups 
                WHERE decode(replace(contract_address, '0x', ''), 'hex') = decode(replace(${contract}, '0x', ''), 'hex')
            `;

            if (!group) {
                return {
                    error: 'Group not found',
                    status: 404
                };
            }

            // Remove leading dot for table name
            const sanitizedGroup = group.group_name.startsWith('.') ? group.group_name.slice(1) : group.group_name;
            const tableName = `accounts_${sanitizedGroup}`;

            // Check if table exists
            const tableExists = await checkTableExists(tableName);
            if (!tableExists) {
                return {
                    error: `Accounts table for group ${group.group_name} does not exist`,
                    status: 404
                };
            }

            // Check if token exists on-chain using domainIdsNames
            console.log('Checking if token exists on-chain:', tokenId);
            let accountName;
            try {
                accountName = await client.readContract({
                    address: contract as `0x${string}`,
                    abi: GROUP_ABI,
                    functionName: 'domainIdsNames',
                    args: [BigInt(tokenId)]
                });

                // If account name is empty or just the group name, token doesn't exist
                if (!accountName || accountName === group.group_name) {
                    console.log('Token does not exist on-chain');
                    
                    // Clean up any existing row
                    await sql.query(
                        `DELETE FROM members.${tableName} WHERE token_id = $1`,
                        [tokenId]
                    );
                    
                    return {
                        error: `Token ${tokenId} does not exist on-chain`,
                        status: 404
                    };
                }

                console.log('Token exists on-chain with name:', accountName);
            } catch (error) {
                console.error('Error checking token on-chain:', error);
                return {
                    error: `Failed to verify token ${tokenId} on chain`,
                    status: 500
                };
            }

            // If we get here, token exists on-chain
            console.log('Token exists on-chain, proceeding with sync');

            // Sync token data
            await sync('accounts', { 
                group_name: group.group_name, 
                token_id: parseInt(tokenId) 
            });

            // Get synced account data
            const { rows: [syncedAccount] } = await sql.query(
                `SELECT 
                    token_id,
                    account_name,
                    description,
                    tba_address,
                    full_account_name
                FROM members.${tableName}
                WHERE token_id = $1 
                LIMIT 1`,
                [tokenId]
            );

            if (!syncedAccount) {
                return {
                    error: 'Failed to sync token data',
                    status: 500
                };
            }

            // Get base image URL with fallbacks
            const baseUrl = process.env.NEXT_PUBLIC_BLOB_URL;
            const tokenImageUrl = `${baseUrl}/${sanitizedGroup}/${tokenId}.png`;
            const defaultImageUrl = `${baseUrl}/${sanitizedGroup}/0.png`;
            const fallbackImageUrl = `${baseUrl}/default.png`;

            // Check images in order: token specific -> group default -> global default
            let baseImageUrl = tokenImageUrl;
            if (!(await checkImageExists(tokenImageUrl))) {
                console.log('Token-specific image not found, checking group default');
                if (await checkImageExists(defaultImageUrl)) {
                    baseImageUrl = defaultImageUrl;
                } else {
                    console.log('Group default image not found, using global fallback');
                    baseImageUrl = fallbackImageUrl;
                }
            }

            // Generate metadata image with text overlay
            const imageUrl = await ImageGenerator.generate({
                baseImageUrl,
                fullAccountName: syncedAccount.full_account_name,
                groupName: sanitizedGroup,
                tokenId,
                contract
            });

            return {
                name: `${syncedAccount.account_name}${group.group_name}`,
                description: syncedAccount.description || '',
                animation_url: `https://iframe-tokenbound.vercel.app/${contract}/${tokenId}/8453`,
                image: imageUrl,
                group_name: sanitizedGroup,
                tba_address: syncedAccount.tba_address,
                full_account_name: syncedAccount.full_account_name
            };

        } catch (error) {
            console.error('Error in getMetadata:', error);
            return {
                error: error instanceof Error ? error.message : 'Unknown error',
                status: 500
            };
        }
    }
};
````

## File: src/lib/database/pools.ts
````typescript
import { sql } from '@vercel/postgres';

interface Pool {
  contract_address: string;
  name: string;
  pool_type: 'balancer' | 'uniswap' | 'ensure';
  tokens?: string[];
  pair_token?: string;
  dex_type?: 'uniswap_v3' | 'uniswap_v4' | 'aerodrome';
}

export const pools = {
  /**
   * Get pool info by certificate contract address
   */
  async getByContract(contractAddress: string): Promise<Pool | null> {
    // Try balancer first
    const { rows: [balancerPool] } = await sql`
      SELECT 
        contract_address,
        name,
        'balancer' as pool_type,
        tokens
      FROM pools.balancer
      WHERE contract_address = ${contractAddress}
      LIMIT 1
    `;
    
    if (balancerPool) {
      return balancerPool as Pool;
    }

    // Try ensure pools
    const { rows: [ensurePool] } = await sql`
      SELECT 
        contract_address,
        name,
        'ensure' as pool_type,
        pair_token,
        dex_type
      FROM pools.ensure
      WHERE contract_address = ${contractAddress}
      LIMIT 1
    `;

    if (ensurePool) {
      return ensurePool as Pool;
    }

    // Try uniswap
    const { rows: [uniswapPool] } = await sql`
      SELECT 
        pool_address as contract_address,
        name,
        'uniswap' as pool_type
      FROM certificates.general
      WHERE pool_address = ${contractAddress}
      LIMIT 1
    `;

    return uniswapPool as Pool || null;
  },

  /**
   * Get all pools with optional filters
   */
  async getAll(options?: {
    poolType?: 'uniswap' | 'balancer' | 'ensure';
    limit?: number;
    offset?: number;
  }): Promise<Pool[]> {
    // Get balancer pools
    const { rows: balancerPools } = await sql`
      SELECT 
        contract_address,
        name,
        'balancer' as pool_type,
        tokens
      FROM pools.balancer
      ORDER BY name ASC
    `;

    // Get ensure pools
    const { rows: ensurePools } = await sql`
      SELECT 
        contract_address,
        name,
        'ensure' as pool_type,
        pair_token,
        dex_type
      FROM pools.ensure
      ORDER BY name ASC
    `;

    // Get uniswap pools
    const { rows: uniswapPools } = await sql`
      SELECT 
        pool_address as contract_address,
        name || '/ETH' as name,
        'uniswap' as pool_type
      FROM certificates.general
      WHERE pool_address IS NOT NULL
      ORDER BY name ASC
    `;
    
    // Combine and filter based on pool type
    let allPools = [...balancerPools, ...ensurePools, ...uniswapPools] as Pool[];
    
    if (options?.poolType) {
      allPools = allPools.filter(pool => pool.pool_type === options.poolType);
    }

    return allPools;
  },

  /**
   * Update pool metrics
   */
  async updateMetrics(poolAddress: string, data: {
    total_value_locked?: string;
    volume_24h?: string;
    fees_24h?: string;
  }): Promise<void> {
    // We'll implement this later when we add these columns
    return;
  }
};
````

## File: src/lib/database/proceeds.ts
````typescript
import { sql } from '@vercel/postgres';

export interface ProceedsAddress {
  address: string;
  name: string | null;
  type: 'split' | 'stream' | 'swapper' | 'team' | 'source';
  description: string | null;
  specific_asset_id?: number;
}

export const proceeds = {
  /**
   * Get all named addresses from proceeds tables
   */
  async getNames() {
    try {
      console.log('Executing database query...');
      const result = await sql`
        WITH all_addresses AS (
          SELECT LOWER(contract_address) as address, name, description, 'split' as type 
          FROM proceeds.splits 
          WHERE chain = 'base' AND name IS NOT NULL
          UNION ALL
          SELECT LOWER(contract_address) as address, name, description, 'stream' as type 
          FROM proceeds.streams 
          WHERE chain = 'base' AND name IS NOT NULL
          UNION ALL
          SELECT LOWER(contract_address) as address, name, description, 'swapper' as type 
          FROM proceeds.swappers 
          WHERE chain = 'base' AND name IS NOT NULL
          UNION ALL
          SELECT LOWER(contract_address) as address, name, description, 'team' as type 
          FROM proceeds.teams 
          WHERE chain = 'base' AND name IS NOT NULL
        ),
        sources AS (
          SELECT 
            'source_' || id::text as address,
            name,
            description,
            'source' as type
          FROM proceeds.sources
          WHERE name IS NOT NULL
        )
        SELECT DISTINCT address, name, description, type
        FROM (
          SELECT * FROM all_addresses
          UNION ALL
          SELECT * FROM sources
        ) combined
        ORDER BY type, name;
      `;
      console.log('Query executed, result:', result);
      return result.rows as ProceedsAddress[];
    } catch (error) {
      console.error('Database error in getNames:', error);
      throw error;
    }
  },

  /**
   * Get all proceeds data for an address
   */
  async getByAddress(address: string) {
    // Normalize address to lowercase
    const normalizedAddress = address.toLowerCase();

    // Check if this is a source address
    if (normalizedAddress.startsWith('source_')) {
      const sourceId = normalizedAddress.replace('source_', '');
      const sourceResult = await sql`
        SELECT * FROM proceeds.sources
        WHERE id = ${sourceId}
      `;
      return {
        source: sourceResult.rows[0] || null
      };
    }

    // Get split data
    const splitResult = await sql`
      SELECT * FROM proceeds.splits 
      WHERE LOWER(contract_address) = ${normalizedAddress}
      AND chain = 'base'
    `;

    // Get stream data
    const streamResult = await sql`
      SELECT * FROM proceeds.streams
      WHERE LOWER(contract_address) = ${normalizedAddress}
      AND chain = 'base'
    `;

    // Get swapper data
    const swapperResult = await sql`
      SELECT * FROM proceeds.swappers
      WHERE LOWER(contract_address) = ${normalizedAddress}
      AND chain = 'base'
    `;

    // Get team data
    const teamResult = await sql`
      SELECT * FROM proceeds.teams
      WHERE LOWER(contract_address) = ${normalizedAddress}
      AND chain = 'base'
    `;

    return {
      split: splitResult.rows[0] || null,
      stream: streamResult.rows[0] || null,
      swapper: swapperResult.rows[0] || null,
      team: teamResult.rows[0] || null
    };
  }
};
````

## File: src/lib/tokens/constants.ts
````typescript
import { type Address } from 'viem'
import { type TokenType, type TokenCategory } from './types'

// NOTE: This module is not fully implemented yet - work in progress

// Native ETH is special case - always available
export const NATIVE_ETH_ADDRESS = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE' as Address

// Default decimals by token type
export const TOKEN_DECIMALS: Partial<Record<TokenType, number>> = {
  native: 18,
  erc20: 18,
  erc721: 0,
  erc1155: 0
}

export const USDC_ADDRESS = '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913' as Address

export const KNOWN_TOKENS: Record<string, { 
  type: TokenType;
  symbol: string;
  categories: TokenCategory[];
  decimals: number;
}> = {
  [NATIVE_ETH_ADDRESS.toLowerCase()]: { 
    type: 'native', 
    symbol: 'ETH',
    categories: ['currency'],
    decimals: 18
  },
  [USDC_ADDRESS.toLowerCase()]: { 
    type: 'erc20', 
    symbol: 'USDC',
    categories: ['currency'],
    decimals: 6
  }
}

// Format configurations for different number ranges
export const FORMAT_CONFIG = {
  smallNumber: {
    minDecimals: 0,
    maxDecimals: 6,
    threshold: 0.000001
  },
  mediumNumber: {
    minDecimals: 0,
    maxDecimals: 4,
    threshold: 0.01
  },
  largeNumber: {
    minDecimals: 0,
    maxDecimals: 2,
    threshold: 1000
  }
}
````

## File: src/lib/tokens/formatting.ts
````typescript
import { parseEther, formatEther, type Address } from 'viem'
import { NATIVE_ETH_ADDRESS, TOKEN_DECIMALS, FORMAT_CONFIG } from './constants'
import { currencies } from '@/lib/database/config/currencies'
import type { Token, TokenType } from './types'

// NOTE: This module is not fully implemented yet - work in progress

/**
 * Gets token info from address, returns null if not found
 */
export async function getTokenInfo(tokenAddress: Address): Promise<Token | null> {
  // Handle native ETH specially
  if (tokenAddress.toLowerCase() === NATIVE_ETH_ADDRESS.toLowerCase()) {
    return {
      address: NATIVE_ETH_ADDRESS,
      chain: 'base',
      type: 'native',
      symbol: 'ETH',
      name: 'Ether',
      decimals: 18,
      categories: ['currency'],
      isApproved: false
    }
  }

  // Get from database
  const dbToken = await currencies.getByAddress(tokenAddress)
  if (!dbToken) return null

  return {
    address: tokenAddress,
    chain: dbToken.chain,
    type: 'erc20',
    symbol: dbToken.symbol,
    name: dbToken.name,
    decimals: dbToken.decimals,
    categories: ['currency'],
    isApproved: false
  }
}

/**
 * Gets the number of decimals for a token
 */
export async function getTokenDecimals(tokenAddress: Address): Promise<number> {
  // Handle native ETH specially
  if (tokenAddress.toLowerCase() === NATIVE_ETH_ADDRESS.toLowerCase()) {
    return 18
  }

  // Get from database
  const dbToken = await currencies.getByAddress(tokenAddress)
  if (dbToken?.decimals != null) return dbToken.decimals
  
  // Default to 18 for unknown tokens
  return 18
}

/**
 * Formats a number based on its size
 */
function formatBasedOnSize(num: number): string {
  if (num === 0) return '0'
  
  const { smallNumber, mediumNumber, largeNumber } = FORMAT_CONFIG
  
  if (num < smallNumber.threshold) return `< ${smallNumber.threshold}`
  if (num < mediumNumber.threshold) {
    return num.toLocaleString('en-US', {
      minimumFractionDigits: smallNumber.minDecimals,
      maximumFractionDigits: smallNumber.maxDecimals
    })
  }
  if (num < largeNumber.threshold) {
    return num.toLocaleString('en-US', {
      minimumFractionDigits: mediumNumber.minDecimals,
      maximumFractionDigits: mediumNumber.maxDecimals
    })
  }
  
  return num.toLocaleString('en-US', {
    minimumFractionDigits: largeNumber.minDecimals,
    maximumFractionDigits: largeNumber.maxDecimals
  })
}

interface FormatTokenAmountParams {
  amount: string | number | bigint
  tokenAddress: Address
  displayDecimals?: number
}

/**
 * Formats a token amount for display
 */
export async function formatTokenAmount({ 
  amount, 
  tokenAddress,
  displayDecimals 
}: FormatTokenAmountParams): Promise<string> {
  if (!amount) return '0'

  const decimals = await getTokenDecimals(tokenAddress)
  const tokenInfo = await getTokenInfo(tokenAddress)
  
  let numericAmount: number
  
  // Convert from BigInt/string if needed
  if (typeof amount === 'bigint') {
    numericAmount = Number(amount) / Math.pow(10, decimals)
  } else if (typeof amount === 'string') {
    numericAmount = Number(amount)
  } else {
    numericAmount = amount
  }

  // If specific display decimals are requested
  if (displayDecimals !== undefined) {
    return numericAmount.toLocaleString('en-US', {
      minimumFractionDigits: 0,
      maximumFractionDigits: displayDecimals
    })
  }

  // Special handling for USDC
  if (tokenInfo?.symbol === 'USDC') {
    return numericAmount.toLocaleString('en-US', {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    })
  }

  return formatBasedOnSize(numericAmount)
}

interface ConvertTokenAmountParams {
  amount: string | number
  tokenAddress: Address
  toWei?: boolean
}

/**
 * Converts a token amount to or from wei
 */
export async function convertTokenAmount({ 
  amount, 
  tokenAddress, 
  toWei = true 
}: ConvertTokenAmountParams): Promise<string> {
  const decimals = await getTokenDecimals(tokenAddress)
  
  if (toWei) {
    if (decimals === 18) {
      return parseEther(amount.toString()).toString()
    }
    // For non-18 decimal tokens (like USDC)
    const value = Number(amount) * Math.pow(10, decimals)
    return BigInt(Math.floor(value)).toString()
  } else {
    if (decimals === 18) {
      return formatEther(BigInt(amount))
    }
    // For non-18 decimal tokens
    return (Number(amount) / Math.pow(10, decimals)).toString()
  }
}

/**
 * Formats a token balance for display
 */
export async function formatTokenBalance(balance: bigint, tokenAddress: Address): Promise<string> {
  return formatTokenAmount({
    amount: balance,
    tokenAddress
  })
}

/**
 * Validates and formats an input amount
 */
export function formatInputAmount(value: string): string {
  // Remove existing commas
  const withoutCommas = value.replace(/,/g, '')
  
  // Only allow numbers and one decimal point
  const cleanValue = withoutCommas.replace(/[^\d.]/g, '')
  
  // Prevent multiple decimal points
  const parts = cleanValue.split('.')
  if (parts.length > 2) return parts[0] + '.' + parts[1]
  
  // Format with commas
  if (cleanValue) {
    const parts = cleanValue.split('.')
    const integerPart = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ',')
    return parts.length > 1 ? `${integerPart}.${parts[1]}` : integerPart
  }
  
  return cleanValue
}
````

## File: src/lib/tokens/index.ts
````typescript
// NOTE: This module is not fully implemented yet - work in progress

// Export types
export * from './types'

// Export constants
export {
  NATIVE_ETH_ADDRESS,
  USDC_ADDRESS,
  TOKEN_DECIMALS,
  KNOWN_TOKENS,
  FORMAT_CONFIG
} from './constants'

// Export formatting utilities
export {
  getTokenInfo,
  getTokenDecimals,
  formatTokenAmount,
  convertTokenAmount,
  formatTokenBalance,
  formatInputAmount
} from './formatting'
````

## File: src/lib/tokens/types.ts
````typescript
import { Address } from 'viem'

// NOTE: This module is not fully implemented yet - work in progress

export type TokenType = 'native' | 'erc20' | 'erc721' | 'erc1155'
export type TokenCategory = 'currency' | 'certificate' | 'general' | 'specific'

export interface Token {
  address: Address
  chain: string
  type: TokenType
  symbol: string
  name: string
  decimals?: number
  isApproved: boolean
  categories: TokenCategory[]
  priceFeedAddress?: Address
  metadata?: Record<string, any>
}

export interface SpamContract {
  address: Address
  chain: string
  reason?: string
  addedAt: Date
}

export interface TokenBalance {
  token: Token
  balance: bigint
  valueUsd?: number
  priceUsd?: number
  priceSource?: string
}

export interface TokenMetadata {
  description?: string
  image?: string
  externalUrl?: string
  attributes?: Array<{
    trait_type: string
    value: string | number
  }>
  [key: string]: any
}
````

## File: src/lib/alchemy.ts
````typescript
import { Network, Alchemy } from 'alchemy-sdk';

const settings = {
  apiKey: process.env.NEXT_PUBLIC_ALCHEMY_API_KEY,
  network: Network.BASE_MAINNET,
};

export const alchemy = new Alchemy(settings);
````

## File: src/lib/docs-search.ts
````typescript
import { readdirSync, readFileSync } from 'fs'
import { join } from 'path'

interface DocSearchResult {
  name: string
  path: string
  type: 'doc'
  doc_section: string
  subsection?: string
}

const docsDirectory = join(process.cwd(), 'src/app/docs')

// Helper function to extract headers and their content from MDX
function extractHeaders(content: string) {
  const lines = content.split('\n')
  const headers: { title: string; anchor: string; content: string[] }[] = []
  let currentHeader: { title: string; anchor: string; content: string[] } | null = null

  lines.forEach((line) => {
    // Match headers (# Header, ## Header, ### Header)
    const headerMatch = line.match(/^(#{1,3})\s+(.+)$/)
    if (headerMatch) {
      if (currentHeader) {
        headers.push(currentHeader)
      }
      const title = headerMatch[2]
      // Create URL-friendly anchor
      const anchor = title.toLowerCase()
        .replace(/[^a-z0-9\s-]/g, '')
        .replace(/\s+/g, '-')
      currentHeader = { title, anchor, content: [] }
    } else if (currentHeader) {
      currentHeader.content.push(line)
    }
  })

  if (currentHeader) {
    headers.push(currentHeader)
  }

  return headers
}

export function searchDocs(query: string): DocSearchResult[] {
  const results: DocSearchResult[] = []
  const sections = ['tldr', 'fundamentals', 'natural-capital', 'ensurance', 'protocol', 'technical', 'faq']
  
  const searchQuery = query.toLowerCase()

  sections.forEach(section => {
    try {
      const filePath = join(docsDirectory, section, 'page.mdx')
      const content = readFileSync(filePath, 'utf8')
      const headers = extractHeaders(content)
      
      // Get page title (first h1)
      const pageTitle = headers.find(h => h.title)?.title || section

      // Search in each section first
      const sectionMatches: DocSearchResult[] = []
      headers.forEach(header => {
        const sectionContent = [header.title, ...header.content].join(' ')
        if (sectionContent.toLowerCase().includes(searchQuery)) {
          sectionMatches.push({
            name: header.title,
            path: `/docs/${section}#${header.anchor}`,
            type: 'doc',
            doc_section: section.toUpperCase().replace('-', ' '),
            subsection: pageTitle
          })
        }
      })

      // If we found section matches, add them
      if (sectionMatches.length > 0) {
        results.push(...sectionMatches)
      } 
      // If no section matches but content includes query, add the page result
      else if (content.toLowerCase().includes(searchQuery)) {
        results.push({
          name: pageTitle,
          path: `/docs/${section}`,
          type: 'doc',
          doc_section: section.toUpperCase().replace('-', ' ')
        })
      }
    } catch (error) {
      console.warn(`Error reading doc section ${section}:`, error)
    }
  })

  return results
}
````

## File: src/lib/ensurance.ts
````typescript
import { Asset, EnsuranceFlags } from '@/types';
import { PortfolioToken, ERC20Token, NFTToken } from '@/modules/account-modules/portfolio/types';
import { CONTRACTS } from '@/modules/specific/config';

interface GeneralCertificate {
  contract_address: string;
  // Add other fields as needed
}

interface Group {
  contract_address: string;
  // Add other fields as needed
}

/**
 * Converts a PortfolioToken to an Asset for ensurance checking
 */
function portfolioTokenToAsset(token: PortfolioToken): Asset {
  // Handle each token type appropriately
  if (token.type === 'native') {
    return {
      chain: 'base',
      contract_address: token.address,
      token_id: '0',
      contract: {
        type: undefined
      },
      name: token.name,
      symbol: token.symbol,
      ensurance: undefined
    };
  }

  if (token.type === 'erc20') {
    const erc20Token = token as ERC20Token;
    return {
      chain: 'base',
      contract_address: erc20Token.contractAddress,
      token_id: '0',
      contract: {
        type: 'erc20'
      },
      name: token.name,
      symbol: token.symbol,
      ensurance: undefined
    };
  }

  // For ERC721 and ERC1155
  const nftToken = token as NFTToken;
  return {
    chain: 'base',
    contract_address: nftToken.contractAddress,
    token_id: nftToken.tokenId,
    contract: {
      type: nftToken.type
    },
    name: token.name,
    symbol: token.symbol,
    ensurance: undefined
  };
}

/**
 * Identifies if assets are Ensurance assets by checking their contracts against known Ensurance contracts.
 * 
 * Note: This is different from the database-level isEnsurance check (in accounts.ts) which
 * is used to identify if a group is the ensurance group and include additional fields
 * like stock_or_flow and display_name in database queries.
 * 
 * This function is specifically for identifying Ensurance assets in the UI/portfolio context.
 */
export async function identifyEnsuranceAssets(assets: Asset[]): Promise<Asset[]> {
  try {
    console.log('Starting ensurance check for assets:', assets.map(a => ({
      name: a.name,
      contract_address: a.contract_address,
      type: a.contract?.type
    })));

    // Fetch known contracts in parallel
    const [generalResponse, groupsResponse] = await Promise.all([
      fetch('/api/general'),
      fetch('/api/groups')
    ]);

    if (!generalResponse.ok || !groupsResponse.ok) {
      console.error('Failed to fetch contract data:', {
        general: generalResponse.status,
        groups: groupsResponse.status
      });
      return assets;
    }

    const generalCertificates = await generalResponse.json();
    const groups = await groupsResponse.json();

    console.log('Fetched contracts:', {
      generalCertificates: generalCertificates.map((c: any) => c.contract_address),
      groups: groups.map((g: any) => g.contract_address),
      specific: CONTRACTS.specific
    });

    // Create lookup sets for faster checking
    const generalContracts = new Set(generalCertificates.map((c: any) => c.contract_address?.toLowerCase()));
    const groupContracts = new Set(groups.map((g: any) => g.contract_address?.toLowerCase()));
    const specificContract = CONTRACTS.specific.toLowerCase();

    // Process each asset
    const assetsWithEnsurance = assets.map(asset => {
      if (!asset.contract_address) {
        console.log('Asset has no contract address:', asset);
        return asset;
      }

      const contractAddress = asset.contract_address.toLowerCase();
      const ensurance: EnsuranceFlags = {
        isEnsuranceGeneral: asset.contract?.type === 'erc20' && generalContracts.has(contractAddress),
        isEnsuranceSpecific: contractAddress === specificContract, // Just check the contract address
        isEnsuranceGroup: asset.contract?.type === 'erc721' && groupContracts.has(contractAddress)
      };

      console.log('Processing asset:', {
        contractAddress,
        type: asset.contract?.type,
        ensurance
      });

      return {
        ...asset,
        ensurance
      };
    });

    console.log('Assets with ensurance flags:', assetsWithEnsurance.map(a => ({
      name: a.name,
      ensurance: a.ensurance
    })));

    return assetsWithEnsurance;
  } catch (error) {
    console.error('Error identifying Ensurance assets:', error);
    return assets;
  }
}

/**
 * Identifies if portfolio tokens are Ensurance assets by checking their contracts against known Ensurance contracts.
 */
export async function identifyEnsurancePortfolioTokens(tokens: PortfolioToken[]): Promise<PortfolioToken[]> {
  try {
    // Debug log the incoming tokens
    console.log('Raw tokens from wallet:', JSON.stringify(tokens, null, 2));

    // Fetch known contracts in parallel
    const [generalResponse, groupsResponse] = await Promise.all([
      fetch('/api/general'),
      fetch('/api/groups')
    ]);

    if (!generalResponse.ok || !groupsResponse.ok) {
      console.error('Failed to fetch contract data:', {
        general: generalResponse.status,
        groups: groupsResponse.status
      });
      return tokens;
    }

    const generalCertificates = await generalResponse.json();
    const groups = await groupsResponse.json();

    // Debug log the contract lists
    console.log('Ensurance contracts:', {
      general: generalCertificates.map((c: any) => c.contract_address),
      groups: groups.map((g: any) => g.contract_address),
      specific: CONTRACTS.specific
    });

    // Simple array of contract addresses to check against
    const ensuranceContracts = [
      ...generalCertificates.map((c: any) => c.contract_address?.toLowerCase()),
      ...groups.map((g: any) => g.contract_address?.toLowerCase()),
      CONTRACTS.specific?.toLowerCase()
    ].filter(Boolean);

    // Process each token
    const tokensWithEnsurance = tokens.map(token => {
      // For ERC20 tokens, use the address property
      const addressToCheck = token.address;

      // Debug log each token check
      console.log('Checking token:', {
        name: token.name,
        type: token.type,
        address: addressToCheck,
        ensuranceContracts
      });

      if (!addressToCheck) {
        console.warn('No address found for token:', token);
        return token;
      }

      const ensurance: EnsuranceFlags = {
        isEnsuranceGeneral: token.type === 'erc20' && ensuranceContracts.includes(addressToCheck.toLowerCase()),
        isEnsuranceSpecific: addressToCheck.toLowerCase() === CONTRACTS.specific?.toLowerCase(),
        isEnsuranceGroup: (token.type === 'erc721' || token.type === 'erc1155') && ensuranceContracts.includes(addressToCheck.toLowerCase())
      };

      return {
        ...token,
        ensurance
      };
    });

    return tokensWithEnsurance;
  } catch (error) {
    console.error('Error identifying Ensurance tokens:', error);
    return tokens;
  }
}
````

## File: src/lib/share.ts
````typescript
import { Metadata, Viewport } from 'next'
import { headers } from 'next/headers'

export const viewport: Viewport = {
  width: 'device-width',
  initialScale: 1,
  themeColor: '#000000'
}

export async function generateShare(pathname: string = '/', params: any = {}): Promise<Metadata> {
  const baseMetadata = {
    metadataBase: new URL('https://ensurance.app'),
    title: 'ensurance: markets for what matters - ensuring the stocks & flows of natural capital',
    description: 'reducing risk, increasing resilience',
    applicationName: 'ensurance agents',
    authors: [{ name: 'BASIN Natural Capital' }],
    openGraph: {
      type: 'website',
      title: 'ensurance: markets for what matters - ensuring the stocks & flows of natural capital',
      description: 'reducing risk, increasing resilience',
      images: [{
        url: 'https://ensurance.app/assets/share-default.png',
        width: 1200,
        height: 630,
        alt: 'ensurance agents'
      }],
      siteName: 'ensurance agents'
    },
    twitter: {
      card: 'summary_large_image',
      title: 'ensurance: markets for what matters - ensuring the stocks & flows of natural capital',
      description: 'reducing risk, increasing resilience',
      images: ['https://ensurance.app/assets/share-default.png'],
      creator: '@ensurance_app',
      site: '@ensurance_app'
    }
  }

  // Just return the base metadata - no API calls or complex logic
  return baseMetadata
}
````

## File: src/lib/tokenbound.ts
````typescript
// @keep Core TokenBound functionality and types
import { TokenboundClient } from "@tokenbound/sdk";
import { createTokenboundClient } from '@/config/tokenbound';
import { getChainByName } from '@/config/chains';
import type { Asset } from '@/types/index';
import { type WalletClient } from 'viem';

export interface TokenboundActions {
  // 6-17-25 note: buttons, aave, portfolio etc. all use this file (or extension of it) as the https://docs.tokenbound.org/sdk/methods#tokenboundclient-sdk-methods are basically shared
  // TODO: Consider ERC721 transfer safety:
  // 1. Add token ID validation to prevent self-transfers
  // 2. Consider disabling ERC721 transfers in favor of external tools
  // 3. If keeping ERC721 transfers, implement user confirmation flow with risk warning
  transferNFT: (asset: Asset, toAddress: `0x${string}`, amount?: number) => Promise<{ hash: string; isCrossChain?: boolean }>;
  isAccountDeployed: (asset: Asset) => Promise<boolean>;
  transferETH: (params: {
    amount: number;
    recipientAddress: `0x${string}`;
    chainId: number;
  }) => Promise<void>;
  transferERC20: (params: {
    amount: number;
    recipientAddress: `0x${string}`;
    erc20tokenAddress: `0x${string}`;
    erc20tokenDecimals: number;
    chainId: number;
  }) => Promise<void>;
}

// @keep Create TokenBound actions with wallet and TBA address
export const createTokenboundActions = (walletClient: WalletClient, tbaAddress: string): TokenboundActions => {
  const client = createTokenboundClient(walletClient);

  return {
    transferNFT: async (asset: Asset, toAddress: `0x${string}`, amount?: number) => {
      if (!walletClient) {
        throw new Error("Please connect your wallet first");
      }

      const chainConfig = getChainByName(asset.chain);
      if (!chainConfig) {
        throw new Error(`Unsupported chain: ${asset.chain}`);
      }

      const tx = await client.transferNFT({
        account: tbaAddress as `0x${string}`,
        tokenType: asset.contract?.type === 'ERC1155' ? 'ERC1155' : 'ERC721',
        tokenContract: asset.contract_address as `0x${string}`,
        tokenId: asset.token_id,
        recipientAddress: toAddress,
        amount: asset.contract?.type === 'ERC1155' ? amount : undefined
      });

      return {
        hash: tx,
        isCrossChain: false
      };
    },
    
    isAccountDeployed: async (asset: Asset): Promise<boolean> => {
      try {
        const chainConfig = getChainByName(asset.chain);
        if (!chainConfig) {
          console.warn(`Chain ${asset.chain} not supported for tokenbound operations`);
          return false;
        }

        if (!walletClient) {
          console.warn('No wallet available for tokenbound operations');
          return false;
        }

        return client.checkAccountDeployment({
          accountAddress: tbaAddress as `0x${string}`,
        });
      } catch (error) {
        console.error('Error checking account deployment:', error);
        return false;
      }
    },

    transferETH: async ({ amount, recipientAddress, chainId }) => {
      if (!walletClient) {
        throw new Error("Please connect your wallet first");
      }

      await client.transferETH({
        account: tbaAddress as `0x${string}`,
        amount,
        recipientAddress,
        chainId: chainId
      });
    },

    transferERC20: async ({ amount, recipientAddress, erc20tokenAddress, erc20tokenDecimals, chainId }) => {
      if (!walletClient) {
        throw new Error("Please connect your wallet first");
      }

      await client.transferERC20({
        account: tbaAddress as `0x${string}`,
        amount,
        recipientAddress,
        erc20tokenAddress,
        erc20tokenDecimals,
        chainId: chainId
      });
    },
  };
};
````

## File: src/lib/types.ts
````typescript
export interface SearchResult {
  name: string
  path: string
  type: string
  chain?: string
  is_agent?: boolean
  is_pool?: boolean
}
````

## File: src/lib/utils.ts
````typescript
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"
 
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
````

## File: src/modules/0x/executeSwap.ts
````typescript
import { 
  type Address,
  createWalletClient,
  custom,
  http,
  createPublicClient,
  parseEther,
  maxUint256,
  concat,
  numberToHex
} from 'viem'
import { base } from 'viem/chains'
import type { RouterV2 } from '@0x/swap-ts-sdk'

// Standard ERC20 ABI for approve and allowance
const ERC20_ABI = [{
  constant: false,
  inputs: [
    { name: '_spender', type: 'address' },
    { name: '_value', type: 'uint256' }
  ],
  name: 'approve',
  outputs: [{ name: '', type: 'bool' }],
  payable: false,
  stateMutability: 'nonpayable',
  type: 'function'
}, {
  constant: true,
  inputs: [
    { name: '_owner', type: 'address' },
    { name: '_spender', type: 'address' }
  ],
  name: 'allowance',
  outputs: [{ name: '', type: 'uint256' }],
  payable: false,
  stateMutability: 'view',
  type: 'function'
}] as const

// Define constants for 0x contract addresses
const PERMIT2_ADDRESS = '0x000000000022D473030F116dDEE9F6B43aC78BA3';
// Add AllowanceHolder for Base chain if you need it
// const ALLOWANCE_HOLDER_BASE = '0x0000000000001ff3684f28c67538d4d072c22734';

// Define types for the quote response
type Quote = {
  buyTokenAddress?: string;
  sellTokenAddress?: string;
  buyAmount?: string;
  sellAmount?: string;
  to?: string;
  data?: string;
  value?: string;
  gas?: string;
  estimatedGas?: string;
  gasPrice?: string;
  protocolFee?: string;
  minimumProtocolFee?: string;
  buyTokenPercentageFee?: string;
  price?: string;
  guaranteedPrice?: string;
  sources?: Array<{ name: string; proportion: string }>;
  allowanceTarget?: string;
  sellTokenToEthRate?: string;
  buyTokenToEthRate?: string;
  fees?: {
    integratorFee?: {
      amount: string;
    };
  };
  // Updated Permit2 specific fields to match 0x v2 API
  permit2?: {
    type?: string;
    hash?: string;
    eip712?: {
      types: Record<string, Array<{ name: string; type: string }>>;
      domain: Record<string, any>;
      primaryType: string;
      message: Record<string, any>;
    }
  };
  // Transaction object per v2 API
  transaction?: {
    to?: string;
    data?: string;
    value?: string;
    gas?: string;
    gasPrice?: string;
    maxFeePerGas?: string;
    maxPriorityFeePerGas?: string;
  }
};

// Define types for the transaction parameters
type TransactionParams = {
  to: string;
  data: string;
  value: string;
  gas: string;
  gasPrice?: string;
}

interface ExecuteSwapParams {
  sellToken: Address
  buyToken: Address
  amount: string
  userAddress: Address
  provider: any
  onStatus: (message: string, type?: 'info' | 'success' | 'error') => void
  apiKey?: string // Optional now since we're using our backend
}

interface CheckAllowanceParams {
  sellToken: Address;
  sellAmount: bigint;
  allowanceTarget: Address;
  userAddress: Address;
  walletClient: any;
  publicClient: any;
  onStatus: (message: string, type?: 'info' | 'success' | 'error') => void;
}

interface ExecuteEthSwapParams {
  quoteResponse: Quote;
  userAddress: Address;
  provider: any;
  publicClient: any;
}

interface ExecuteTokenSwapParams {
  swapParams: TransactionParams;
  userAddress: Address;
  provider: any;
  publicClient: any;
}

export async function executeSwap({
  sellToken,
  buyToken,
  amount,
  userAddress,
  provider,
  onStatus
}: ExecuteSwapParams) {
  // Create clients
  const publicClient = createPublicClient({
    chain: base,
    transport: http()
  })

  const walletClient = createWalletClient({
    chain: base,
    transport: custom(provider)
  })

  // Amount is already in correct decimals from the component
  const sellAmountWei = amount

  // Log initial parameters
  console.log('Swap parameters:', {
    sellToken,
    buyToken,
    amount,
    sellAmountWei,
    userAddress,
    chainId: base.id
  })

  try {
    onStatus('Getting quote...', 'info')

    // Use our backend proxy to get a quote
    const params = new URLSearchParams({
      action: 'quote',
      sellToken,
      buyToken,
      sellAmount: sellAmountWei,
      taker: userAddress,
      swapFeeToken: buyToken,
      slippageBps: '200', // 2% slippage
      swapFeeBps: '100'   // 1% fee
    })

    const quoteResponse = await fetch(`/api/0x?${params}`)
    if (!quoteResponse.ok) {
      const errorData = await quoteResponse.json()
      console.error('Quote error details:', errorData)
      
      // Handle v2 API error structure
      const details = errorData.details || {}
      if (details.validationErrors?.length > 0) {
        throw new Error(`Invalid trade parameters: ${details.validationErrors[0]}`)
      } else if (details.code === 'INSUFFICIENT_LIQUIDITY') {
        throw new Error('Insufficient liquidity for this trade')
      } else if (details.code === 'INVALID_TOKEN') {
        throw new Error('One or more tokens are not supported')
      } else if (details.code === 'INSUFFICIENT_BALANCE') {
        throw new Error('Insufficient balance for this trade')
      } else {
        throw new Error(details.message || errorData.error || 'Failed to get quote')
      }
    }

    const quoteData = await quoteResponse.json() as Quote
    console.log('Quote received:', {
      buyAmount: quoteData.buyAmount,
      sellAmount: quoteData.sellAmount,
      estimatedGas: quoteData.estimatedGas || quoteData.gas || quoteData.transaction?.gas,
      price: quoteData.price,
      sources: quoteData.sources?.filter((s) => Number(s.proportion) > 0).map((s) => s.name) || [],
      allowanceTarget: quoteData.allowanceTarget,
      permitData: quoteData.permit2 ? 'Present' : 'Not present',
      transaction: quoteData.transaction ? 'Present' : 'Not present'
    })

    // Make sure we have transaction data in the expected format (v2 API)
    if (!quoteData.transaction) {
      console.error('Missing transaction object in quote response', quoteData);
      throw new Error('Invalid quote: missing transaction object');
    }

    // Handle native ETH case
    const isNativeETH = sellToken.toLowerCase() === '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee'.toLowerCase()
    
    if (isNativeETH) {
      onStatus('Executing ETH swap...', 'info')
      return await executeEthSwap({
        quoteResponse: quoteData,
        userAddress,
        provider,
        publicClient
      })
    } else {
      // For ERC20 tokens with Permit2

      // Check if quote includes Permit2 data (needed for token-to-token swaps)
      if (!quoteData.permit2?.eip712) {
        console.error('Missing Permit2 data in quote response');
        throw new Error('Invalid quote: missing Permit2 data');
      }

      // SECURITY CHECK: Ensure we have a valid allowanceTarget
      if (!quoteData.allowanceTarget) {
        console.warn('Missing allowanceTarget in quote response - using canonical Permit2 address');
        // If we're using Permit2 flow and allowanceTarget is missing, use the canonical Permit2 address
        if (quoteData.permit2?.type === 'Permit2') {
          quoteData.allowanceTarget = PERMIT2_ADDRESS;
          console.log('Using canonical Permit2 address as allowanceTarget');
        } else {
          console.error('Cannot safely determine allowance target - Permit2 type missing');
          throw new Error('Invalid quote: missing allowance target for token swap');
        }
      }

      // SECURITY CHECK: Never approve the Settler contract (transaction.to)
      if (quoteData.allowanceTarget.toLowerCase() === quoteData.transaction.to?.toLowerCase()) {
        console.error('SECURITY VIOLATION: API returned Settler contract as allowanceTarget', {
          allowanceTarget: quoteData.allowanceTarget,
          settlerContract: quoteData.transaction.to
        });
        throw new Error('Security violation: Cannot approve Settler contract');
      }

      // Log the allowance target for security verification
      console.log('Using allowance target:', {
        allowanceTarget: quoteData.allowanceTarget,
        isPermit2: quoteData.allowanceTarget.toLowerCase() === PERMIT2_ADDRESS.toLowerCase(),
        settler: quoteData.transaction.to
      });

      // Check and set allowance if needed
      await checkAndSetAllowance({
        sellToken,
        sellAmount: BigInt(quoteData.sellAmount || '0'),
        allowanceTarget: quoteData.allowanceTarget as Address,
        userAddress,
        walletClient,
        publicClient,
        onStatus
      });

      // Sign permit message
      onStatus('Signing permission...', 'info');
      
      const permitData = quoteData.permit2.eip712;
      
      // Ensure proper typing for EIP712 data
      const typedData = {
        types: permitData?.types || {},
        domain: permitData?.domain || {},
        primaryType: permitData?.primaryType || 'PermitTransferFrom',
        message: permitData?.message || {}
      };
      
      console.log('Signing permit with data:', {
        domain: typedData.domain,
        primaryType: typedData.primaryType,
        messageType: typedData.types[typedData.primaryType],
        message: typedData.message
      });

      try {
        // Get signature from wallet
        const signature = await provider.request({
          method: 'eth_signTypedData_v4',
          params: [
            userAddress,
            JSON.stringify(typedData)
          ]
        });

        console.log('Permit signature obtained:', signature.slice(0, 20) + '...');

        // Brief delay after permit signing to ensure signature is processed
        onStatus('Processing permit signature...', 'info');
        await new Promise(resolve => setTimeout(resolve, 1500)); // 1.5 second delay

        // Add ERC-4337 smart wallet detection helper
        const isERC4337Wallet = async (address: string, provider: any): Promise<boolean> => {
          try {
            // Check various provider properties that indicate a smart wallet
            const providerObj = provider?.provider || provider
            const isCoinbase = !!(
              providerObj?.isCoinbaseWallet || 
              providerObj?.provider?.isCoinbaseWallet ||
              providerObj?.isCoinbaseBrowser
            )
            const isAA = !!(
              providerObj?.isAccountAbstraction ||
              providerObj?.provider?.isAccountAbstraction ||
              providerObj?.isSmartContractWallet ||
              providerObj?.provider?.isSmartContractWallet
            )

            // Also check if the address is a contract as fallback
            const code = await publicClient.getBytecode({ address: address as `0x${string}` })
            const isContract = code !== undefined && code !== '0x'

            const result = isCoinbase || isAA || isContract
            console.log('Wallet detection:', {
              isCoinbase,
              isAA,
              isContract,
              provider: providerObj?.constructor?.name,
              result
            })
            
            return result
          } catch (error) {
            console.error('Error checking if wallet is ERC-4337:', error)
            // If we can't determine, assume it's a smart wallet to be safe
            return true
          }
        }

        // Add transaction simulation helper
        const simulateTransaction = async (tx: any, provider: any): Promise<boolean> => {
          try {
            const result = await provider.request({
              method: 'eth_call',
              params: [{
                from: tx.from,
                to: tx.to,
                data: tx.data,
                value: tx.value
              }, 'latest']
            })
            return true
          } catch (error) {
            console.error('Simulation failed:', error)
            return false
          }
        }

        // Modify the transaction preparation section
        try {
          // Check if the user is using an ERC-4337 wallet
          const isAA = await isERC4337Wallet(userAddress, provider)
          console.log('Wallet type:', isAA ? 'ERC-4337 Smart Wallet' : 'Regular Wallet')

          // Format signature following 0x v2 specs - EXACTLY as per documentation
          const signatureLengthHex = numberToHex(signature.length / 2 - 1, {
            size: 32,
            signed: false,
          })

          // For 0x v2 API: prepare the transaction from the transaction object
          const tx = {
            from: userAddress,
            to: quoteData.transaction.to,
            data: concat([quoteData.transaction.data, signatureLengthHex, signature]),
            value: quoteData.transaction.value || '0x0',
          }

          // Log transaction details for debugging
          console.log('Executing transaction:', {
            to: tx.to,
            dataLength: tx.data.length,
            value: tx.value,
            isAA
          })

          // Send transaction without any gas parameters for smart contract wallets
          const txHash = await provider.request({
            method: 'eth_sendTransaction',
            params: [tx]
          })

          console.log('Transaction sent with hash:', txHash)
          
          // Wait for receipt with longer timeout
          const receipt = await publicClient.waitForTransactionReceipt({ 
            hash: txHash,
            timeout: 180_000 // 3 minute timeout
          })
          
          console.log('Transaction receipt:', {
            status: receipt.status,
            blockNumber: receipt.blockNumber,
            gasUsed: receipt.gasUsed.toString(),
            logs: receipt.logs.length
          });
          
          if (!receipt.status) {
            throw new Error('Transaction failed on-chain');
          }
          
          return {
            success: true,
            txHash
          };
        } catch (error) {
          console.error('Signing or swap error:', error);
          throw error;
        }
      } catch (error: any) {
        console.error('Signing or swap error:', error);
        throw error;
      }
    }
  } catch (error: any) {
    console.error('Swap failed:', error)
    
    // Handle specific errors
    if (error.message?.includes('rejected') || error.code === 4001) {
      throw new Error('Transaction rejected by user')
    } else {
      throw new Error(error.message || 'Failed to fetch')
    }
  }
}

async function checkAndSetAllowance({
  sellToken,
  sellAmount,
  allowanceTarget,
  userAddress,
  walletClient,
  publicClient,
  onStatus
}: CheckAllowanceParams) {
  // Validate addresses
  if (!allowanceTarget || !sellToken) {
    console.error('Invalid address parameters:', { sellToken, allowanceTarget });
    throw new Error('Missing required address parameters for token approval');
  }

  // Ensure the allowanceTarget has the 0x prefix and is properly formatted
  const formattedAllowanceTarget = allowanceTarget.startsWith('0x') 
    ? allowanceTarget 
    : `0x${allowanceTarget}`;

  if (formattedAllowanceTarget.length !== 42) {
    console.error('Invalid allowance target format:', formattedAllowanceTarget);
    throw new Error('Invalid allowance target address format');
  }

  try {
    // Check current allowance
    const currentAllowance = await publicClient.readContract({
      address: sellToken as `0x${string}`,
      abi: ERC20_ABI,
      functionName: 'allowance',
      args: [userAddress as `0x${string}`, formattedAllowanceTarget as `0x${string}`]
    })

    console.log('Allowance check:', {
      token: sellToken,
      spender: formattedAllowanceTarget,
      currentAllowance: currentAllowance.toString(),
      requiredAmount: sellAmount.toString()
    })

    // If allowance is too low, request approval
    if (currentAllowance < sellAmount) {
      onStatus('Approving token spending...', 'info')

      try {
        // IMPORTANT: Use maxUint256 for unlimited approvals instead of exact amount
        // This follows best practices for DEX interactions
        const hash = await walletClient.writeContract({
          address: sellToken as `0x${string}`,
          abi: ERC20_ABI,
          functionName: 'approve',
          args: [formattedAllowanceTarget as `0x${string}`, maxUint256],
          account: userAddress as `0x${string}`
        })

        // Wait for approval transaction
        onStatus('Waiting for approval confirmation...', 'info')
        const receipt = await publicClient.waitForTransactionReceipt({ hash })

        if (!receipt.status) {
          throw new Error('Approval transaction failed')
        }

        onStatus('Approval confirmed', 'success')

        // Verify the allowance was set correctly after a short delay
        await new Promise(resolve => setTimeout(resolve, 2000))
        
        const newAllowance = await publicClient.readContract({
          address: sellToken as `0x${string}`,
          abi: ERC20_ABI,
          functionName: 'allowance',
          args: [userAddress as `0x${string}`, formattedAllowanceTarget as `0x${string}`]
        })

        console.log('New allowance:', newAllowance.toString())
        
        if (newAllowance < sellAmount) {
          throw new Error('Allowance not set correctly')
        }
      } catch (error) {
        console.error('Approval error:', error)
        throw error
      }
    } else {
      console.log('Sufficient allowance already exists')
    }
  } catch (error) {
    console.error('Error in allowance check/set:', error);
    throw error;
  }
}

// Improve the executeEthSwap function
async function executeEthSwap({
  quoteResponse,
  userAddress,
  provider,
  publicClient
}: ExecuteEthSwapParams) {
  try {
    // For 0x v2 API, we should use the transaction object
    if (!quoteResponse.transaction) {
      console.error('Missing transaction object in quote for ETH swap');
      throw new Error('Invalid quote: missing transaction object for ETH swap');
    }

    // Validate that we have a valid 'to' address
    if (!quoteResponse.transaction.to) {
      console.error('Missing destination address in transaction:', quoteResponse.transaction);
      throw new Error('Invalid quote: missing destination address');
    }

    // Ensure we have valid transaction data
    if (!quoteResponse.transaction.data) {
      console.error('Missing transaction data in transaction:', quoteResponse.transaction);
      throw new Error('Invalid quote: missing transaction data');
    }

    const tx = {
      from: userAddress,
      to: quoteResponse.transaction.to,
      data: quoteResponse.transaction.data,
      value: `0x${BigInt(quoteResponse.transaction.value || 0).toString(16)}`,
      // Remove explicit gas setting to let smart contract wallet handle it
      // gas: `0x${Math.floor(Number(quoteResponse.transaction.gas) * 1.2).toString(16)}`, // 20% buffer
    }

    console.log('ETH swap transaction:', {
      to: tx.to,
      value: tx.value,
      // Log original gas estimate for reference
      originalGasEstimate: quoteResponse.transaction.gas
    })

    // Send transaction
    const txHash = await provider.request({
      method: 'eth_sendTransaction',
      params: [tx]
    })

    console.log('Transaction sent with hash:', txHash);
    
    // Wait for receipt with longer timeout
    const receipt = await publicClient.waitForTransactionReceipt({ 
      hash: txHash,
      timeout: 120_000 // 2 minute timeout
    })
    
    console.log('Transaction receipt:', {
      status: receipt.status,
      blockNumber: receipt.blockNumber,
      gasUsed: receipt.gasUsed.toString(),
      logs: receipt.logs.length
    });
    
    if (!receipt.status) {
      throw new Error('Transaction failed on-chain');
    }
    
    // Additional verification: check for events/logs
    if (receipt.logs.length === 0) {
      // No events emitted, usually a sign of failure
      console.warn('Transaction succeeded but emitted no logs - possible silent failure');
    }
    
    return {
      success: true,
      txHash
    }
  } catch (error) {
    console.error('ETH swap error:', error)
    throw error
  }
}
````

## File: src/modules/account-modules/chat/index.tsx
````typescript
'use client'

import React from 'react'

interface ChatTabProps {
  address: string
  selectedChain?: string
  isOwner?: boolean
  isAgent?: boolean
}

export default function ChatTab({ address, isAgent = false }: ChatTabProps) {
  return (
    <div className="relative min-h-[300px]">
      <div className={`space-y-4 ${!isAgent ? 'blur-[2px]' : ''}`}>
        {/* Chat messages */}
        <div className="space-y-4">
          {/* Agent message */}
          <div className="flex justify-start">
            <div className="bg-gray-800 rounded-lg p-3 max-w-[80%] rounded-tl-none">
              <p className="text-gray-300">What do you want to ensure?</p>
            </div>
          </div>
          
          {/* User message */}
          <div className="flex justify-end">
            <div className="bg-blue-600 rounded-lg p-3 max-w-[80%] rounded-tr-none">
              <p className="text-white">I would like to ensure biodiversity and clean water for all.</p>
            </div>
          </div>
          
          {/* Agent message */}
          <div className="flex justify-start">
            <div className="bg-gray-800 rounded-lg p-3 max-w-[80%] rounded-tl-none">
              <p className="text-gray-300">Well we have several ways for you to do both!</p>
            </div>
          </div>
        </div>

        {/* Coming soon message */}
        <div className="text-center text-gray-400 text-sm mt-6">
          Full chat coming soon...
        </div>

        {/* Loading state */}
        <div className="flex items-center gap-1.5 mt-4">
          <div className="w-1.5 h-1.5 bg-gray-500 rounded-full animate-pulse"></div>
          <div className="w-1.5 h-1.5 bg-gray-500 rounded-full animate-pulse delay-75"></div>
          <div className="w-1.5 h-1.5 bg-gray-500 rounded-full animate-pulse delay-150"></div>
        </div>
      </div>

      {/* Overlay when not agentified */}
      {!isAgent && (
        <div className="absolute inset-0 flex flex-col items-center bg-black/10 backdrop-blur-[1px] rounded-lg">
          <div className="bg-black/30 px-8 py-4 rounded-xl text-center mt-[225px]">
            <p className="text-lg text-white mb-4">This account has not been agentified yet!</p>
            <button className="px-6 py-2 bg-purple-600 hover:bg-purple-700 text-white rounded-lg font-medium transition-colors">
              MAKE AGENT
            </button>
          </div>
        </div>
      )}
    </div>
  )
}
````

## File: src/modules/account-modules/impact/index.tsx
````typescript
'use client'

import React from 'react'

interface ImpactTabProps {
  address: string
  selectedChain?: string
  isOwner?: boolean
}

export default function ImpactTab({ address, selectedChain, isOwner }: ImpactTabProps) {
  return (
    <div className="flex flex-col items-center justify-center py-16">
      <h2 className="text-2xl font-bold text-gray-200 mb-2">Impact Module</h2>
      <p className="text-lg text-gray-400">
        Coming soon: Track and measure your agent's environmental impact
      </p>
    </div>
  )
}
````

## File: src/modules/account-modules/overview/index.tsx
````typescript
'use client'

import React, { useState, useEffect } from 'react'
// TODO: Implement isEnsuranceToken check when completing assets feature
// import { isEnsuranceToken } from '@/modules/specific/contract'
import AccountStats from '@/modules/accounts/AccountStats'
// import SpecificGrid from '@/modules/specific/SpecificGrid'
import Link from 'next/link'
import { usePathname } from 'next/navigation'

interface OverviewTabProps {
  description?: string
  tbaAddress: string
  isOwner?: boolean
}

interface AssetSummary {
  uniqueCount: number      // Number of unique NFTs (721 + 1155)
  totalCount: number       // Total including quantities
  ensuredCount: number     // Number of ensured assets
  nonEnsuredCount: number  // Number of non-ensured assets
}

interface CurrencySummary {
  totalValue: number
  currencyCount: number  // Number of unique currencies
  chains: string[]
}

export default function OverviewTab({ description, tbaAddress, isOwner }: OverviewTabProps) {
  const pathname = usePathname()
  const accountName = pathname.split('/')[1]
  const keyword = accountName
    ?.split('.')[0]
    ?.split('-')
    ?.filter(Boolean)
    ?.join(' ') || ''

  const [assetSummary, setAssetSummary] = useState<AssetSummary>({ 
    uniqueCount: 0, 
    totalCount: 0,
    ensuredCount: 0,
    nonEnsuredCount: 0
  })
  const [currencySummary, setCurrencySummary] = useState<CurrencySummary>({ totalValue: 0, currencyCount: 0, chains: [] })
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    let isMounted = true

    async function fetchSummaries() {
      if (!tbaAddress) return

      try {
        // Fetch currency and asset data
        const [currencyResponse, assetResponse] = await Promise.all([
          fetch(`/api/accounts/${tbaAddress}/currency`),
          fetch(`/api/accounts/${tbaAddress}/assets`)
        ]);

        if (!currencyResponse.ok || !assetResponse.ok) {
          throw new Error('Failed to fetch data');
        }

        const currencyData = await currencyResponse.json();
        const assetData = await assetResponse.json();

        // Calculate currency summary
        let totalValue = 0;
        let currencyCount = 0;
        const chains = Object.keys(currencyData.groupedBalances || {});

        chains.forEach(chain => {
          currencyData.groupedBalances[chain].forEach((token: any) => {
            const balance = Number(token.queried_wallet_balances[0]?.value_usd_string || 0)
            if (balance > 0) {
              currencyCount++
              totalValue += balance
            }
          })
        });

        // Calculate asset summary
        const uniqueCount = assetData.nfts?.length || 0;
        let totalCount = 0;
        let ensuredCount = 0;
        let nonEnsuredCount = 0;

        assetData.nfts?.forEach((nft: any) => {
          const quantity = Number(nft.queried_wallet_balances?.[0]?.quantity_string || 1)
          totalCount += quantity

          // TODO: Implement isEnsuranceToken check when completing assets feature
          nonEnsuredCount++
        });

        if (isMounted) {
          setCurrencySummary({ totalValue, currencyCount, chains })
          setAssetSummary({
            uniqueCount,
            totalCount,
            ensuredCount,
            nonEnsuredCount
          })
        }

        // Update database stats
        try {
          const statsPayload = {
            account_name: accountName,
            stats: {
              total_currency_value: totalValue,
              total_assets: totalCount,
              ensured_assets: ensuredCount,
              stats_last_updated: new Date().toISOString()
            }
          };
          
          const response = await fetch('/api/accounts/stats', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(statsPayload)
          });
          
        } catch (error) {
          console.error('Failed to update stats in database:', error)
        }
      } catch (error) {
        console.error('Error fetching summaries:', error)
      } finally {
        if (isMounted) {
          setLoading(false)
        }
      }
    }

    fetchSummaries()

    return () => {
      isMounted = false
    }
  }, [tbaAddress, accountName])

  if (loading) {
    return (
      <div className="flex items-center justify-center h-[100px]">
        <div className="animate-pulse text-gray-400">Loading summaries...</div>
      </div>
    )
  }

  return (
    <div className="flex flex-col">
      {/* Description */}
      {description && (
        <div className="bg-gray-900/50 rounded-lg p-2 mb-1">
          <div className="text-xs text-gray-500 uppercase tracking-wide mb-0.5">About</div>
          <p className="text-sm text-gray-300 leading-relaxed">
            {description}
          </p>
        </div>
      )}

      {/* Stats */}
      <AccountStats 
        variant="full"
        total_currency_value={currencySummary.totalValue}
        total_assets={assetSummary.totalCount}
        ensured_assets={assetSummary.ensuredCount}
        uniqueCount={assetSummary.uniqueCount}
        currencyCount={currencySummary.currencyCount}
        chains={currencySummary.chains}
        accountName={accountName}
        loading={loading}
        className="mb-1"
      />
    </div>
  )
}
````

## File: src/modules/account-modules/place/index.tsx
````typescript
'use client'

import React from 'react'

interface PlaceTabProps {
  address: string
  selectedChain?: string
  isOwner?: boolean
}

export default function PlaceTab({ address, selectedChain, isOwner }: PlaceTabProps) {
  return (
    <div className="flex flex-col items-center justify-center py-16">
      <h2 className="text-2xl font-bold text-gray-200 mb-2">Place Module</h2>
      <p className="text-lg text-gray-400">
        Coming soon: Geographic and spatial data for your agent
      </p>
    </div>
  )
}
````

## File: src/modules/account-modules/portfolio/components/Card.tsx
````typescript
import { PortfolioToken, NFTToken, ERC20Token } from '../types';
import Image from 'next/image';
import { formatUnits } from 'viem';
import { cn } from '@/lib/utils';
import Link from 'next/link';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import { EnsureButtonsLite } from '@/modules/ensure/buttons';
import { useState, useEffect } from 'react';
import { getTokenInfo } from '@/modules/specific/collect';

import { CONTRACTS } from '@/modules/specific/config';

interface CardProps {
  token: PortfolioToken;
  variant: 'list' | 'grid' | 'overview';
  address: string;
  context: 'tokenbound' | 'operator';
  isOverview?: boolean;
  isOwner?: boolean;
  isDeployed?: boolean;
  enhancedImageUrl?: string;
}

export default function Card({ 
  token, 
  variant, 
  address, 
  context,
  isOverview = false,
  isOwner = false,
  isDeployed = false,
  enhancedImageUrl
}: CardProps) {
  const imageSize = variant === 'grid' ? 40 : 32;
  const fallbackSize = variant === 'grid' ? 'text-2xl' : 'text-xl';
  
  // State for specific ERC1155 pricing
  const [pricePerToken, setPricePerToken] = useState<bigint | undefined>();
  
  // Check if this is our specific contract
  const isOurSpecificContract = token.ensurance?.isEnsuranceSpecific;
  
  // Determine if buttons should be muted
  const shouldMuteButtons = () => {
    // All ERC721 tokens should be muted
    if (token.type === 'erc721') {
      return true;
    }
    
    // ERC1155 tokens that are NOT our specific contract should be muted
    if (token.type === 'erc1155' && !isOurSpecificContract) {
      return true;
    }
    
    // For tokenbound context, check ownership and deployment
    if (context === 'tokenbound') {
      // If not owner, mute buttons
      if (!isOwner) {
        return true;
      }
      
      // If owner but not deployed, mute buttons
      if (isOwner && !isDeployed) {
        return true;
      }
    }
    
    return false;
  };
  
  // Get appropriate tooltip message based on state
  const getMutedTooltip = () => {
    // Handle token type restrictions first
    if (token.type === 'erc721') {
      return "portfolio actions not supported for this contract";
    }
    
    if (token.type === 'erc1155' && !isOurSpecificContract) {
      return "portfolio actions not supported for this contract";
    }
    
    // Handle tokenbound authentication
    if (context === 'tokenbound') {
      if (!isOwner) {
        return "connect as account operator to enable actions";
      }
      
      if (isOwner && !isDeployed) {
        return "deploy account to enable portfolio actions";
      }
    }
    
    return "portfolio actions not supported for this contract";
  };
  
  // Fetch price for our specific ERC1155 tokens
  useEffect(() => {
    const fetchPrice = async () => {
      if (token.type === 'erc1155' && isOurSpecificContract && token.address) {
        try {
          const nftToken = token as NFTToken;
          const tokenInfo = await getTokenInfo(
            token.address as `0x${string}`,
            nftToken.tokenId
          );
          
          if (tokenInfo?.salesConfig?.pricePerToken) {
            setPricePerToken(tokenInfo.salesConfig.pricePerToken);
          }
        } catch (error) {
          console.error('Failed to fetch token price:', error);
        }
      }
    };
    
    fetchPrice();
  }, [token.type, token.address, isOurSpecificContract]);
  


  const formatBalance = (token: PortfolioToken) => {
    if (token.type === 'erc721') {
      return '1'; // ERC721s always have balance of 1
    }
    
    if (token.type === 'erc1155') {
      return token.balance; // ERC1155s show actual balance
    }
    
    // For fungible tokens, use existing logic
    const formatted = formatUnits(BigInt(token.balance), token.decimals);
    const value = parseFloat(formatted);
    
    // For values >= 1, show full number with commas, no decimals
    if (value >= 1) {
      return Math.floor(value).toLocaleString('en-US');
    }
    
    // For small values, show more decimals to capture small amounts
    return value.toLocaleString('en-US', { 
      minimumSignificantDigits: 1,
      maximumSignificantDigits: 6
    });
  };

  const formatUsdValue = (value: number | null) => {
    if (!value) return '-';
    
    return value.toLocaleString('en-US', {
      style: 'currency',
      currency: 'USD',
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    });
  };

  const formatEthValue = (value: number | null) => {
    if (!value) return '-';
    
    return value.toLocaleString('en-US', {
      minimumFractionDigits: 4,
      maximumFractionDigits: 4
    }) + ' ETH';
  };


  
  const getTokenImage = (token: PortfolioToken): string | undefined => {
    // Return enhanced image URL if available
    if (enhancedImageUrl) {
      return enhancedImageUrl;
    }
    
    if (token.type === 'native') {
      return token.metadata?.image || 'https://raw.githubusercontent.com/0xsquid/assets/main/images/tokens/eth.svg';
    }
    if (token.type === 'erc721' || token.type === 'erc1155') {
      const nftToken = token as NFTToken;
      const imageUrl = nftToken.nftMetadata.image.cachedUrl || nftToken.nftMetadata.image.originalUrl;
      
      // Validate image URL to filter out suspicious domains
      if (imageUrl && isValidImageUrl(imageUrl)) {
        return imageUrl;
      }
      return undefined; // Will fall back to enhanced fetching or placeholder
    }
    if (token.type === 'erc20') {
      return (token as ERC20Token).metadata?.image;
    }
    return undefined;
  };

  // Helper function to validate image URLs
  const isValidImageUrl = (url: string): boolean => {
    try {
      const parsedUrl = new URL(url);
      
      // List of suspicious or untrusted domains to block
      const blockedDomains = [
        'nftcreator.pages.dev',
        // Add other suspicious domains as needed
      ];
      
      // Check if domain is in blocked list
      if (blockedDomains.some(domain => parsedUrl.hostname.includes(domain))) {
        console.warn(`Blocked suspicious image domain: ${parsedUrl.hostname}`);
        return false;
      }
      
      return true;
    } catch (error) {
      console.warn('Invalid image URL:', url);
      return false;
    }
  };

  const getTokenName = (token: PortfolioToken) => {
    if (token.type === 'erc721' || token.type === 'erc1155') {
      return token.name || token.symbol;
    }
    return token.symbol;
  };

  const getImageContainerClasses = (token: PortfolioToken, variant: 'grid' | 'list') => {
    if (token.type === 'erc20' || token.type === 'native') {
      return variant === 'grid' 
        ? "relative w-full aspect-square rounded-full overflow-hidden bg-black/20"
        : "w-8 h-8 bg-gray-800 rounded-full overflow-hidden flex items-center justify-center";
    }
    return variant === 'grid'
      ? "relative w-full aspect-square rounded-lg overflow-hidden bg-black/20"
      : "w-8 h-8 bg-gray-800 rounded-md overflow-hidden flex items-center justify-center";
  };

  const EnsuranceDot = () => (
    <span className={cn(
      "w-2 h-2 rounded-full relative after:content-[''] after:absolute after:inset-0 after:rounded-full after:animate-pulse",
      "bg-yellow-500 after:bg-yellow-500/50"
    )} />
  );

  const getTokenLink = (token: PortfolioToken) => {
    // Don't create links in overview mode
    if (variant === 'overview') return '#';

    // Handle Ensurance tokens
    if (token.ensurance?.isEnsuranceGeneral) {
      return `/general/${token.address}`;
    }
    if (token.ensurance?.isEnsuranceSpecific && (token.type === 'erc721' || token.type === 'erc1155')) {
      const nftToken = token as NFTToken;
      return `/specific/${token.address}/${nftToken.tokenId}`;
    }
    // Handle account tokens (NFTs that are part of a group)
    if (token.ensurance?.isEnsuranceGroup && (token.type === 'erc721' || token.type === 'erc1155')) {
      const nftToken = token as NFTToken;
      return `/${nftToken.name}`;
    }
    return '#';
  };

  const showEnsuranceDot = variant !== 'overview' && 
    (token.ensurance?.isEnsuranceGeneral || token.ensurance?.isEnsuranceSpecific || token.ensurance?.isEnsuranceGroup);

  const getValueTooltip = (token: PortfolioToken) => {
    if (token.type === 'erc721' || token.type === 'erc1155') {
      const nftToken = token as NFTToken;
      const averagePrice = nftToken.value?.averagePrice;
      const averagePriceUsd = nftToken.value?.averagePriceUsd;
      const floorPrice = nftToken.value?.floorPrice;
      const floorPriceUsd = nftToken.value?.floorPriceUsd;
      
      let tooltipContent = [];
      
      // Always show average sale price, even if null
      tooltipContent.push(
        `Average Sale: ${averagePrice ? formatEthValue(averagePrice) : 'N/A'} (${averagePriceUsd ? formatUsdValue(averagePriceUsd) : 'N/A'})`
      );
      
      // Always show floor price, even if null
      tooltipContent.push(
        `Floor Price: ${floorPrice ? formatEthValue(floorPrice) : 'N/A'} (${floorPriceUsd ? formatUsdValue(floorPriceUsd) : 'N/A'})`
      );
      
      return tooltipContent.join('\n');
    }
    return undefined;
  };

  const getDisplayValue = (token: PortfolioToken) => {
    if (token.type === 'erc721' || token.type === 'erc1155') {
      const nftToken = token as NFTToken;
      const quantity = parseInt(token.balance);
      
      // Try to use average sale price first
      if (nftToken.value?.averagePrice && nftToken.value?.averagePriceUsd) {
        return {
          eth: nftToken.value.averagePrice * quantity,
          usd: nftToken.value.averagePriceUsd * quantity,
          isFloorPrice: false
        };
      }
      
      // Fall back to floor price
      if (nftToken.value?.floorPrice && nftToken.value?.floorPriceUsd) {
        return {
          eth: nftToken.value.floorPrice * quantity,
          usd: nftToken.value.floorPriceUsd * quantity,
          isFloorPrice: true
        };
      }
    }
    
    // For other token types, use existing value
    return token.value ? {
      eth: null,
      usd: token.value.usd,
      isFloorPrice: false
    } : null;
  };

  const displayValue = getDisplayValue(token);

  if (variant === 'grid') {
    return (
      <div className="flex flex-col gap-4">
        <Link 
          href={getTokenLink(token)}
          className={cn(
            "block cursor-pointer",
            getTokenLink(token) === '#' && "cursor-default"
          )}
        >
          <div className={getImageContainerClasses(token, 'grid')}>
            {getTokenImage(token) ? (
              <Image
                src={getTokenImage(token)!}
                alt={getTokenName(token)}
                fill
                sizes="(max-width: 640px) 100vw, (max-width: 768px) 50vw, (max-width: 1024px) 33vw, 25vw"
                priority={false}
                loading="lazy"
                className="object-cover"
                unoptimized={true}
                onError={(e) => {
                  const img = e.target as HTMLImageElement;
                  img.src = '/assets/no-image-found.png';
                }}
              />
            ) : (
              <div className="absolute inset-0 flex items-center justify-center">
                <div className={fallbackSize + " font-bold text-gray-600"}>
                  {getTokenName(token).charAt(0)}
                </div>
              </div>
            )}
          </div>
        </Link>
        <div className="flex items-center justify-center gap-2">
          <div className="text-lg font-semibold text-white">
            {getTokenName(token)}
          </div>
          {showEnsuranceDot && <EnsuranceDot />}
        </div>
        <div className="flex items-center justify-between text-sm text-gray-400 px-2">
          <div className="flex gap-4">
            <div>bal: {formatBalance(token)}</div>
            {displayValue && (
              <TooltipProvider>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <div className={cn(
                      "flex items-center gap-1",
                      displayValue.isFloorPrice && "text-gray-500"
                    )}>
                      {formatUsdValue(displayValue.usd)}
                      {displayValue.isFloorPrice && (
                        <span className="text-xs text-gray-500">*</span>
                      )}
                    </div>
                  </TooltipTrigger>
                  <TooltipContent>
                    <p className="whitespace-pre-line">
                      {getValueTooltip(token)}
                      {displayValue.isFloorPrice && "\n\n* Low market activity - using floor price"}
                    </p>
                  </TooltipContent>
                </Tooltip>
              </TooltipProvider>
            )}
          </div>
        </div>
      </div>
    );
  }

  return (
    <tr className="hover:bg-gray-900/30 transition-colors group">
      <td className="py-4 pr-4">
        <div className="flex items-center gap-3">
          <Link 
            href={getTokenLink(token)}
            className={cn(
              "block cursor-pointer",
              getTokenLink(token) === '#' && "cursor-default"
            )}
          >
            <div className={getImageContainerClasses(token, 'list')}>
              {getTokenImage(token) ? (
                <Image
                  src={getTokenImage(token)!}
                  alt={getTokenName(token)}
                  width={imageSize}
                  height={imageSize}
                  className="object-cover"
                />
              ) : (
                <div className={fallbackSize + " font-bold text-gray-600"}>
                  {getTokenName(token).charAt(0)}
                </div>
              )}
            </div>
          </Link>
          <div className="flex flex-col">
            <div className="flex items-center gap-2">
              <div className="font-medium text-white">
                {getTokenName(token)}
              </div>
              {showEnsuranceDot && <EnsuranceDot />}
            </div>
            <div className="text-sm text-gray-400">
              bal: {formatBalance(token)}
            </div>
          </div>
        </div>
      </td>
      <td className="py-4 text-right">
        {displayValue && (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <div className={cn(
                  "flex items-center justify-end gap-1",
                  displayValue.isFloorPrice && "text-gray-500"
                )}>
                  {formatUsdValue(displayValue.usd)}
                  {displayValue.isFloorPrice && (
                    <span className="text-xs text-gray-500">*</span>
                  )}
                </div>
              </TooltipTrigger>
              <TooltipContent>
                <p className="whitespace-pre-line">
                  {getValueTooltip(token)}
                  {displayValue.isFloorPrice && "\n\n* Low market activity - using floor price"}
                </p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        )}
      </td>
      <td className="py-4 text-right">
        <div className="opacity-0 group-hover:opacity-100 transition-opacity duration-200">
          <EnsureButtonsLite
            tokenSymbol={token.symbol}
            tokenName={token.name}
            imageUrl={getTokenImage(token)}
            contractAddress={token.type === 'native' ? '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE' : token.address}
            tokenId={(token.type === 'erc721' || token.type === 'erc1155') ? (token as NFTToken).tokenId : undefined}
            tokenType={token.type as any}
            context={context}
            tbaAddress={context === 'tokenbound' ? address : undefined}
            variant="list"
            showBuy={true}
            showSwap={true}
            showSend={true}
            showBurn={token.ensurance?.isEnsuranceGeneral || token.ensurance?.isEnsuranceSpecific}
            muted={shouldMuteButtons()}
            mutedTooltip={getMutedTooltip()}
            pricePerToken={pricePerToken}
            primaryMintActive={!!pricePerToken}
          />
        </div>
      </td>
    </tr>
  );
}
````

## File: src/modules/account-modules/portfolio/components/PortfolioGrid.tsx
````typescript
import { PortfolioToken, NFTToken } from '../types';
import Card from './Card';
import { Card as UICard, CardContent } from "@/components/ui/card";
import { Skeleton } from "@/components/ui/skeleton";
import { identifyEnsurancePortfolioTokens } from '@/lib/ensurance';
import { useEffect, useState } from 'react';
import { cn } from '@/lib/utils';
import { EnsureButtonsLite } from '@/modules/ensure/buttons';
import { getTokenInfo } from '@/modules/specific/collect';

import { CONTRACTS } from '@/modules/specific/config';

interface PortfolioGridProps {
  tokens: PortfolioToken[];
  isLoading?: boolean;
  address: string;
  context: 'tokenbound' | 'operator';

  isOwner?: boolean;
  isDeployed?: boolean;
}

export default function PortfolioGrid({ 
  tokens, 
  isLoading = false, 
  address, 
  context,
 
  isOwner = false,
  isDeployed = false 
}: PortfolioGridProps) {
  const [processedTokens, setProcessedTokens] = useState<PortfolioToken[]>(tokens);
  const [tokenPrices, setTokenPrices] = useState<Record<string, bigint>>({});
  const [enhancedImages, setEnhancedImages] = useState<Record<string, string>>({});

  useEffect(() => {
    const processTokens = async () => {
      const tokensWithEnsurance = await identifyEnsurancePortfolioTokens(tokens);
      setProcessedTokens(tokensWithEnsurance);
      
      // Fetch prices for our specific ERC1155 tokens
      const pricePromises = tokensWithEnsurance
        .filter(token => 
          token.type === 'erc1155' && 
          token.ensurance?.isEnsuranceSpecific
        )
        .map(async (token) => {
          try {
            const nftToken = token as NFTToken;
            const tokenInfo = await getTokenInfo(
              token.address as `0x${string}`,
              nftToken.tokenId
            );
            
            if (tokenInfo?.salesConfig?.pricePerToken) {
              return {
                key: `${token.address}-${nftToken.tokenId}`,
                price: tokenInfo.salesConfig.pricePerToken
              };
            }
          } catch (error) {
            console.error('Failed to fetch token price:', error);
          }
          return null;
        });
      
      const prices = await Promise.all(pricePromises);
      const priceMap: Record<string, bigint> = {};
      
      prices.forEach(priceData => {
        if (priceData) {
          priceMap[priceData.key] = priceData.price;
        }
      });
      
      setTokenPrices(priceMap);
      
      // Fetch enhanced images for tokens that need it
      const imagePromises = tokensWithEnsurance
        .filter(token => {
          // ERC20 tokens without existing image
          const needsERC20Image = token.type === 'erc20' && 
            !(token as any).metadata?.image;
          
          // ERC721 group tokens (have yellow dot but no good image)
          const needsERC721Image = token.type === 'erc721' && 
            token.ensurance?.isEnsuranceGroup;
          
          return needsERC20Image || needsERC721Image;
        })
        .map(async (token) => {
          try {
            const params = new URLSearchParams({
              address: token.address,
              tokenType: token.type
            });
            
            // Add tokenId for ERC721 tokens
            if (token.type === 'erc721') {
              const nftToken = token as NFTToken;
              params.append('tokenId', nftToken.tokenId);
            }
            
            const response = await fetch(`/api/utilities/image?${params}`);
            const data = await response.json();
            
            if (data.url) {
              const key = token.type === 'erc721' ? 
                `${token.address}-${(token as NFTToken).tokenId}` : 
                token.address;
              return { key, url: data.url };
            }
          } catch (error) {
            console.error('Failed to fetch enhanced image:', error);
          }
          return null;
        });
      
      const images = await Promise.all(imagePromises);
      const imageMap: Record<string, string> = {};
      
      images.forEach(imageData => {
        if (imageData) {
          imageMap[imageData.key] = imageData.url;
        }
      });
      
      setEnhancedImages(imageMap);
    };
    processTokens();
  }, [tokens]);
  
  // Helper functions
  const shouldMuteButtons = (token: PortfolioToken) => {
    // All ERC721 tokens should be muted
    if (token.type === 'erc721') {
      return true;
    }
    
    // ERC1155 tokens that are NOT our specific contract should be muted
    if (token.type === 'erc1155' && !token.ensurance?.isEnsuranceSpecific) {
      return true;
    }
    
    // For tokenbound context, check ownership and deployment
    if (context === 'tokenbound') {
      // If not owner, mute buttons
      if (!isOwner) {
        return true;
      }
      
      // If owner but not deployed, mute buttons
      if (isOwner && !isDeployed) {
        return true;
      }
    }
    
    return false;
  };
  
  // Get appropriate tooltip message based on state
  const getMutedTooltip = (token: PortfolioToken) => {
    // Handle token type restrictions first
    if (token.type === 'erc721') {
      return "portfolio actions not supported for this contract";
    }
    
    if (token.type === 'erc1155' && !token.ensurance?.isEnsuranceSpecific) {
      return "portfolio actions not supported for this contract";
    }
    
    // Handle tokenbound authentication
    if (context === 'tokenbound') {
      if (!isOwner) {
        return "connect as account operator to enable actions";
      }
      
      if (isOwner && !isDeployed) {
        return "deploy account to enable portfolio actions";
      }
    }
    
    return "portfolio actions not supported for this contract";
  };
  
  const getTokenPrice = (token: PortfolioToken) => {
    if (token.type === 'erc1155' && token.ensurance?.isEnsuranceSpecific) {
      const nftToken = token as NFTToken;
      return tokenPrices[`${token.address}-${nftToken.tokenId}`];
    }
    return undefined;
  };
  
  const getEnhancedImageUrl = (token: PortfolioToken) => {
    const key = token.type === 'erc721' ? 
      `${token.address}-${(token as NFTToken).tokenId}` : 
      token.address;
    return enhancedImages[key];
  };

  if (isLoading) {
    return (
      <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6 mt-6">
        {[...Array(4)].map((_, index) => (
          <UICard key={`skeleton-${index}`} className="bg-primary-dark border-gray-800">
            <CardContent className="p-4">
              <Skeleton className="h-48 w-full mb-4 bg-gray-800" />
              <Skeleton className="h-4 w-3/4 mb-2 bg-gray-800" />
            </CardContent>
          </UICard>
        ))}
      </div>
    );
  }

  if (!processedTokens.length) {
    return (
      <div className="text-center py-8">
        <p className="text-lg text-gray-600 dark:text-gray-400">
          No matches found in this portfolio.
        </p>
      </div>
    );
  }

  return (
    <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
      {processedTokens.map((token) => (
        <UICard 
          key={`${token.address}-${token.type}${token.type === 'erc721' || token.type === 'erc1155' ? `-${token.tokenId}` : ''}`}
          className="bg-primary-dark border-gray-800 hover:border-gray-700 transition-colors relative group"
        >
          {(token.ensurance?.isEnsuranceGeneral || token.ensurance?.isEnsuranceSpecific || token.ensurance?.isEnsuranceGroup) && (
            <div className="absolute top-2 right-2 z-10">
              <span className={cn(
                "w-2 h-2 rounded-full relative after:content-[''] after:absolute after:inset-0 after:rounded-full after:animate-pulse",
                "bg-yellow-500 after:bg-yellow-500/50"
              )} />
            </div>
          )}
          <CardContent className="p-4">
            <Card 
              token={token}
              variant="grid"
              address={address}
              context={context}
              isOwner={isOwner}
              isDeployed={isDeployed}
              enhancedImageUrl={getEnhancedImageUrl(token)}
            />
            
            {/* Ensure Buttons - only show on hover */}
            <div className="opacity-0 group-hover:opacity-100 transition-opacity duration-200 flex justify-center mt-2">
              <EnsureButtonsLite
                tokenSymbol={token.symbol}
                tokenName={token.name}
                imageUrl={token.type === 'erc721' || token.type === 'erc1155' ? 
                  (token as any).nftMetadata?.image?.cachedUrl || (token as any).metadata?.image : 
                  token.metadata?.image
                }
                contractAddress={token.type === 'native' ? '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE' : token.address}
                tokenId={(token.type === 'erc721' || token.type === 'erc1155') ? (token as any).tokenId : undefined}
                tokenType={token.type as any}
                context={context}
                tbaAddress={context === 'tokenbound' ? address : undefined}
                variant="grid"
                showBuy={true}
                showSwap={true}
                showSend={true}
                showBurn={token.ensurance?.isEnsuranceGeneral || token.ensurance?.isEnsuranceSpecific}
                muted={shouldMuteButtons(token)}
                mutedTooltip={getMutedTooltip(token)}
                pricePerToken={getTokenPrice(token)}
                primaryMintActive={!!getTokenPrice(token)}
              />
            </div>
          </CardContent>
        </UICard>
      ))}
    </div>
  );
}
````

## File: src/modules/account-modules/portfolio/components/PortfolioList.tsx
````typescript
import { PortfolioToken, NFTToken } from '../types';
import Card from './Card';
import { identifyEnsurancePortfolioTokens } from '@/lib/ensurance';
import { useEffect, useState } from 'react';
import { cn } from '@/lib/utils';
import Link from 'next/link';
import { EnsureButtonsLite } from '@/modules/ensure/buttons';

interface PortfolioListProps {
  tokens: PortfolioToken[];
  isOverview?: boolean;
  address: string;
  context: 'tokenbound' | 'operator';
  account?: string;
  isOwner?: boolean;
  isDeployed?: boolean;
}

export default function PortfolioList({ 
  tokens, 
  isOverview = false, 
  address, 
  context,
  account, 
  isOwner = false,
  isDeployed = false 
}: PortfolioListProps) {
  const [processedTokens, setProcessedTokens] = useState<PortfolioToken[]>(tokens);
  const [enhancedImages, setEnhancedImages] = useState<Record<string, string>>({});

  useEffect(() => {
    const processTokens = async () => {
      const tokensWithEnsurance = await identifyEnsurancePortfolioTokens(tokens);
      setProcessedTokens(tokensWithEnsurance);
      
      // Fetch enhanced images for tokens that need it
      const imagePromises = tokensWithEnsurance
        .filter(token => {
          // ERC20 tokens without existing image
          const needsERC20Image = token.type === 'erc20' && 
            !(token as any).metadata?.image;
          
          // ERC721 group tokens (have yellow dot but no good image)
          const needsERC721Image = token.type === 'erc721' && 
            token.ensurance?.isEnsuranceGroup;
          
          return needsERC20Image || needsERC721Image;
        })
        .map(async (token) => {
          try {
            const params = new URLSearchParams({
              address: token.address,
              tokenType: token.type
            });
            
            // Add tokenId for ERC721 tokens
            if (token.type === 'erc721') {
              const nftToken = token as NFTToken;
              params.append('tokenId', nftToken.tokenId);
            }
            
            const response = await fetch(`/api/utilities/image?${params}`);
            const data = await response.json();
            
            if (data.url) {
              const key = token.type === 'erc721' ? 
                `${token.address}-${(token as NFTToken).tokenId}` : 
                token.address;
              return { key, url: data.url };
            }
          } catch (error) {
            console.error('Failed to fetch enhanced image:', error);
          }
          return null;
        });
      
      const images = await Promise.all(imagePromises);
      const imageMap: Record<string, string> = {};
      
      images.forEach(imageData => {
        if (imageData) {
          imageMap[imageData.key] = imageData.url;
        }
      });
      
      setEnhancedImages(imageMap);
    };
    processTokens();
  }, [tokens]);

  // Helper function to get enhanced image URL
  const getEnhancedImageUrl = (token: PortfolioToken) => {
    const key = token.type === 'erc721' ? 
      `${token.address}-${(token as NFTToken).tokenId}` : 
      token.address;
    return enhancedImages[key];
  };

  if (!processedTokens.length) {
    return (
      <div className="text-center py-8">
        <p className="text-gray-500">None found</p>
      </div>
    );
  }

  // If in overview mode, sort by USD value and limit to 10 items
  const displayTokens = isOverview 
    ? [...processedTokens]
        .sort((a, b) => {
          const aValue = a.value?.usd || 0;
          const bValue = b.value?.usd || 0;
          return bValue - aValue; // Sort descending
        })
        .slice(0, 10)
    : processedTokens;

  return (
    <div className="overflow-x-auto relative">
      <table className="w-full">
        {!isOverview && (
          <thead>
            <tr className="text-left text-sm text-gray-400">
              <th className="pb-4 font-medium w-[50%]">name</th>
              <th className="pb-4 font-medium text-right w-[30%]">value</th>
              <th className="pb-4 font-medium text-right w-[20%]">actions</th>
            </tr>
          </thead>
        )}
        <tbody className={`divide-y divide-gray-800 ${isOverview ? 'space-y-2' : ''}`}>
          {displayTokens.map((token) => (
            <Card
              key={`${token.address}-${token.type}${token.type === 'erc721' || token.type === 'erc1155' ? `-${token.tokenId}` : ''}`}
              token={token}
              variant={isOverview ? 'overview' : 'list'}
              address={address}
              context={context}
              isOverview={isOverview}
              isOwner={isOwner}
              isDeployed={isDeployed}
              enhancedImageUrl={getEnhancedImageUrl(token)}
            />
          ))}
        </tbody>
      </table>
      {isOverview && account && (
        <Link href={`/${account}/hold`} className="absolute inset-0 z-10" tabIndex={-1} aria-label="View all assets">
          <span className="sr-only">View all assets</span>
        </Link>
      )}
    </div>
  );
}
````

## File: src/modules/account-modules/portfolio/hooks/usePortfolioData.ts
````typescript
import { useState, useEffect } from 'react';
import { PortfolioToken } from '../types';
import { formatUnits } from 'viem';
import { getTokenImage } from '../utils/getTokenImage';
import { getPriceFloor } from '../utils/getPriceFloor';
import { getSalesData } from '../utils/getSalesData';
import { CONTRACTS } from '@/modules/specific/config';

export function usePortfolioData(tbaAddress: string) {
  const [tokens, setTokens] = useState<PortfolioToken[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchTokens = async () => {
      if (!tbaAddress) {
        setError('No address provided');
        setIsLoading(false);
        return;
      }

      try {
        setIsLoading(true);
        setError(null);

        // First get the spam list
        const spamResponse = await fetch('/api/utilities/spam');
        if (!spamResponse.ok) {
          throw new Error('Failed to fetch spam list');
        }
        const { addresses: spamAddresses } = await spamResponse.json();
        console.log('Spam addresses:', spamAddresses);

        // Get list of supported tokens to identify ensurance tokens
        const [currenciesResponse, certificatesResponse] = await Promise.all([
          fetch('/api/currencies'),
          fetch('/api/general')
        ]);

        const supportedTokens = new Set();
        if (currenciesResponse.ok) {
          const currencies = await currenciesResponse.json();
          currencies.forEach((c: any) => supportedTokens.add(c.address.toLowerCase()));
        }
        if (certificatesResponse.ok) {
          const certificates = await certificatesResponse.json();
          certificates.forEach((c: any) => supportedTokens.add(c.contract_address.toLowerCase()));
        }

        // Fetch both fungible and non-fungible tokens in parallel
        const [fungibleResponse, nonfungibleResponse] = await Promise.all([
          fetch(`/api/alchemy/fungible?address=${tbaAddress}`),
          fetch(`/api/alchemy/nonfungible?address=${tbaAddress}`)
        ]);

        if (!fungibleResponse.ok || !nonfungibleResponse.ok) {
          throw new Error('Failed to fetch token data');
        }

        const fungibleData = await fungibleResponse.json();
        const nonfungibleData = await nonfungibleResponse.json();

        // Transform fungible tokens (native + ERC20)
        const fungibleTokens = await Promise.all(
          fungibleData.data.tokens.map(async (token: any) => {
            // Identify ETH by null tokenAddress in Alchemy response
            const isNative = !token.tokenAddress;
            const price = token.tokenPrices?.[0]?.value;
            const decimals = token.tokenMetadata?.decimals || 18;
            
            // Skip tokens with zero balance
            if (token.tokenBalance === '0x0000000000000000000000000000000000000000000000000000000000000000') {
              return null;
            }

            // Skip spam tokens
            if (!isNative && spamAddresses.includes(token.tokenAddress.toLowerCase())) {
              console.log('Filtered out spam fungible token:', token.tokenAddress);
              return null;
            }
            
            // Convert balance from hex to decimal considering token decimals
            const formattedBalance = formatUnits(BigInt(token.tokenBalance), decimals);
            
            // Calculate total value in USD
            const totalValue = price ? parseFloat(formattedBalance) * parseFloat(price) : null;

            // For ETH, use direct image URL
            const imageUrl = isNative 
              ? 'https://raw.githubusercontent.com/0xsquid/assets/main/images/tokens/eth.svg'
              : await getTokenImage(token.tokenAddress);

            // Check if this is an ensurance token
            const isEnsuranceToken = !isNative && supportedTokens.has(token.tokenAddress.toLowerCase());

            return {
              type: isNative ? 'native' : 'erc20',
              address: isNative ? '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee' : token.tokenAddress,
              symbol: isNative ? 'ETH' : (token.tokenMetadata?.symbol || 'Unknown'),
              name: isNative ? 'Ethereum' : (token.tokenMetadata?.name || 'Unknown Token'),
              balance: token.tokenBalance,
              decimals,
              value: {
                usd: totalValue
              },
              metadata: {
                name: isNative ? 'Ethereum' : (token.tokenMetadata?.name || 'Unknown Token'),
                image: imageUrl
              },
              ...(isEnsuranceToken && {
                ensurance: {
                  isEnsuranceGeneral: true
                }
              })
            };
          })
        );

        // Group NFTs by contract to avoid duplicate price fetches
        const nftGroups = nonfungibleData.data.ownedNfts.reduce((acc: { [key: string]: any[] }, nft: any) => {
          if (!spamAddresses.includes(nft.contract.address.toLowerCase())) {
            if (!acc[nft.contract.address]) {
              acc[nft.contract.address] = [];
            }
            acc[nft.contract.address].push(nft);
          }
          return acc;
        }, {});

        // Fetch price data for each unique contract
        const priceData = await Promise.all(
          Object.keys(nftGroups).map(async (contractAddress) => {
            const [floorData, salesData] = await Promise.all([
              getPriceFloor(contractAddress),
              getSalesData(contractAddress)
            ]);
            return { 
              contractAddress, 
              floorPrice: floorData.floorPrice,
              floorPriceUsd: floorData.floorPriceUsd,
              averagePrice: salesData.averagePrice,
              averagePriceUsd: salesData.averagePriceUsd
            };
          })
        );

        // Create a map of contract addresses to price data
        const priceDataMap = priceData.reduce((acc: { [key: string]: any }, { contractAddress, ...data }) => {
          acc[contractAddress.toLowerCase()] = data;
          return acc;
        }, {});

        // Transform non-fungible tokens (ERC721 + ERC1155)
        const nftTokens = Object.values(nftGroups).flat().map((nft: any) => {
          const priceData = priceDataMap[nft.contract.address.toLowerCase()] || {};
          const balance = parseInt(nft.balance || '1'); // ERC721 always has balance 1
          
          // Use average price if available, otherwise fall back to floor price
          const totalValue = priceData.averagePriceUsd 
            ? priceData.averagePriceUsd * balance 
            : priceData.floorPriceUsd 
              ? priceData.floorPriceUsd * balance 
              : null;

          // Check if this is our specific contract
          const isSpecificContract = nft.contract.address.toLowerCase() === CONTRACTS.specific.toLowerCase();
          
          // Check if this is any ensurance token
          const isEnsuranceToken = supportedTokens.has(nft.contract.address.toLowerCase()) || isSpecificContract;

          return {
            type: nft.tokenType.toLowerCase() as 'erc721' | 'erc1155',
            address: nft.contract.address,
            contractAddress: nft.contract.address,
            symbol: nft.contract.symbol || nft.contract.name,
            name: nft.name,
            balance: nft.balance,
            decimals: 0,
            tokenId: nft.tokenId,
            tokenType: nft.tokenType,
            contract: {
              address: nft.contract.address,
              name: nft.contract.name,
              symbol: nft.contract.symbol,
              tokenType: nft.tokenType
            },
            description: nft.description,
            tokenUri: nft.tokenUri,
            value: {
              usd: totalValue,
              floorPrice: priceData.floorPrice,
              floorPriceUsd: priceData.floorPriceUsd,
              averagePrice: priceData.averagePrice,
              averagePriceUsd: priceData.averagePriceUsd
            },
            nftMetadata: {
              name: nft.name,
              description: nft.description,
              image: {
                cachedUrl: nft.image.cachedUrl,
                thumbnailUrl: nft.image.thumbnailUrl,
                contentType: nft.image.contentType,
                originalUrl: nft.image.originalUrl
              },
              ...(nft.animation && {
                animation: {
                  cachedUrl: nft.animation.cachedUrl,
                  contentType: nft.animation.contentType
                }
              }),
              ...(nft.raw?.metadata?.content && {
                content: {
                  uri: nft.raw.metadata.content.uri,
                  mime: nft.raw.metadata.content.mime
                }
              })
            },
            metadata: {
              name: nft.name,
              image: nft.image.cachedUrl || nft.image.originalUrl
            },
            ...(isEnsuranceToken && {
              ensurance: {
                isEnsuranceSpecific: isSpecificContract,
                isEnsuranceGeneral: !isSpecificContract && supportedTokens.has(nft.contract.address.toLowerCase())
              }
            })
          };
        });

        // Combine and filter out null values
        const allTokens = [...fungibleTokens, ...nftTokens].filter(Boolean);
        console.log('Final token count:', allTokens.length);
        setTokens(allTokens);
      } catch (err) {
        console.error('Error fetching portfolio data:', err);
        setError(err instanceof Error ? err.message : 'Failed to fetch token data');
      } finally {
        setIsLoading(false);
      }
    };

    fetchTokens();
  }, [tbaAddress]);

  return {
    tokens,
    isLoading,
    error
  };
}
````

## File: src/modules/account-modules/portfolio/utils/getPriceFloor.ts
````typescript
export async function getPriceFloor(contractAddress: string): Promise<{ floorPrice: number | null; floorPriceUsd: number | null }> {
  try {
    // Get floor price in ETH
    const floorResponse = await fetch(`/api/moralis/price-floor?address=${contractAddress}`);
    if (!floorResponse.ok) {
      console.warn(`No price floor data for ${contractAddress}`);
      return { floorPrice: null, floorPriceUsd: null };
    }
    
    const floorData = await floorResponse.json();
    const floorPrice = parseFloat(floorData.floor_price);

    // Get current ETH price
    const ethPriceResponse = await fetch('/api/eth-price');
    if (!ethPriceResponse.ok) {
      console.warn('Failed to fetch ETH price');
      return { floorPrice, floorPriceUsd: null };
    }

    const ethPriceData = await ethPriceResponse.json();
    const ethPrice = ethPriceData.price;

    // Calculate USD value
    const floorPriceUsd = floorPrice * ethPrice;

    return { 
      floorPrice,
      floorPriceUsd
    };
  } catch (error) {
    console.error('Error fetching price floor:', error);
    return { floorPrice: null, floorPriceUsd: null };
  }
}
````

## File: src/modules/account-modules/portfolio/utils/getSalesData.ts
````typescript
interface SalesData {
  lastSalePrice: number | null;
  lastSalePriceUsd: number | null;
  averagePrice: number | null;
  averagePriceUsd: number | null;
  lowestPrice: number | null;
  lowestPriceUsd: number | null;
  highestPrice: number | null;
  highestPriceUsd: number | null;
  totalTrades: number;
}

export async function getSalesData(contractAddress: string): Promise<SalesData> {
  try {
    // Get sales data
    const salesResponse = await fetch(`/api/moralis/contract-sales?address=${contractAddress}`);
    if (!salesResponse.ok) {
      console.warn(`No sales data for ${contractAddress}`);
      return {
        lastSalePrice: null,
        lastSalePriceUsd: null,
        averagePrice: null,
        averagePriceUsd: null,
        lowestPrice: null,
        lowestPriceUsd: null,
        highestPrice: null,
        highestPriceUsd: null,
        totalTrades: 0
      };
    }
    
    const salesData = await salesResponse.json();

    // Get current ETH price
    const ethPriceResponse = await fetch('/api/eth-price');
    if (!ethPriceResponse.ok) {
      console.warn('Failed to fetch ETH price');
      return {
        lastSalePrice: null,
        lastSalePriceUsd: null,
        averagePrice: null,
        averagePriceUsd: null,
        lowestPrice: null,
        lowestPriceUsd: null,
        highestPrice: null,
        highestPriceUsd: null,
        totalTrades: 0
      };
    }

    const ethPriceData = await ethPriceResponse.json();
    const ethPrice = ethPriceData.price;

    // Extract prices from response
    const lastSalePrice = salesData.last_sale?.price_formatted ? parseFloat(salesData.last_sale.price_formatted) : null;
    const averagePrice = salesData.average_sale?.price_formatted ? parseFloat(salesData.average_sale.price_formatted) : null;
    const lowestPrice = salesData.lowest_sale?.price_formatted ? parseFloat(salesData.lowest_sale.price_formatted) : null;
    const highestPrice = salesData.highest_sale?.price_formatted ? parseFloat(salesData.highest_sale.price_formatted) : null;

    // Calculate USD values using current ETH price
    const lastSalePriceUsd = lastSalePrice ? lastSalePrice * ethPrice : null;
    const averagePriceUsd = averagePrice ? averagePrice * ethPrice : null;
    const lowestPriceUsd = lowestPrice ? lowestPrice * ethPrice : null;
    const highestPriceUsd = highestPrice ? highestPrice * ethPrice : null;

    return {
      lastSalePrice,
      lastSalePriceUsd,
      averagePrice,
      averagePriceUsd,
      lowestPrice,
      lowestPriceUsd,
      highestPrice,
      highestPriceUsd,
      totalTrades: salesData.total_trades || 0
    };
  } catch (error) {
    console.error('Error fetching sales data:', error);
    return {
      lastSalePrice: null,
      lastSalePriceUsd: null,
      averagePrice: null,
      averagePriceUsd: null,
      lowestPrice: null,
      lowestPriceUsd: null,
      highestPrice: null,
      highestPriceUsd: null,
      totalTrades: 0
    };
  }
}
````

## File: src/modules/account-modules/portfolio/utils/getTokenImage.ts
````typescript
import { generalCertificates } from '@/lib/database/certificates/general';

const convertIpfsUrl = (url: string) => {
  if (url?.startsWith('ipfs://')) {
    return url.replace('ipfs://', 'https://magic.decentralized-content.com/ipfs/')
  }
  return url
}

export async function getTokenImage(address: string): Promise<string | null> {
  try {
    const response = await fetch(`/api/utilities/image?address=${address}`);
    if (!response.ok) {
      throw new Error('Failed to fetch token image');
    }
    
    const data = await response.json();
    return data.url;

  } catch (error) {
    console.error('Error fetching token image:', error);
    return null;
  }
}
````

## File: src/modules/account-modules/portfolio/index.tsx
````typescript
import { useState, useMemo } from 'react';
import { ViewMode, TokenFilter, SortConfig, SortField, PortfolioToken } from './types';
import { usePortfolioData } from './hooks/usePortfolioData';
import PortfolioGrid from './components/PortfolioGrid';
import PortfolioList from './components/PortfolioList';
import { Grid, List, ArrowUpDown, Search } from 'lucide-react';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { formatUnits } from 'viem';

interface PortfolioProps {
  address: string;
  context?: 'tokenbound' | 'operator';
  isOwner?: boolean;
  isDeployed?: boolean;
  searchQuery?: string;
}

const SORT_CYCLES: SortField[] = ['name', 'balance', 'value'];

export default function Portfolio({ address, context = 'tokenbound', isOwner = false, isDeployed = false, searchQuery = '' }: PortfolioProps) {
  const [viewMode, setViewMode] = useState<ViewMode>('list');
  const [filter, setFilter] = useState<TokenFilter>('all');
  const [sort, setSort] = useState<SortConfig>({ field: 'value', direction: 'desc' });
  const [localSearchQuery, setLocalSearchQuery] = useState('');
  
  const { tokens: rawTokens, isLoading, error } = usePortfolioData(address);

  const options = [
    { value: 'all', label: 'portfolio' },
    { value: 'currency', label: 'currency' },
    { value: 'assets', label: 'assets' }
  ];

  // Step 1: Use all tokens from the endpoint, no initial filtering
  const uniqueTokens = useMemo(() => {
    if (!rawTokens) return [];
    // Create a Map to dedupe tokens by address and type
    const tokenMap = new Map();
    rawTokens.forEach(token => {
      const key = `${token.address}-${token.type}${token.type === 'erc721' || token.type === 'erc1155' ? `-${token.tokenId}` : ''}`;
      tokenMap.set(key, token);
    });
    return Array.from(tokenMap.values());
  }, [rawTokens]);

  // Step 2: Only filter based on user selection
  const filteredTokens = useMemo(() => {
    if (!uniqueTokens?.length) return [];
    
    return uniqueTokens.filter(token => {
      switch (filter) {
        case 'currency':
          return token.type === 'native' || token.type === 'erc20';
        case 'assets':
          return token.type === 'erc721' || token.type === 'erc1155';
        case 'all':
        default:
          return true;
      }
    });
  }, [uniqueTokens, filter]); // Depend on both uniqueTokens and filter

  // Step 3: Apply search filter
  const searchFilteredTokens = useMemo(() => {
    if (!filteredTokens?.length) return [];
    
    // Use appropriate search query based on context
    const currentSearchQuery = context === 'operator' ? searchQuery : localSearchQuery;
    if (!currentSearchQuery.trim()) return filteredTokens;
    
    const query = currentSearchQuery.toLowerCase().trim();
    return filteredTokens.filter(token => {
      // Search by token name, symbol, or contract address
      const name = token.name?.toLowerCase() || '';
      const symbol = token.symbol?.toLowerCase() || '';
      const address = token.address?.toLowerCase() || '';
      
      return name.includes(query) || 
             symbol.includes(query) || 
             address.includes(query);
    });
  }, [filteredTokens, searchQuery, localSearchQuery, context]);

  // Step 4: Sort the filtered tokens
  const sortedTokens = useMemo(() => {
    if (!searchFilteredTokens?.length) return [];
    
    return [...searchFilteredTokens].sort((a, b) => {
      switch (sort.field) {
        case 'name':
          const aName = (a.type === 'erc721' || a.type === 'erc1155' ? a.name : a.symbol)?.toLowerCase() || '';
          const bName = (b.type === 'erc721' || b.type === 'erc1155' ? b.name : b.symbol)?.toLowerCase() || '';
          return sort.direction === 'asc' ? aName.localeCompare(bName) : bName.localeCompare(aName);
        
        case 'balance':
        case 'value':
          const aValue = sort.field === 'balance' 
            ? parseFloat(formatUnits(BigInt(a.balance), a.decimals))
            : a.value?.usd || 0;
          const bValue = sort.field === 'balance'
            ? parseFloat(formatUnits(BigInt(b.balance), b.decimals))
            : b.value?.usd || 0;
          return sort.direction === 'asc' ? aValue - bValue : bValue - aValue;
        
        default:
          return 0;
      }
    });
  }, [searchFilteredTokens, sort]); // Depend on searchFilteredTokens and sort

  const handleSortClick = () => {
    const fields = SORT_CYCLES;
    const currentIndex = fields.indexOf(sort.field);
    
    // Move to next field, or back to first if at end
    const nextField = fields[(currentIndex + 1) % fields.length];
    
    // Set direction based on field type
    setSort({
      field: nextField,
      direction: nextField === 'name' ? 'asc' : 'desc'
    });
  };

  const getSortLabel = () => {
    const labels = {
      name: 'Sort by name (A-Z)',
      balance: 'Sort by balance (High-Low)',
      value: 'Sort by value (High-Low)'
    };
    return labels[sort.field];
  };

  if (isLoading) {
    return (
      <div className="text-center py-8">
        <p className="text-gray-500">Loading portfolio...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className="text-center py-8">
        <p className="text-red-400">{error}</p>
      </div>
    );
  }

  return (
    <div className="space-y-4">
      {/* Controls Bar */}
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-4">
          {/* Filter Dropdown as Heading */}
          <Select value={filter} onValueChange={(value) => setFilter(value as TokenFilter)}>
            <SelectTrigger className="text-xl font-medium bg-transparent border-0 hover:bg-transparent focus:ring-0 focus:ring-offset-0 focus-visible:ring-0 focus-visible:ring-offset-0 focus:outline-none pl-0 pr-2 h-auto w-auto">
              <SelectValue placeholder="portfolio" />
            </SelectTrigger>
            <SelectContent className="bg-[#000] border-gray-800">
              {options.map((option) => (
                <SelectItem
                  key={option.value}
                  value={option.value}
                  className="text-white hover:bg-[#111] focus:bg-[#111] cursor-pointer"
                >
                  {option.label}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>

          {/* Small Search Box (TBA context only) */}
          {context === 'tokenbound' && (
            <div className="relative">
              <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 w-4 h-4 text-gray-400" />
              <input
                type="text"
                placeholder="search portfolio"
                value={localSearchQuery}
                onChange={(e) => setLocalSearchQuery(e.target.value)}
                className="pl-9 pr-3 py-1.5 text-sm bg-gray-900/30 rounded-md text-white placeholder-gray-400 focus:outline-none w-40"
              />
            </div>
          )}
        </div>

        {/* View and Sort Controls */}
        <div className="flex gap-2">
          <div className="bg-gray-900/30 rounded-lg p-1 flex gap-1">
            <button
              onClick={() => setViewMode('grid')}
              className={`p-1.5 rounded-md transition-colors ${
                viewMode === 'grid'
                  ? 'bg-gray-800 text-white'
                  : 'text-gray-400 hover:text-white'
              }`}
              aria-label="Grid view"
            >
              <Grid className="w-5 h-5" />
            </button>
            <button
              onClick={() => setViewMode('list')}
              className={`p-1.5 rounded-md transition-colors ${
                viewMode === 'list'
                  ? 'bg-gray-800 text-white'
                  : 'text-gray-400 hover:text-white'
              }`}
              aria-label="List view"
            >
              <List className="w-5 h-5" />
            </button>
          </div>

          <button
            onClick={handleSortClick}
            className="bg-gray-900/30 p-1.5 rounded-lg text-gray-400 hover:text-white transition-colors"
            title={getSortLabel()}
          >
            <ArrowUpDown 
              className={`w-5 h-5 transition-transform ${sort.direction === 'desc' ? 'rotate-180' : ''}`}
            />
          </button>
        </div>
      </div>

      {/* Portfolio Content */}
      {viewMode === 'grid' ? (
        <PortfolioGrid 
          tokens={sortedTokens} 
          address={address}
          context={context}
          isOwner={isOwner}
          isDeployed={isDeployed}
        />
      ) : (
        <PortfolioList 
          tokens={sortedTokens} 
          address={address}
          context={context}
          isOwner={isOwner}
          isDeployed={isDeployed}
        />
      )}
    </div>
  );
}
````

## File: src/modules/account-modules/portfolio/types.ts
````typescript
import { EnsuranceFlags } from '@/types';

export interface BaseToken {
  type: 'native' | 'erc20' | 'erc721' | 'erc1155';
  address: string;
  symbol: string;
  name: string;
  balance: string;
  decimals: number;
  value?: {
    usd: number | null;
    floorPrice?: number | null;
    floorPriceUsd?: number | null;
    averagePrice?: number | null;
    averagePriceUsd?: number | null;
  };
  ensurance?: EnsuranceFlags;
}

export interface NativeToken extends BaseToken {
  type: 'native';
  metadata?: {
    name?: string;
    image?: string;
  };
}

export interface ERC20Token extends BaseToken {
  type: 'erc20';
  contractAddress: string;
  metadata?: {
    name?: string;
    image?: string;
  };
}

export interface NFTMetadata {
  name: string;
  description: string;
  image: {
    cachedUrl: string;
    thumbnailUrl: string | null;
    contentType: string;
    originalUrl: string;
  };
  animation?: {
    cachedUrl: string | null;
    contentType: string | null;
  };
  content?: {
    uri: string;
    mime: string;
  };
}

export interface NFTContract {
  address: string;
  name: string;
  symbol: string | null;
  tokenType: 'ERC721' | 'ERC1155';
}

export interface NFTToken extends BaseToken {
  type: 'erc721' | 'erc1155';
  contractAddress: string;
  tokenId: string;
  tokenType: 'ERC721' | 'ERC1155';
  contract: NFTContract;
  description: string;
  tokenUri: string;
  nftMetadata: NFTMetadata;
  metadata?: {
    name?: string;
    image?: string;
  };
}

export type PortfolioToken = NativeToken | ERC20Token | NFTToken;

export type ViewMode = 'grid' | 'list';

export type TokenFilter = 'all' | 'currency' | 'assets';

export type SortField = 'name' | 'balance' | 'value';
export type SortDirection = 'asc' | 'desc';

export interface SortConfig {
  field: SortField;
  direction: SortDirection;
}
````

## File: src/modules/account-modules/reputation/index.tsx
````typescript
'use client'

import React from 'react'

interface ReputationTabProps {
  address: string
  selectedChain: string
  isOwner: boolean
}

export default function ReputationTab({ address, selectedChain, isOwner }: ReputationTabProps) {
  return (
    <div className="flex flex-col items-center justify-center py-16">
      <h2 className="text-2xl font-bold text-gray-200 mb-2">Reputation Module</h2>
      <p className="text-lg text-gray-400">
        Coming soon: View and manage your agent's reputation and credentials
      </p>
    </div>
  )
}
````

## File: src/modules/account-modules/index.tsx
````typescript
'use client'

import React, { useState, useEffect } from 'react'
import { useRouter, useSearchParams } from 'next/navigation'
import * as Tooltip from '@radix-ui/react-tooltip'

// Export tab components so pages can import what they need
export { default as PortfolioTab } from './portfolio'
export { default as ReputationTab } from './reputation'
export { default as PlaceTab } from './place'
export { default as ImpactTab } from './impact'

export interface TabData {
  value: string
  label: string
  component: React.ComponentType<any>
}

interface TabbedModulesProps {
  address: string
  isOwner: boolean
  initialModule?: string | null
  tabs: TabData[]
  label?: string
}

export default function TabbedModules({ 
  address, 
  isOwner = false,
  initialModule,
  tabs = [],
  label
}: TabbedModulesProps) {
  const router = useRouter()
  const searchParams = useSearchParams()
  
  // Validate tabs array
  if (!tabs || tabs.length === 0) {
    return (
      <div className="bg-[#111] rounded-xl p-4">
        <div className="text-gray-400">No tabs available</div>
      </div>
    )
  }

  // Initialize state from URL or defaults
  const defaultTab = initialModule || tabs[0]?.value
  const [activeTab, setActiveTab] = useState(searchParams.get('module') || defaultTab)
  const selectedChain = 'base'  // Hardcoded to base chain

  // Ensure activeTab is valid
  useEffect(() => {
    const isValidTab = tabs.some(tab => tab.value === activeTab)
    if (!isValidTab && tabs.length > 0) {
      setActiveTab(tabs[0].value)
    }
  }, [activeTab, tabs])

  const updateUrl = (tab: string) => {
    const params = new URLSearchParams(Array.from(searchParams.entries()))
    
    // Only update if values are different
    if (params.get('module') !== tab) {
      params.set('module', tab)
    }
    
    // Remove chain param if it exists
    params.delete('chain')

    // Use shallow routing to prevent full page reload
    router.push(`?${params.toString()}`, { scroll: false })
  }

  const handleTabChange = (tab: string) => {
    setActiveTab(tab)
    updateUrl(tab)
  }

  const getTabStyle = (tabValue: string) => {
    const isPortfolioTab = tabValue === 'portfolio'
    const isActive = activeTab === tabValue

    if (isPortfolioTab) {
      return isActive
        ? 'bg-gradient-to-r from-amber-600/90 to-yellow-500/40 text-white font-semibold shadow-sm'
        : 'text-gray-500 dark:text-gray-300 hover:bg-gradient-to-r hover:from-amber-600/80 hover:to-yellow-500/30 hover:text-white hover:font-semibold'
    }

    return isActive
      ? 'bg-gradient-to-r from-slate-700 to-slate-800 text-white font-semibold shadow-sm'
      : 'text-gray-500 dark:text-gray-300 hover:bg-black/20'
  }

  const activeTabData = tabs.find(tab => tab.value === activeTab)

  if (!address) {
    return (
      <div className="bg-[#111] rounded-xl p-4">
        <div className="text-gray-400">Loading...</div>
      </div>
    )
  }

  return (
    <div className="bg-[#111] rounded-xl p-4">
      <div className="flex flex-col border-b border-gray-700">
        {/* Optional Label */}
        {label && (
          <div className="px-2 md:px-4">
            <div className="flex flex-col items-start gap-1">
              <div className="text-xs font-bold bg-clip-text text-transparent bg-gradient-to-r from-amber-300 via-yellow-500 to-amber-600">
                {label}
              </div>
              <div className="w-[175px] h-[2px] bg-gradient-to-r from-amber-300 via-yellow-500 to-amber-600 mb-1" />
            </div>
          </div>
        )}

        {/* Tabs */}
        <div className="flex items-center justify-between w-full px-0 md:px-4">
          <div className="flex items-center gap-0.5 md:gap-2 overflow-x-auto no-scrollbar py-2 px-1 md:px-0">
            {tabs.map((tab) => (
              <Tooltip.Provider key={tab.value}>
                <Tooltip.Root>
                  <Tooltip.Trigger asChild>
                    <button
                      className={`px-1.5 md:px-4 py-1.5 md:py-2 rounded-t-lg transition-all duration-200 whitespace-nowrap text-xs md:text-base ${getTabStyle(tab.value)}`}
                      onClick={() => handleTabChange(tab.value)}
                    >
                      {tab.label}
                    </button>
                  </Tooltip.Trigger>
                </Tooltip.Root>
              </Tooltip.Provider>
            ))}
          </div>
        </div>
      </div>

      {/* Content */}
      <div className="p-2 md:p-4 w-full">
        {activeTabData && address ? (
          <activeTabData.component
            key={`${activeTabData.value}-${selectedChain}`}
            address={address}
            selectedChain={selectedChain}
            isOwner={isOwner}
          />
        ) : (
          <div className="text-gray-400">Loading...</div>
        )}
      </div>
    </div>
  )
}
````

## File: src/modules/accounts/AccountHeader.tsx
````typescript
'use client'

import { toast } from 'react-toastify'
import SingleAccountImage from './SingleAccountImage'
import { usePrivy } from '@privy-io/react-auth'
import { createPublicClient, http, createWalletClient, custom } from 'viem'
import { base } from 'viem/chains'
import { useEffect, useState } from 'react'
import { cn } from '@/lib/utils'
import SITUS_ABI from '@/abi/SitusOG.json'
import type { Address } from 'viem'
import { TokenboundClient } from '@tokenbound/sdk'
import { tokenboundConfig, getTokenBoundClientConfig, isTokenBoundSupportedChain } from '@/config/tokenbound'

interface Group {
  group_name: string
  contract_address: string
}

interface AccountHeaderProps {
  accountName: string
  tokenId: number
  tbaAddress: string
  groupName: string
  isAgent?: boolean
  displayName?: string | null
  isPool?: boolean
}

export default function AccountHeader({ 
  accountName, 
  tokenId, 
  tbaAddress, 
  groupName,
  isAgent,
  displayName,
  isPool 
}: AccountHeaderProps) {
  const { user, ready, authenticated } = usePrivy()
  const [isOwner, setIsOwner] = useState(false)
  const [isDeployed, setIsDeployed] = useState(false)
  const [isDeploying, setIsDeploying] = useState(false)
  const statusDotClasses = "w-3 h-3 rounded-full relative after:content-[''] after:absolute after:inset-0 after:rounded-full after:animate-pulse"
  const largeDotClasses = "w-4 h-4 rounded-full relative after:content-[''] after:absolute after:inset-0 after:rounded-full after:animate-pulse"

  // Decode the account name if it's URL encoded
  const decodedAccountName = decodeURIComponent(accountName)

  // Format display name for pools
  const formattedDisplayName = isPool && displayName 
    ? `${displayName.toLowerCase()} ensurance`
    : decodedAccountName

  useEffect(() => {
    async function checkStatus() {
      if (!user?.wallet?.address) return

      try {
        const client = createPublicClient({
          chain: base,
          transport: http()
        })

        // Get the contract address from the group name
        const factoryResponse = await fetch('/api/groups')
        const groups = (await factoryResponse.json()) as Group[]
        const group = groups.find(g => g.group_name === `.${groupName}`)
        
        if (!group?.contract_address) {
          console.warn('Group contract address not found')
          return
        }

        // Check ownership
        const owner = await client.readContract({
          address: group.contract_address as `0x${string}`,
          abi: SITUS_ABI,
          functionName: 'ownerOf',
          args: [BigInt(tokenId)]
        }) as Address

        setIsOwner(owner.toLowerCase() === user.wallet.address.toLowerCase())

        // Check TBA deployment using Tokenbound SDK
        const tokenboundClient = new TokenboundClient({
          chainId: base.id,
          walletClient: createWalletClient({
            account: user.wallet.address as `0x${string}`,
            chain: base,
            transport: custom(window.ethereum)
          })
        })

        const deployed = await tokenboundClient.checkAccountDeployment({
          accountAddress: tbaAddress as `0x${string}`
        })

        setIsDeployed(deployed)
      } catch (error) {
        console.error('Error checking status:', error)
      }
    }

    checkStatus()
  }, [user?.wallet?.address, tokenId, groupName, tbaAddress])

  const handleDeployAccount = async () => {
    if (!user?.wallet?.address || !isOwner || isDeployed || isDeploying) return;

    try {
      setIsDeploying(true);
      toast.info('Deploying account...', { autoClose: false, toastId: 'deploying' });

      // Get the contract address from the group name
      const factoryResponse = await fetch('/api/groups');
      const groups = (await factoryResponse.json()) as Group[];
      const group = groups.find(g => g.group_name === `.${groupName}`);
      
      if (!group?.contract_address) {
        throw new Error('Group contract address not found');
      }

      if (!isTokenBoundSupportedChain(tokenboundConfig.chainId)) {
        throw new Error('Chain not supported for tokenbound operations');
      }

      // Create viem wallet client with our standard config
      const walletClient = createWalletClient({
        account: user.wallet.address as `0x${string}`,
        chain: tokenboundConfig.chain,
        transport: custom(window.ethereum)
      });

      const tokenboundClient = new TokenboundClient(getTokenBoundClientConfig({
        walletClient
      }));

      const { account, txHash } = await tokenboundClient.createAccount({
        tokenContract: group.contract_address as `0x${string}`,
        tokenId: tokenId.toString()
      });

      toast.dismiss('deploying');
      toast.success('Account deployed successfully!', { autoClose: 3000 });
      setIsDeployed(true);
    } catch (error) {
      console.error('Error deploying account:', error);
      toast.dismiss('deploying');
      toast.error('Failed to deploy account. Please try again.');
    } finally {
      setIsDeploying(false);
    }
  };

  return (
    <div className="relative group/main">
      <div className="flex items-center gap-6">
        <div className="w-20 h-20 bg-gray-800 rounded-full">
          <SingleAccountImage 
            tokenId={tokenId}
            groupName={groupName}
            variant="circle"
            className="bg-gray-800"
          />
        </div>
        <div className="flex flex-col gap-1">
          <div className="flex items-center gap-2">
            <h2 className="text-3xl font-bold text-white">
              {formattedDisplayName}
            </h2>
            <div className="flex items-center gap-3">
              {isAgent && (
                <span className="text-xs px-1.5 py-0.5 rounded bg-gray-800/80 text-purple-300/50 font-mono ml-2 translate-y-[2px]">
                  AGENT
                </span>
              )}
              {/* Only show status dots if user is the owner */}
              {isOwner && (
                isDeployed ? (
                  // Large green dot: fully operational
                  <span 
                    className={cn(
                      largeDotClasses,
                      "bg-green-500 after:bg-green-500/50 ml-1"
                    )}
                    title="Your account is fully operational"
                  />
                ) : (
                  <>
                    {/* Small green dot: you are the owner */}
                    <span 
                      className={cn(
                        statusDotClasses,
                        "bg-green-500 after:bg-green-500/50 ml-1"
                      )}
                      title="You operate this account"
                    />
                    {/* Deployment status dot: green if deployed, red if not, clickable if not deployed */}
                    <span 
                      className={cn(
                        statusDotClasses,
                        isDeployed 
                          ? "bg-green-500 after:bg-green-500/50" 
                          : "bg-red-500 after:bg-red-500/50",
                        !isDeployed && !isDeploying && "cursor-pointer hover:scale-110 transition-transform"
                      )}
                      title={isDeployed ? "Account is deployed" : isDeploying ? "Deploying..." : "Click to deploy account"}
                      onClick={!isDeployed && !isDeploying ? handleDeployAccount : undefined}
                    />
                  </>
                )
              )}
            </div>
          </div>
          <div className="flex flex-col gap-0.5">
            {/* Account name on hover - only for pools */}
            {isPool && displayName && (
              <div className="text-sm font-mono text-gray-500 opacity-0 group-hover/main:opacity-70 transition-opacity duration-300 delay-300">
                {decodedAccountName}
              </div>
            )}
            {/* TBA address with copy functionality */}
            <div 
              className="cursor-pointer text-sm font-mono text-gray-500 opacity-0 group-hover/main:opacity-70 transition-opacity duration-300 delay-300 hover:text-gray-300"
              onClick={() => {
                navigator.clipboard.writeText(tbaAddress)
                  .then(() => toast.success('Account address copied to clipboard!', {
                    autoClose: 2000,
                    hideProgressBar: false,
                    closeOnClick: true,
                    pauseOnHover: true,
                    draggable: true,
                  }))
                  .catch(() => toast.error('Failed to copy address'))
              }}
            >
              {tbaAddress}
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}
````

## File: src/modules/accounts/AccountImage.tsx
````typescript
// components/AccountImage.tsx
'use client';

import Image from 'next/image';
import { useState } from 'react';

interface AccountImageProps {
  tokenId: string | number;
  groupName: string;
  variant?: 'circle' | 'square';
  className?: string;
}

export default function AccountImage({ 
  tokenId, 
  groupName,
  variant = 'circle',
  className = ''
}: AccountImageProps) {
  const [imageSrc, setImageSrc] = useState(
    `https://2rhcowhl4b5wwjk8.public.blob.vercel-storage.com/${groupName}/${tokenId}.png`
  );

  const handleImageError = () => {
    if (imageSrc.includes(`/${groupName}/${tokenId}.png`)) {
      // Try group's default image
      setImageSrc(`https://2rhcowhl4b5wwjk8.public.blob.vercel-storage.com/${groupName}/0.png`);
    } else {
      // If group default fails, use global default
      setImageSrc('https://2rhcowhl4b5wwjk8.public.blob.vercel-storage.com/default.png');
    }
  };

  return (
    <div className={`relative h-full aspect-square overflow-hidden ${
      variant === 'circle' ? 'rounded-full' : 'rounded-lg'
    } ${className}`}>
      <Image
        src={imageSrc}
        alt={`Account ${tokenId}`}
        fill
        className="object-cover"
        onError={handleImageError}
        priority
        unoptimized
      />
    </div>
  );
}
````

## File: src/modules/accounts/AccountsGrid.tsx
````typescript
'use client'

import { useState, useEffect, useMemo, useCallback } from 'react'
import Link from 'next/link'
import AccountImage from './AccountImage'
import { Card, CardContent } from "@/components/ui/card"
import { Skeleton } from "@/components/ui/skeleton"
import Image from 'next/image'

interface Account {
    full_account_name: string;
    token_id: number;
    group_name: string;
    is_agent: boolean;
}

interface AccountsGridProps {
    groupName?: string;
    searchQuery?: string;
    walletAddress?: string;
    isAgent?: boolean;
}

export default function AccountsGrid({ 
    groupName, 
    searchQuery = '', 
    walletAddress,
    isAgent
}: AccountsGridProps) {
    const [accounts, setAccounts] = useState<Account[]>([])
    const [loading, setLoading] = useState(true)
    const [error, setError] = useState<string | null>(null)
    const [page, setPage] = useState(1)
    const ITEMS_PER_PAGE = 20

    const getPathPrefix = () => {
        return '';
    };

    // Memoized fetch function
    const fetchAccounts = useCallback(async () => {
        try {
            console.log('AccountsGrid fetching with:', { walletAddress, groupName })

            // For "mine" view: fetch wallet's NFTs filtered by contract(s)
            if (walletAddress) {
                let contractAddresses: string[];
                let groups;
                
                // First get all groups data
                const groupsResponse = await fetch('/api/groups')
                if (!groupsResponse.ok) throw new Error('Failed to fetch groups')
                groups = await groupsResponse.json()
                console.log('Found groups:', groups)

                // If groupName provided, filter to single group
                if (groupName) {
                    const group = groups.find((g: any) => 
                        g.group_name === (groupName.startsWith('.') ? groupName : `.${groupName}`)
                    )
                    if (!group) throw new Error('Group not found')
                    contractAddresses = [group.contract_address.toLowerCase()]
                }
                // For root /mine, use all group contracts
                else {
                    contractAddresses = groups
                        .filter((group: any) => group.contract_address) // Ensure we have a contract
                        .map((group: any) => group.contract_address.toLowerCase())
                }

                console.log('Using contract addresses:', contractAddresses)

                // Use new Alchemy endpoint with contract filtering
                const apiUrl = `/api/alchemy/nonfungible?address=${walletAddress}&contractAddresses=${contractAddresses.join(',')}`
                console.log('Full Alchemy API URL:', apiUrl)

                // Fetch wallet's NFTs filtered by contract(s)
                const nftResponse = await fetch(apiUrl)
                if (!nftResponse.ok) throw new Error('Failed to fetch NFTs')
                const nftData = await nftResponse.json()
                console.log('Raw Alchemy response:', nftData)

                // Transform NFTs to match Account interface
                const transformedNfts = nftData.ownedNfts.map((nft: any) => {
                    // Find matching group for group_name
                    const contractAddress = nft.contract.address.toLowerCase()
                    const matchingGroup = groups.find((group: any) => 
                        group.contract_address.toLowerCase() === contractAddress
                    )
                    const groupName = matchingGroup?.group_name || nft.contract.name || ''

                    return {
                        full_account_name: nft.name, // Use the name directly from Alchemy
                        token_id: parseInt(nft.tokenId),
                        group_name: groupName,
                        is_agent: false // TODO: Determine if this is an agent based on metadata
                    }
                })

                console.log('Transformed NFTs:', transformedNfts)
                return transformedNfts
            }
            // For regular view: use existing DB accounts endpoint
            else {
                const endpoint = groupName 
                    ? `/api/accounts?group=${encodeURIComponent(groupName)}`
                    : '/api/accounts'
                console.log('Fetching DB accounts from:', endpoint)
                
                const response = await fetch(endpoint)
                if (!response.ok) throw new Error('Failed to fetch accounts')
                const data = await response.json()
                console.log('DB accounts:', data)
                return data
            }
        } catch (err) {
            console.error('Error fetching accounts:', err)
            throw err
        }
    }, [walletAddress, groupName])

    // Initial fetch with cleanup
    useEffect(() => {
        let mounted = true;
        setLoading(true)
        
        const load = async () => {
            try {
                const data = await fetchAccounts()
                if (mounted) {
                    setAccounts(data)
                }
            } catch (err) {
                console.error('Error loading accounts:', err)
                if (mounted) {
                    setError('Failed to load accounts')
                }
            } finally {
                if (mounted) {
                    setLoading(false)
                }
            }
        }

        load()
        
        return () => {
            mounted = false
        }
    }, [fetchAccounts])

    // Reset page when filters change
    useEffect(() => {
        setPage(1)
    }, [groupName, searchQuery])

    // Memoized filtered accounts
    const filteredAccounts = useMemo(() => {
        let filtered = accounts;

        // Filter by search
        if (searchQuery) {
            const searchLower = searchQuery.toLowerCase()
            filtered = filtered.filter(account => 
                account?.full_account_name?.toLowerCase()?.includes(searchLower) ?? false
            )
        }

        // Filter by isAgent if specified
        if (isAgent !== undefined) {
            filtered = filtered.filter(account => account.is_agent === isAgent)
        }

        // Sort: agents first, then alphabetically
        return filtered.sort((a, b) => {
            // First sort by is_agent (agents come first)
            if (a.is_agent !== b.is_agent) {
                return a.is_agent ? -1 : 1;
            }
            
            // Then sort alphabetically
            if (!a.full_account_name && !b.full_account_name) return 0;
            if (!a.full_account_name) return 1;  // null values go to end
            if (!b.full_account_name) return -1;
            return a.full_account_name.localeCompare(b.full_account_name);
        });
    }, [accounts, searchQuery, isAgent])

    // Memoized paginated accounts
    const displayedAccounts = useMemo(() => {
        return filteredAccounts.slice(0, page * ITEMS_PER_PAGE)
    }, [filteredAccounts, page])

    const loadMore = useCallback(() => {
        if (displayedAccounts.length < filteredAccounts.length) {
            setPage(p => p + 1)
        }
    }, [displayedAccounts.length, filteredAccounts.length])

    // Handle scroll-based loading
    useEffect(() => {
        const handleScroll = () => {
            if (loading || displayedAccounts.length >= filteredAccounts.length) return;
            
            const scrolledToBottom = 
                window.innerHeight + window.scrollY >= 
                document.documentElement.scrollHeight - 1000;

            if (scrolledToBottom) {
                loadMore();
            }
        };

        window.addEventListener('scroll', handleScroll);
        return () => window.removeEventListener('scroll', handleScroll);
    }, [loading, loadMore, displayedAccounts.length, filteredAccounts.length]);

    if (error) {
        return (
            <div className="text-center py-8">
                <p className="text-red-500">{error}</p>
            </div>
        )
    }

    if (loading) {
        return (
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 md:gap-6">
                {[...Array(8)].map((_, index) => (
                    <Card key={`skeleton-${index}`} className="bg-primary-dark border-gray-800">
                        <CardContent className="p-4 flex items-center">
                            <Skeleton className="w-16 h-16 mr-4 bg-gray-800" />
                            <Skeleton className="h-4 w-3/4 bg-gray-800" />
                        </CardContent>
                    </Card>
                ))}
            </div>
        )
    }

    if (filteredAccounts.length === 0) {
        return (
            <div className="text-center py-8">
                <p className="text-lg text-gray-600 dark:text-gray-400">
                    {walletAddress ? (
                        "API migration in progress - NFT functionality will be restored soon"
                    ) : (
                        <>
                            No{groupName ? ` .${groupName}` : ''} accounts found{searchQuery ? ' matching your search' : ''}.
                            {!searchQuery && (
                                <>
                                    {' '}You can create one{' '}
                                    <Link 
                                        href={`${getPathPrefix()}/create`}
                                        className="text-blue-400 hover:text-blue-300 transition-colors"
                                    >
                                        here
                                    </Link>.
                                </>
                            )}
                        </>
                    )}
                </p>
            </div>
        )
    }

    return (
        <div className="space-y-6">
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 md:gap-6">
                {displayedAccounts.map((account) => (
                    <Link
                        key={account.full_account_name}
                        href={`${getPathPrefix()}/${account.full_account_name}`}
                        className="bg-primary dark:bg-primary-dark hover:bg-primary-dark dark:hover:bg-primary 
                                 text-primary-foreground dark:text-primary-dark-foreground font-bold py-4 px-6 
                                 rounded-lg transition duration-300 ease-in-out transform 
                                 hover:-translate-y-1 hover:scale-105 flex items-center"
                    >
                        <div className="w-20 h-20 flex-shrink-0 mr-6">
                            <AccountImage
                                tokenId={account.token_id}
                                groupName={groupName || account.group_name?.replace('.', '')}
                            />
                        </div>
                        <span className="text-xl font-mono break-all">
                            {account.full_account_name}
                        </span>
                    </Link>
                ))}
            </div>
            {displayedAccounts.length < filteredAccounts.length && (
                <div className="flex justify-center">
                    <button
                        onClick={loadMore}
                        className="px-4 py-2 bg-primary-dark hover:bg-gray-800 rounded-lg transition-colors"
                    >
                        Load More
                    </button>
                </div>
            )}
        </div>
    )
}
````

## File: src/modules/accounts/AccountStats.tsx
````typescript
import Link from 'next/link'
import { cn } from '@/lib/utils'

interface AccountStatsProps {
    variant?: 'mini' | 'detailed' | 'full';
    total_currency_value: number;
    total_assets: number;
    ensured_assets: number;
    uniqueCount?: number;
    currencyCount?: number;
    chains?: string[];
    accountName?: string;  // For links in full variant
    loading?: boolean;
    className?: string;
}

export default function AccountStats({ 
    variant = 'mini',
    total_currency_value,
    total_assets,
    ensured_assets,
    uniqueCount,
    currencyCount,
    chains = [],
    accountName,
    loading = false,
    className
}: AccountStatsProps) {
    if (loading) {
        return (
            <div className="flex items-center justify-center h-[100px]">
                <div className="animate-pulse text-gray-400">Loading stats...</div>
            </div>
        )
    }

    const StatWrapper = ({ children, href }: { children: React.ReactNode, href?: string }) => {
        if (href && variant === 'full') {
            return (
                <Link href={href} className="block h-full">
                    <div className="bg-gray-900/50 rounded-lg p-2 hover:bg-gray-900/70 transition-colors h-full">
                        {children}
                    </div>
                </Link>
            )
        }
        return (
            <div className={cn(
                "bg-gray-900/30 rounded-lg p-2",
                variant === 'full' && "bg-gray-900/50"
            )}>
                {children}
            </div>
        )
    }

    if (variant === 'mini') {
        return (
            <div className={cn("grid grid-cols-2 gap-3 mt-3", className)}>
                {/* Currency Stats */}
                <StatWrapper>
                    <div className="text-xs text-gray-500 uppercase tracking-wide mb-1">Currency</div>
                    <span className="text-base bg-clip-text text-transparent bg-gradient-to-r from-amber-300 via-yellow-500 to-amber-600 tabular-nums">
                        ${Math.round(total_currency_value).toLocaleString()}
                    </span>
                </StatWrapper>

                {/* Asset Stats */}
                <StatWrapper>
                    <div className="text-xs text-gray-500 uppercase tracking-wide mb-1">Assets</div>
                    <div className="flex flex-col">
                        <div className="flex justify-between items-baseline">
                            <span className="text-xs text-gray-500">Total</span>
                            <span className="text-base text-gray-300 tabular-nums">
                                {total_assets?.toLocaleString() || '0'}
                            </span>
                        </div>
                        <div className="flex justify-between items-baseline">
                            <span className="text-xs text-gray-500">Ensured</span>
                            <div className="flex flex-col items-end">
                                <span className="text-base bg-clip-text text-transparent bg-gradient-to-r from-amber-300 via-yellow-500 to-amber-600 tabular-nums">
                                    {ensured_assets?.toLocaleString() || '0'}
                                </span>
                                <span className="text-[10px] text-gray-600">
                                    {total_assets ? ((ensured_assets / total_assets) * 100).toFixed(1) : '0'}% of total
                                </span>
                            </div>
                        </div>
                    </div>
                </StatWrapper>
            </div>
        )
    }

    // Full variant with all stats and links
    return (
        <div className={cn("grid grid-cols-1 md:grid-cols-2 gap-1", className)}>
            {/* Assets Stats */}
            <StatWrapper href={accountName ? `/${accountName}/hold` : undefined}>
                <div className="text-xs text-gray-500 uppercase tracking-wide mb-1">Assets</div>
                <div className="space-y-2.5">
                    {uniqueCount !== undefined && (
                        <div className="flex justify-between items-baseline">
                            <span className="text-xs text-gray-500">Total Portfolio</span>
                            <span className="text-base text-gray-300 tabular-nums">
                                {uniqueCount.toLocaleString()} unique
                            </span>
                        </div>
                    )}
                    <div className="flex justify-between items-baseline">
                        <span className="text-xs text-gray-500">Total Assets</span>
                        <span className="text-base text-gray-300 tabular-nums">
                            {total_assets.toLocaleString()} items
                        </span>
                    </div>
                    <div className="flex justify-between items-baseline">
                        <span className="text-xs text-gray-500">Ensured Assets</span>
                        <div className="flex flex-col items-end">
                            <span className="text-base bg-clip-text text-transparent bg-gradient-to-r from-amber-300 via-yellow-500 to-amber-600 tabular-nums">
                                {ensured_assets.toLocaleString()}
                            </span>
                            <span className="text-[10px] text-gray-600">
                                {((ensured_assets / (uniqueCount || total_assets)) * 100).toFixed(1)}% of {uniqueCount ? 'portfolio' : 'total'}
                            </span>
                        </div>
                    </div>
                </div>
            </StatWrapper>

            {/* Currency Stats */}
            <StatWrapper href={accountName ? `/${accountName}/hold?module=currency` : undefined}>
                <div className="text-xs text-gray-500 uppercase tracking-wide mb-1">Currency</div>
                <div className="space-y-2.5">
                    <div className="flex justify-between items-baseline">
                        <span className="text-xs text-gray-500">Total Value</span>
                        <span className="text-base bg-clip-text text-transparent bg-gradient-to-r from-amber-300 via-yellow-500 to-amber-600 tabular-nums">
                            ${Math.round(total_currency_value).toLocaleString()}
                        </span>
                    </div>
                    {currencyCount !== undefined && (
                        <div className="flex justify-between items-baseline">
                            <span className="text-xs text-gray-500">Currencies</span>
                            <span className="text-base text-gray-300 tabular-nums">
                                {currencyCount}
                            </span>
                        </div>
                    )}
                    {chains && chains.length > 0 && (
                        <div className="flex justify-between items-baseline">
                            <span className="text-xs text-gray-500">Chains</span>
                            <span className="text-base text-gray-300 tabular-nums">
                                {chains.length}
                            </span>
                        </div>
                    )}
                </div>
            </StatWrapper>
        </div>
    )
}
````

## File: src/modules/accounts/context.tsx
````typescript
'use client'

import { createContext, useContext, ReactNode, useEffect, useState } from 'react'
import { usePrivy } from '@privy-io/react-auth'
import { createPublicClient, http, createWalletClient, custom } from 'viem'
import { base } from 'viem/chains'
import SITUS_ABI from '@/abi/SitusOG.json'
import { TokenboundClient } from '@tokenbound/sdk'
import type { Address } from 'viem'

interface Group {
  group_name: string
  contract_address: string
}

interface AccountData {
  full_account_name: string
  token_id: number
  tba_address: string
  group_name: string
  is_agent: boolean
  description?: string
  pool_type?: string | null
  specific_asset_id?: number
}

interface AccountContextType {
  accountData: AccountData
  isOwner: boolean
  isDeployed: boolean
}

const AccountContext = createContext<AccountContextType | null>(null)

export function AccountProvider({ 
  children, 
  accountData 
}: { 
  children: ReactNode
  accountData: AccountData
}) {
  const { user } = usePrivy()
  const [isOwner, setIsOwner] = useState(false)
  const [isDeployed, setIsDeployed] = useState(false)
  
  useEffect(() => {
    async function checkStatus() {
      if (!user?.wallet?.address) return

      try {
        const client = createPublicClient({
          chain: base,
          transport: http()
        })

        // Get the contract address from the group name
        const factoryResponse = await fetch('/api/groups')
        const groups = (await factoryResponse.json()) as Group[]
        const group = groups.find(g => g.group_name === `.${accountData.group_name}`)
        
        if (!group?.contract_address) {
          console.warn('Group contract address not found')
          return
        }

        // Check ownership
        const owner = await client.readContract({
          address: group.contract_address as `0x${string}`,
          abi: SITUS_ABI,
          functionName: 'ownerOf',
          args: [BigInt(accountData.token_id)]
        }) as Address

        setIsOwner(owner.toLowerCase() === user.wallet.address.toLowerCase())

        // Check TBA deployment using Tokenbound SDK
        const tokenboundClient = new TokenboundClient({
          chainId: base.id,
          walletClient: createWalletClient({
            account: user.wallet.address as `0x${string}`,
            chain: base,
            transport: custom(window.ethereum)
          })
        })

        const deployed = await tokenboundClient.checkAccountDeployment({
          accountAddress: accountData.tba_address as `0x${string}`
        })

        setIsDeployed(deployed)
      } catch (error) {
        console.error('Error checking status:', error)
        setIsOwner(false)
        setIsDeployed(false)
      }
    }

    checkStatus()
  }, [user?.wallet?.address, accountData])

  const value = {
    accountData,
    isOwner,
    isDeployed
  }

  return (
    <AccountContext.Provider value={value}>
      {children}
    </AccountContext.Provider>
  )
}

export function useAccount() {
  const context = useContext(AccountContext)
  if (!context) {
    throw new Error('useAccount must be used within an AccountProvider')
  }
  return context
}
````

## File: src/modules/accounts/SingleAccountImage.tsx
````typescript
'use client';

import Image from 'next/image';
import { useState } from 'react';

interface SingleAccountImageProps {
  tokenId: string | number;
  groupName: string;
  variant?: 'circle' | 'square';
  className?: string;
}

export default function SingleAccountImage({ 
  tokenId, 
  groupName,
  variant = 'circle',
  className = ''
}: SingleAccountImageProps) {
  const [imageSrc, setImageSrc] = useState(
    `https://2rhcowhl4b5wwjk8.public.blob.vercel-storage.com/${groupName}/${tokenId}.png`
  );

  const handleImageError = () => {
    if (imageSrc.includes(`/${groupName}/${tokenId}.png`)) {
      // Try group's default image (0.png)
      setImageSrc(`https://2rhcowhl4b5wwjk8.public.blob.vercel-storage.com/${groupName}/0.png`);
    } else if (imageSrc.includes(`/${groupName}/0.png`)) {
      // If group default fails, use global default
      setImageSrc('https://2rhcowhl4b5wwjk8.public.blob.vercel-storage.com/default.png');
    }
  };

  return (
    <div className={`relative h-full aspect-square overflow-hidden ${
      variant === 'circle' ? 'rounded-full' : 'rounded-lg'
    } ${className}`}>
      <Image
        src={imageSrc}
        alt={`Account ${tokenId}`}
        fill
        className="object-cover"
        onError={handleImageError}
        priority
      />
    </div>
  );
}
````

## File: src/modules/accounts/SwarmAccountImage.tsx
````typescript
'use client';

import Image from 'next/image';
import { useState } from 'react';

interface SwarmAccountImageProps {
  tokenId: string | number;
  groupName: string;
  className?: string;
  size?: 'small' | 'large';
  unoptimized?: boolean;
}

export default function SwarmAccountImage({ 
  tokenId, 
  groupName,
  className = '',
  size = 'small',
  unoptimized = false
}: SwarmAccountImageProps) {
  const [imageSrc, setImageSrc] = useState(
    `https://2rhcowhl4b5wwjk8.public.blob.vercel-storage.com/${groupName}/${tokenId}.png`
  );

  const handleImageError = () => {
    if (imageSrc.includes(`/${groupName}/${tokenId}.png`)) {
      // Try group's default image
      setImageSrc(`https://2rhcowhl4b5wwjk8.public.blob.vercel-storage.com/${groupName}/0.png`);
    } else {
      // If group default fails, use global default
      setImageSrc('https://2rhcowhl4b5wwjk8.public.blob.vercel-storage.com/default.png');
    }
  };

  const dimensions = size === 'large' ? 200 : 100;

  return (
    <div className={`relative aspect-square overflow-hidden ${className}`}>
      <Image
        src={imageSrc}
        alt={`Account ${tokenId}`}
        width={dimensions}
        height={dimensions}
        className="object-cover w-full h-full hover:scale-110 transition-transform duration-300 cursor-pointer"
        onError={handleImageError}
        priority
        unoptimized={unoptimized}
      />
    </div>
  );
}
````

## File: src/modules/admin/sync/service.ts
````typescript
import { createPublicClient, http } from 'viem'
import { base } from 'viem/chains'
import { sql } from '@vercel/postgres'
import { TokenboundClient } from "@tokenbound/sdk"
import { getTokenBoundClientConfig } from '@/config/tokenbound'
import type { SyncEntity, SyncOperationResult, GeneralCertificateData, SyncOptions, SyncResult } from './types'
import ZORA_COIN_ABI from '../../../abi/ZoraCoin.json'
import { generalCertificates } from '@/lib/database/certificates/general'
import { getCoin, getCoins } from '@zoralabs/coins-sdk'

// Initialize Viem client with Alchemy
const alchemyApiKey = process.env.ALCHEMY_API_KEY;
if (!alchemyApiKey) {
  console.warn('ALCHEMY_API_KEY not found, falling back to public RPC');
}

export const client = createPublicClient({
  chain: base,
  transport: http(alchemyApiKey 
    ? `https://base-mainnet.g.alchemy.com/v2/${alchemyApiKey}`
    : 'https://mainnet.base.org'
  )
})

// Initialize Tokenbound client
const tokenboundClient = new TokenboundClient(getTokenBoundClientConfig())

// Contract addresses from docs
const FACTORY_ADDRESS = '0x67c814835e1920324634fd6da416a0e79c949970'
const FACTORY_ABI = [
  {
    "inputs": [],
    "name": "getTldsArray",
    "outputs": [{"type": "string[]"}],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [{"type": "string"}],
    "name": "tldNamesAddresses",
    "outputs": [{"type": "address"}],
    "stateMutability": "view",
    "type": "function"
  }
]

const GROUP_ABI = [
  {
    "inputs": [],
    "name": "totalSupply",
    "outputs": [{"type": "uint256"}],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [{"type": "uint256"}],
    "name": "domainIdsNames",
    "outputs": [{"type": "string"}],
    "stateMutability": "view",
    "type": "function"
  }
]

// Sync groups from chain
async function syncGroups(): Promise<SyncOperationResult> {
  const startTime = Date.now()
  const results = []
  let success = 0
  let failed = 0

  try {
    // First get all groups from Factory contract
    const groupNames = await client.readContract({
      address: FACTORY_ADDRESS as `0x${string}`,
      abi: FACTORY_ABI,
      functionName: 'getTldsArray',
      args: []
    }) as string[]

    for (const groupName of groupNames) {
      try {
        // Get contract address for this group
        const contractAddress = await client.readContract({
          address: FACTORY_ADDRESS as `0x${string}`,
          abi: FACTORY_ABI,
          functionName: 'tldNamesAddresses',
          args: [groupName]
        }) as `0x${string}`

        // Get total supply from group contract
        const totalSupply = await client.readContract({
          address: contractAddress,
          abi: GROUP_ABI,
          functionName: 'totalSupply',
          args: []
        })

        // Update or insert group in database, preserving is_active status
        await sql`
          INSERT INTO members.groups (
            group_name,
            contract_address,
            total_supply,
            is_active
          ) VALUES (
            ${groupName},
            ${contractAddress},
            ${Number(totalSupply)},
            COALESCE(
              (SELECT is_active FROM members.groups WHERE group_name = ${groupName}),
              false  -- default to false for new groups
            )
          )
          ON CONFLICT (group_name) DO UPDATE SET
            contract_address = EXCLUDED.contract_address,
            total_supply = EXCLUDED.total_supply
            -- is_active is intentionally not updated to preserve manual control
        `

        results.push({
          id: groupName,
          group: groupName,
          status: 'success' as const,
          data: { 
            contract_address: contractAddress,
            group_name: groupName,
            total_supply: Number(totalSupply)
          }
        })
        success++
      } catch (err: any) {
        results.push({
          id: groupName,
          group: groupName,
          status: 'failed' as const,
          error: err.message
        })
        failed++
      }
    }

  } catch (err: any) {
    throw new Error(`Failed to sync groups: ${err.message}`)
  }

  return {
    options: { entity: 'groups' },
    timestamp: startTime,
    stats: { total: results.length, success, failed },
    results
  }
}

// Get contract data
async function getContractData(address: string) {
  // For now, return a basic ERC721 ABI
  const abi = [
    {
      "inputs": [],
      "name": "totalSupply",
      "outputs": [{"type": "uint256"}],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getTldsArray",
      "outputs": [{"type": "string[]"}],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [{"type": "uint256"}],
      "name": "tokenURI",
      "outputs": [{"type": "string"}],
      "stateMutability": "view",
      "type": "function"
    }
  ]
  return { abi }
}

// Sync accounts from chain
async function syncAccounts(group_name?: string, token_id?: number): Promise<SyncOperationResult> {
  const startTime = Date.now()
  const results = []
  let success = 0
  let failed = 0

  try {
    // Get target groups
    const { rows: targetGroups } = group_name 
      ? await sql`
          SELECT * FROM members.groups 
          WHERE group_name = ${group_name} AND is_active = true
        `
      : await sql`
          SELECT * FROM members.groups 
          WHERE is_active = true
        `

    console.log(`\nStarting accounts sync for ${targetGroups.length} groups...`)

    for (const [groupIndex, group] of targetGroups.entries()) {
      try {
        if (!group.contract_address) {
          throw new Error('No contract address')
        }

        console.log(`\nProcessing group ${groupIndex + 1}/${targetGroups.length}: ${group.group_name}`)

        // Process specific token or all tokens
        const tokens = token_id ? [token_id] : Array.from({ length: group.total_supply }, (_, i) => i + 1)
        console.log(`Total tokens to process: ${tokens.length}`)
        let processedTokens = 0

        for (const id of tokens) {
          try {
            // Get account name from chain
            const accountName = await client.readContract({
              address: group.contract_address as `0x${string}`,
              abi: GROUP_ABI,
              functionName: 'domainIdsNames',
              args: [BigInt(id)]
            })

            // Generate TBA address
            const tbaAddress = await tokenboundClient.getAccount({
              tokenContract: group.contract_address as `0x${string}`,
              tokenId: id.toString()
            })

            // Check if TBA is deployed
            const isDeployed = await tokenboundClient.checkAccountDeployment({
              accountAddress: tbaAddress
            })

            // Construct full account name
            const fullAccountName = `${accountName}${group.group_name}`

            // Update account in database
            const tableName = `accounts_${group.group_name.replace('.', '')}`
            await sql.query(
              `INSERT INTO members.${tableName} (
                token_id,
                account_name,
                full_account_name,
                tba_address,
                tba_deployed,
                is_active
              ) VALUES (
                $1, $2, $3, $4, $5,
                COALESCE(
                  (SELECT is_active FROM members.${tableName} WHERE token_id = $1),
                  true  -- default to true for new accounts
                )
              )
              ON CONFLICT (token_id) DO UPDATE SET
                account_name = EXCLUDED.account_name,
                full_account_name = EXCLUDED.full_account_name,
                tba_address = EXCLUDED.tba_address,
                tba_deployed = EXCLUDED.tba_deployed`,
              [id, accountName, fullAccountName, tbaAddress, isDeployed]
            )

            results.push({
              id: `${group.group_name}-${id}`,
              group: group.group_name,
              token: id,
              status: 'success' as const,
              data: {
                token_id: id,
                account_name: accountName as string,
                full_account_name: fullAccountName,
                holder: '', // Not available here
                group_name: group.group_name,
                tba_address: tbaAddress
              }
            })
            success++

            // Log progress
            processedTokens++
            if (processedTokens % 10 === 0 || processedTokens === tokens.length) {
              console.log(`Progress: ${processedTokens}/${tokens.length} tokens (${Math.round(processedTokens/tokens.length * 100)}%)`)
            }

          } catch (err: any) {
            results.push({
              id: `${group.group_name}-${id}`,
              group: group.group_name,
              token: id,
              status: 'failed' as const,
              error: err.message
            })
            failed++
            console.log(`Failed to sync token ${id}: ${err.message}`)
          }
        }

        console.log(`Completed group ${group.group_name}: ${success} succeeded, ${failed} failed`)

      } catch (err: any) {
        results.push({
          id: group.group_name,
          group: group.group_name,
          status: 'failed' as const,
          error: err.message
        })
        failed++
        console.log(`Failed to process group ${group.group_name}: ${err.message}`)
      }
    }

    console.log(`\nSync completed in ${((Date.now() - startTime)/1000).toFixed(1)}s`)
    console.log(`Total: ${results.length}, Success: ${success}, Failed: ${failed}`)

  } catch (err: any) {
    throw new Error(`Failed to sync accounts: ${err.message}`)
  }

  return {
    options: { entity: 'accounts', group_name, token_id },
    timestamp: startTime,
    stats: { total: results.length, success, failed },
    results
  }
}

// Helper to add delay between batches
const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

// Sync general certificates from chain
async function syncGeneralCertificates(empty_only: boolean = false): Promise<SyncOperationResult> {
  const startTime = Date.now();
  
  try {
    // Get certificates that need syncing
    const certificates = await generalCertificates.getCertificatesForSync(empty_only);
    
    console.log(`\nStarting general certificates sync for ${certificates.length} contracts...`);
    console.log('Using Alchemy RPC endpoint for improved rate limits...');
    if (empty_only) {
      console.log('Only syncing certificates with missing data...');
    }

    // Sync certificates in batches with more aggressive settings since we're using Alchemy
    const results = await generalCertificates.syncBatch(certificates, {
      batchSize: 3,   // Process 3 certificates at once (each makes ~5 RPC calls)
      batchDelay: 500 // 500ms delay between batches (more aggressive with Alchemy)
    });

    const success = results.filter(r => r.status === 'success').length;
    const failed = results.filter(r => r.status === 'failed').length;

    console.log(`\nSync completed in ${((Date.now() - startTime)/1000).toFixed(1)}s`);
    console.log(`Total: ${results.length}, Success: ${success}, Failed: ${failed}`);

    return {
      options: { entity: 'general_certificates', empty_only },
      timestamp: startTime,
      stats: { total: results.length, success, failed },
      results
    };

  } catch (err: any) {
    throw new Error(`Failed to sync general certificates: ${err.message}`);
  }
}

// Sync market data for general certificates
async function syncGeneralCertificatesMarketData(): Promise<SyncOperationResult> {
  console.log('\n=== Starting Market Data Sync ===');
  const startTime = Date.now();
  const results: SyncResult[] = [];
  let success = 0;
  let failed = 0;

  try {
    // Get all certificates
    console.log('Fetching certificates from database...');
    const certificates = await generalCertificates.getAll();
    console.log(`Found ${certificates.length} certificates to sync`);
    
    // Process in smaller batches to avoid rate limits
    const BATCH_SIZE = 3;  // 3 coins per batch
    const BATCH_DELAY = 3000; // 3 seconds between batches
    const CALL_DELAY = 1000;   // 1 second between API calls

    for (let i = 0; i < certificates.length; i += BATCH_SIZE) {
      const batch = certificates.slice(i, i + BATCH_SIZE);
      
      console.log('\n-------------------');
      console.log(`Processing Batch ${Math.floor(i/BATCH_SIZE) + 1}/${Math.ceil(certificates.length/BATCH_SIZE)}`);
      console.log('Addresses:', batch.map(c => c.contract_address).join(', '));

      // Process each certificate in the batch
      for (const cert of batch) {
        try {
          console.log(`\nProcessing ${cert.contract_address}...`);
          
          // Get market data from Zora
          console.log('Calling Zora API...');
          const response = await getCoin({ 
            address: cert.contract_address as `0x${string}`,
            chain: base.id
          });
          
          // Debug logging
          console.log('Full Zora API response:', JSON.stringify(response, null, 2));
          console.log('Response data structure:', {
            hasResponse: !!response,
            hasData: !!response?.data,
            hasZora20Token: !!response?.data?.zora20Token,
            responseKeys: response ? Object.keys(response) : [],
            dataKeys: response?.data ? Object.keys(response.data) : [],
            tokenKeys: response?.data?.zora20Token ? Object.keys(response.data.zora20Token) : []
          });
          
          if (!response?.data?.zora20Token) {
            console.log(`❌ No market data available for ${cert.contract_address}`);
            console.log('Response structure:', {
              hasResponse: !!response,
              hasData: !!response?.data,
              hasZora20Token: !!response?.data?.zora20Token
            });
            results.push({
              id: cert.contract_address,
              status: 'failed' as const,
              error: 'No market data available'
            });
            failed++;
            continue;
          }

          const coinData = response.data.zora20Token;

          // Log the market data we found
          console.log('Found market data:', {
            totalSupply: coinData.totalSupply,
            totalVolume: coinData.totalVolume,
            volume24h: coinData.volume24h,
            marketCap: coinData.marketCap,
            creatorEarnings: coinData.creatorEarnings,
            uniqueHolders: coinData.uniqueHolders
          });

          // Update market data in database
          await generalCertificates.updateMarketData(cert, {
            total_supply: coinData.totalSupply || '0',
            total_volume: coinData.totalVolume || '0',
            volume_24h: coinData.volume24h || '0',
            market_cap: coinData.marketCap || '0',
            creator_earnings: coinData.creatorEarnings || [],
            unique_holders: coinData.uniqueHolders || 0
          });

          console.log(`✓ Updated ${cert.contract_address}`);
          results.push({
            id: cert.contract_address,
            status: 'success' as const,
            data: {
              contract_address: cert.contract_address,
              chain: cert.chain,
              name: cert.name || '',
              symbol: cert.symbol || '',
              token_uri: cert.token_uri || '',
              pool_address: cert.pool_address || undefined,
              total_supply: coinData.totalSupply || '0',
              total_volume: coinData.totalVolume || '0',
              volume_24h: coinData.volume24h || '0',
              market_cap: coinData.marketCap || '0',
              creator_earnings: coinData.creatorEarnings || [],
              unique_holders: coinData.uniqueHolders || 0
            }
          });
          success++;

          // Add delay between API calls
          await sleep(CALL_DELAY);

        } catch (err: any) {
          console.error(`❌ Failed to process ${cert.contract_address}:`, err);
          results.push({
            id: cert.contract_address,
            status: 'failed' as const,
            error: err.message
          });
          failed++;
        }
      }

      // Add delay between batches
      if (i + BATCH_SIZE < certificates.length) {
        console.log(`\nWaiting ${BATCH_DELAY/1000} seconds before next batch...`);
        await sleep(BATCH_DELAY);
      }

      // Log progress
      const progress = Math.min(i + BATCH_SIZE, certificates.length);
      const percentage = ((progress / certificates.length) * 100).toFixed(1);
      console.log('\n-------------------');
      console.log(`Progress: ${progress}/${certificates.length} (${percentage}%)`);
      console.log(`Success: ${success}, Failed: ${failed}`);
    }

    const duration = ((Date.now() - startTime)/1000).toFixed(1);
    console.log('\n=== Market Data Sync Complete ===');
    console.log(`Duration: ${duration}s`);
    console.log(`Final Stats - Total: ${results.length}, Success: ${success}, Failed: ${failed}`);

    return {
      options: { entity: 'general_certificates', market_data: true },
      timestamp: startTime,
      stats: { total: results.length, success, failed },
      results
    };

  } catch (err: any) {
    console.error('❌ Fatal error:', err);
    throw new Error(`Market data sync failed: ${err.message}`);
  }
}

// Sync market data for general certificates using getCoins
async function syncGeneralCertificatesMarketDataBatch(): Promise<SyncOperationResult> {
  console.log('\n=== Starting Batch Market Data Sync ===');
  const startTime = Date.now();
  const results: SyncResult[] = [];
  let success = 0;
  let failed = 0;

  try {
    // Get all certificates
    console.log('Fetching certificates from database...');
    const certificates = await generalCertificates.getAll();
    console.log(`Found ${certificates.length} certificates to sync`);
    
    // Process in batches of 20 (Zora API limit)
    const BATCH_SIZE = 20;
    const BATCH_DELAY = 3000; // 3 seconds between batches

    for (let i = 0; i < certificates.length; i += BATCH_SIZE) {
      const batch = certificates.slice(i, i + BATCH_SIZE);
      const addresses = batch.map(cert => cert.contract_address);
      
      console.log('\n-------------------');
      console.log(`Processing Batch ${Math.floor(i/BATCH_SIZE) + 1}/${Math.ceil(certificates.length/BATCH_SIZE)}`);
      console.log('Addresses:', addresses.join(', '));

      try {
        // Get market data for this batch
        console.log('Calling Zora API...');
        const response = await getCoins({ 
          coins: addresses.map(address => ({
            chainId: base.id,
            collectionAddress: address
          }))
        });
        
        // Debug logging
        console.log('Full Zora API response:', JSON.stringify(response, null, 2));
        
        if (!response?.data?.zora20Tokens) {
          console.log(`❌ No market data available for batch`);
          console.log('Response structure:', {
            hasResponse: !!response,
            hasData: !!response?.data,
            hasZora20Tokens: !!response?.data?.zora20Tokens
          });
          failed += addresses.length;
        } else {
          // Process each token's data
          for (const tokenData of response.data.zora20Tokens) {
            try {
              const cert = certificates.find(c => c.contract_address === tokenData.address);
              if (!cert) {
                console.log(`❌ Certificate not found for address ${tokenData.address}`);
                failed++;
                continue;
              }

              // Update market data in database
              await generalCertificates.updateMarketData(cert, {
                total_supply: tokenData.totalSupply || '0',
                total_volume: tokenData.totalVolume || '0',
                volume_24h: tokenData.volume24h || '0',
                market_cap: tokenData.marketCap || '0',
                creator_earnings: tokenData.creatorEarnings || [],
                unique_holders: tokenData.uniqueHolders || 0
              });

              console.log(`✓ Updated ${tokenData.address}`);
              results.push({
                id: tokenData.address,
                status: 'success' as const,
                data: {
                  contract_address: tokenData.address,
                  chain: cert.chain,
                  name: cert.name || '',
                  symbol: cert.symbol || '',
                  token_uri: cert.token_uri || '',
                  pool_address: cert.pool_address || undefined,
                  total_supply: tokenData.totalSupply || '0',
                  total_volume: tokenData.totalVolume || '0',
                  volume_24h: tokenData.volume24h || '0',
                  market_cap: tokenData.marketCap || '0',
                  creator_earnings: tokenData.creatorEarnings || [],
                  unique_holders: tokenData.uniqueHolders || 0
                }
              });
              success++;
            } catch (err: any) {
              console.error(`❌ Failed to process ${tokenData.address}:`, err);
              results.push({
                id: tokenData.address,
                status: 'failed' as const,
                error: err.message
              });
              failed++;
            }
          }
        }

        // Add delay between batches
        if (i + BATCH_SIZE < certificates.length) {
          console.log(`\nWaiting ${BATCH_DELAY/1000} seconds before next batch...`);
          await sleep(BATCH_DELAY);
        }

        // Log progress
        const progress = Math.min(i + BATCH_SIZE, certificates.length);
        const percentage = ((progress / certificates.length) * 100).toFixed(1);
        console.log('\n-------------------');
        console.log(`Progress: ${progress}/${certificates.length} (${percentage}%)`);
        console.log(`Success: ${success}, Failed: ${failed}`);
      } catch (err: any) {
        console.error('❌ Batch processing error:', err);
        failed += batch.length;
      }
    }

    const duration = ((Date.now() - startTime)/1000).toFixed(1);
    console.log('\n=== Market Data Sync Complete ===');
    console.log(`Duration: ${duration}s`);
    console.log(`Final Stats - Total: ${results.length}, Success: ${success}, Failed: ${failed}`);

    return {
      options: { entity: 'general_certificates', market_data: true },
      timestamp: startTime,
      stats: { total: results.length, success, failed },
      results
    };

  } catch (err: any) {
    console.error('❌ Fatal error:', err);
    throw new Error(`Market data sync failed: ${err.message}`);
  }
}

// Main sync function that handles all sync operations
export async function sync(entity: SyncEntity, options: Omit<SyncOptions, 'entity'> = {}): Promise<SyncOperationResult> {
  const { group_name, token_id, empty_only, market_data, batch_process } = options;

  switch (entity) {
    case 'groups':
      return syncGroups();
    
    case 'accounts':
      return syncAccounts(group_name, token_id);
    
    case 'general_certificates':
      if (market_data) {
        return batch_process 
          ? syncGeneralCertificatesMarketDataBatch()
          : syncGeneralCertificatesMarketData();
      }
      return syncGeneralCertificates(empty_only);
    
    default:
      throw new Error(`Unknown entity: ${entity}`);
  }
}

// Export all sync functions
export {
  syncGroups,
  syncAccounts,
  syncGeneralCertificates,
  syncGeneralCertificatesMarketData,
  syncGeneralCertificatesMarketDataBatch
};
````

## File: src/modules/admin/sync/types.ts
````typescript
export type SyncEntity = 'groups' | 'accounts' | 'general_certificates';

export interface GroupData {
  group_name: string;
  contract_address: string;
  total_supply?: number;
}

export interface GeneralCertificateData {
  contract_address: string;
  chain: string;
  name: string;
  symbol: string;
  token_uri: string;
  description?: string;
  pool_address?: string;
  total_supply?: string;
  total_volume?: string;
  volume_24h?: string;
  market_cap?: string;
  creator_earnings?: {
    amount: {
      currencyAddress: string;
      amountRaw: string;
      amountDecimal: number;
    };
    amountUsd?: string;
  }[];
  unique_holders?: number;
  payout_recipient?: string;
}

export interface AccountData {
  token_id: number;
  account_name: string;
  full_account_name: string;
  holder: string;
  group_name: string;
  tba_address?: string;
}

export interface SyncOptions {
  entity: SyncEntity;
  group_name?: string; // For syncing accounts of a specific group
  token_id?: number; // For syncing a specific account
  empty_only?: boolean; // For syncing only empty general certificates
  market_data?: boolean; // For syncing market data for general certificates
  batch_process?: boolean; // For using getCoins instead of getCoin
}

export interface SyncResult {
  id: string; // contract address for groups/certificates, full_account_name for accounts
  status: 'success' | 'failed';
  error?: string;
  data?: GroupData | AccountData | GeneralCertificateData;
}

export interface SyncOperationResult {
  options: SyncOptions;
  timestamp: number;
  results: SyncResult[];
  stats: {
    total: number;
    success: number;
    failed: number;
  }
}
````

## File: src/modules/assets/AssetSearch.tsx
````typescript
import React, { forwardRef } from 'react'
import { cn } from '@/lib/utils'
import { TypewriterEffect } from '@/components/ui/typewriter-effect'

interface AssetSearchProps {
  searchQuery: string;
  setSearchQuery: (query: string) => void;
  placeholder?: string;
  autoFocus?: boolean;
  typewriterWords?: { text: string }[];
  className?: string;
  onFocus?: () => void;
}

export const AssetSearch = forwardRef<HTMLInputElement, AssetSearchProps>(function AssetSearch({ 
  searchQuery, 
  setSearchQuery, 
  placeholder = "search assets...",
  autoFocus,
  typewriterWords,
  className,
  onFocus
}, ref) {
  return (
    <div className={cn("w-full max-w-md relative", className)}>
      <input
        ref={ref}
        type="text"
        placeholder={typewriterWords ? '' : placeholder.toLowerCase()}
        value={searchQuery}
        onChange={(e) => setSearchQuery(e.target.value)}
        autoFocus={autoFocus}
        onFocus={onFocus}
        className={cn(
          "w-full px-4 py-2 rounded-lg text-center",
          "bg-[rgb(var(--background-rgb))]",
          "border border-[rgba(var(--foreground-rgb),0.1)]",
          "text-[rgb(var(--foreground-rgb))]",
          "placeholder:text-[rgba(var(--foreground-rgb),0.5)]",
          "focus:outline-none focus:ring-2 focus:ring-[rgba(var(--foreground-rgb),0.2)]",
          "transition-colors duration-200"
        )}
      />
      {typewriterWords && !searchQuery && (
        <div className="absolute inset-0 pointer-events-none flex items-center justify-center">
          <TypewriterEffect 
            words={typewriterWords} 
            className="opacity-50 [&>div>span]:!text-base [&>div>span]:!tracking-normal [&>div>span]:!font-normal" 
          />
        </div>
      )}
    </div>
  )
});
````

## File: src/modules/ensure/buttons/accounts/index.ts
````typescript
import * as operator from './operator'
import * as tokenbound from './tokenbound'
import { ButtonContext } from '../types'

/**
 * Account Execution Factory
 * 
 * Routes execution to the appropriate account type
 */

export type AccountExecutionResult = {
  success: boolean
  hash: string
  error?: string
}

/**
 * Execute operation based on context
 */
export const executeOperation = async (
  context: ButtonContext,
  operation: any,
  params: any
): Promise<AccountExecutionResult> => {
  if (context === 'tokenbound') {
    return await tokenbound.executeTransaction(operation, params)
  } else {
    // operator, general, specific contexts use standard wallet
    return await operator.executeTransaction(operation, params)
  }
}

// Re-export for direct access
export { operator, tokenbound }
````

## File: src/modules/ensure/buttons/accounts/operator.ts
````typescript
import { 
  createWalletClient, 
  createPublicClient,
  custom, 
  http,
  type Address,
  maxUint256
} from 'viem'
import { base } from 'viem/chains'
import { executeSwap } from '@/modules/0x/executeSwap'
import { checkAndHandlePermit2Approval } from '../utils/permit2'
import type { OperationResult } from '../operations'

/**
 * Operator Account Operations
 * 
 * Handles execution through standard wallet client
 * Supports permit2 for ERC20 operations via 0x API
 */

export interface ExecutionResult {
  success: boolean
  hash: string
  error?: string
}

export interface ExecutionParams {
  userAddress: string
  provider: any
  walletClient?: any
}

/**
 * Execute transaction through standard wallet
 */
export const executeTransaction = async (
  operation: OperationResult,
  params: ExecutionParams
): Promise<ExecutionResult> => {
  const { userAddress, provider } = params

  try {
    // Create wallet client
    const walletClient = createWalletClient({
      account: userAddress as Address,
      chain: base,
      transport: custom(provider)
    })

    let hash: string

    // Handle approval first if needed
    if (operation.needsApproval && operation.approvalData) {
      // For ERC1155 USDC approval
      if (operation.approvalData.to && operation.approvalData.data) {
        const approvalHash = await walletClient.writeContract({
          address: operation.approvalData.to as Address,
          abi: [
            {
              inputs: [
                { name: 'spender', type: 'address' },
                { name: 'amount', type: 'uint256' }
              ],
              name: 'approve',
              outputs: [{ type: 'bool' }],
              stateMutability: 'nonpayable',
              type: 'function'
            }
          ],
          functionName: 'approve',
          args: [operation.approvalData.spender, maxUint256],
          account: userAddress as Address
        })

        // Wait for approval
        const publicClient = createPublicClient({
          chain: base,
          transport: http()
        })
        await publicClient.waitForTransactionReceipt({ hash: approvalHash })
      }
      
      // For 0x operations with permit2, let executeSwap handle approval
      else if (operation.approvalData.permit2 || operation.approvalData.allowanceTarget) {
        // This will be handled by executeSwap with proper permit2 flow
        console.log('Permit2 operation detected - executeSwap will handle approval')
      }
    }

    // Execute main transaction
    if (operation.transaction.sellToken && operation.transaction.buyToken) {
      // This is a 0x swap operation
      const result = await executeSwap({
        sellToken: operation.transaction.sellToken,
        buyToken: operation.transaction.buyToken,
        amount: operation.transaction.sellAmount,
        userAddress: userAddress as Address,
        provider,
        onStatus: (message: string) => {
          console.log(`🔄 ${message}`)
        }
      })

      if (!result.success || !result.txHash) {
        throw new Error('Swap execution failed')
      }

      hash = result.txHash
    } else {
      // Standard transaction - use sendTransaction for raw data
      hash = await walletClient.sendTransaction({
        to: operation.transaction.to as Address,
        data: operation.transaction.data as `0x${string}`,
        value: operation.transaction.value ? BigInt(operation.transaction.value) : BigInt(0),
        account: userAddress as Address
      })

      // Wait for confirmation
      const publicClient = createPublicClient({
        chain: base,
        transport: http()
      })
      await publicClient.waitForTransactionReceipt({ hash: hash as `0x${string}` })
    }

    return {
      success: true,
      hash
    }
  } catch (error: any) {
    console.error('Operator execution failed:', error)
    return {
      success: false,
      hash: '',
      error: error.message || 'Transaction failed'
    }
  }
}

/**
 * Check if user has sufficient balance for operation
 */
export const checkBalance = async (
  tokenAddress: string,
  userAddress: string,
  amount: bigint,
  isNative: boolean = false
): Promise<boolean> => {
  try {
    const publicClient = createPublicClient({
      chain: base,
      transport: http()
    })

    let balance: bigint

    if (isNative) {
      balance = await publicClient.getBalance({
        address: userAddress as Address
      })
    } else {
      balance = await publicClient.readContract({
        address: tokenAddress as Address,
        abi: [
          {
            inputs: [{ name: 'account', type: 'address' }],
            name: 'balanceOf',
            outputs: [{ type: 'uint256' }],
            stateMutability: 'view',
            type: 'function'
          }
        ],
        functionName: 'balanceOf',
        args: [userAddress as Address]
      }) as bigint
    }

    return balance >= amount
  } catch (error) {
    console.error('Balance check failed:', error)
    return false
  }
}
````

## File: src/modules/ensure/buttons/accounts/tokenbound.ts
````typescript
import { 
  createWalletClient, 
  createPublicClient,
  custom, 
  http,
  type Address,
  maxUint256,
  encodeFunctionData
} from 'viem'
import { base } from 'viem/chains'
import { createTokenboundClient } from '@/config/tokenbound'
import { createTokenboundActions } from '@/lib/tokenbound'
import { handleTokenboundPermit2Approval } from '../utils/permit2'
import type { OperationResult } from '../operations'

/**
 * Tokenbound Account Operations
 * 
 * Handles execution through tokenbound SDK
 * All operations go through the TBA execute function
 * 
 * KEY INSIGHT FOR PERMIT2 + TBA:
 * 1. First, TBA approves tokens to Permit2 (standard ERC20 approval)
 * 2. Then, user signs EIP-712 message that has TBA as the token owner
 * 3. Finally, TBA executes the 0x transaction with the appended signature
 * 
 * This works because:
 * - The 0x API generates Permit2 message with TBA as `from` (token owner)
 * - User can sign this message on behalf of TBA (EIP-1271 compatible)
 * - TBA executes the transaction that validates the signature
 */

export interface TokenboundExecutionResult {
  success: boolean
  hash: string
  error?: string
}

export interface TokenboundExecutionParams {
  userAddress: string
  tbaAddress: string
  provider: any
  toastId?: any
  onStatusUpdate?: (message: string) => void
}

/**
 * Execute transaction through tokenbound account
 */
export const executeTransaction = async (
  operation: OperationResult,
  params: TokenboundExecutionParams
): Promise<TokenboundExecutionResult> => {
  const { userAddress, tbaAddress, provider, onStatusUpdate } = params

  try {
    // Create wallet client for the user (who controls the TBA)
    const walletClient = createWalletClient({
      account: userAddress as Address,
      chain: base,
      transport: custom(provider)
    })

    // Create tokenbound client
    const tokenboundClient = createTokenboundClient(walletClient)
    const tokenboundActions = createTokenboundActions(walletClient, tbaAddress)

    // 1. First check if TBA is deployed
    const isDeployed = await tokenboundClient.checkAccountDeployment({
      accountAddress: tbaAddress as `0x${string}`
    })

    if (!isDeployed) {
      throw new Error('Tokenbound account is not deployed. Please deploy it first.')
    }

    // 2. Special handling for ERC1155 operations (send/burn using safeTransferFrom)
    const PROCEEDS_ADDRESS = '0xa187F8CBdd36D63967c33f5BD4dD4B9ECA51270e'
    if (operation.transaction.to && 
        operation.transaction.data && 
        operation.transaction.data.includes('f242432a')) { // safeTransferFrom selector
      
      // Extract parameters from the transaction data
      // safeTransferFrom(address,address,uint256,uint256,bytes)
      // The data structure after the selector is: from(32) + to(32) + tokenId(32) + amount(32) + dataOffset(32)
      const txData = operation.transaction.data.slice(10) // Remove 0x and selector
      const toHex = txData.slice(64, 128) // Second parameter (to address)
      const tokenIdHex = txData.slice(128, 192) // Third parameter (tokenId)
      const amountHex = txData.slice(192, 256) // Fourth parameter (amount)
      
      const recipientAddress = '0x' + toHex.slice(24) // Remove leading zeros from address
      const tokenId = BigInt('0x' + tokenIdHex).toString()
      const amount = Number(BigInt('0x' + amountHex))
      
      const isBurn = recipientAddress.toLowerCase() === PROCEEDS_ADDRESS.toLowerCase()
      const operationType = isBurn ? 'burn' : 'send'
      
      console.log(`🔄 TBA: Detected ERC1155 ${operationType} operation - using transferNFT method`)
      onStatusUpdate?.(`${operationType === 'burn' ? 'burning' : 'sending'} tokens through your agent account...`)
      
      console.log(`🔄 TBA: ${operationType} details:`, {
        contractAddress: operation.transaction.to,
        tokenId,
        amount,
        recipient: recipientAddress
      })
      
      // Use transferNFT method for both ERC1155 send and burn
      const result = await tokenboundActions.transferNFT(
        {
          contract_address: operation.transaction.to,
          token_id: tokenId,
          contract: { type: 'ERC1155' },
          chain: 'base'
        } as any,
        recipientAddress as Address,
        amount
      )
      
      return {
        success: true,
        hash: result.hash
      }
    }

    let hash: string

    // Handle approval first if needed
    if (operation.needsApproval && operation.approvalData) {
      // For ERC1155 USDC approval through TBA
      if (operation.approvalData.to && operation.approvalData.data) {
        console.log('🔄 TBA: Executing approval transaction...')
        onStatusUpdate?.('executing approval through your agent account...')
        
        const approvalHash = await tokenboundClient.execute({
          account: tbaAddress as `0x${string}`,
          to: operation.approvalData.to as `0x${string}`,
          value: BigInt(0),
          data: operation.approvalData.data as `0x${string}`
        })

        // Wait for approval confirmation
        const publicClient = createPublicClient({
          chain: base,
          transport: http()
        })
        await publicClient.waitForTransactionReceipt({ hash: approvalHash as `0x${string}` })
        
        // Add delay for network propagation
        await new Promise(resolve => setTimeout(resolve, 3000))
      }
      
      // For 0x operations with permit2, handle approval through TBA
      else if (operation.approvalData.permit2 || operation.approvalData.allowanceTarget) {
        console.log('🔄 TBA: Starting permit2 approval process...', {
          sellToken: operation.transaction.sellToken,
          sellAmount: operation.transaction.sellAmount,
          allowanceTarget: operation.approvalData.allowanceTarget,
          hasPermit2Data: !!operation.approvalData.permit2
        })
        
        const approvalResult = await handleTokenboundPermit2Approval({
          sellToken: operation.transaction.sellToken as Address,
          sellAmount: BigInt(operation.transaction.sellAmount),
          allowanceTarget: operation.approvalData.allowanceTarget as Address,
          userAddress: userAddress as Address,
          tbaAddress: tbaAddress as Address,
          tokenboundClient,
          provider,
          onStatus: (message: string) => {
            console.log(`🔄 TBA: ${message}`)
            onStatusUpdate?.(message)
          }
        })
        
        console.log('✅ TBA Permit2 approval completed:', {
          needsApproval: approvalResult.needsApproval,
          approvalHash: approvalResult.approvalHash,
          currentAllowance: approvalResult.currentAllowance.toString()
        })
      }
    }

    // 2. Execute 0x swap with Permit2 signature (if needed)
    if (operation.transaction.sellToken && operation.transaction.buyToken) {
      console.log('🔄 TBA: Processing 0x swap transaction...', {
        to: operation.transaction.to,
        value: operation.transaction.value,
        dataLength: operation.transaction.data?.length,
        hasPermit2: !!operation.approvalData?.permit2
      })
      
      let transactionData = operation.transaction.data as `0x${string}`
      
      // Check if we need to sign Permit2 EIP-712 message and append signature
      if (operation.approvalData?.permit2?.eip712) {
        console.log('🔄 TBA: Signing Permit2 EIP-712 message...')
        onStatusUpdate?.('signing permit2 message for your agent account...')
        
        try {
          // FIXED: For TBAs, the user (owner) signs the EIP-712 message
          // The message should already reference the TBA as the token owner
          const permitData = operation.approvalData.permit2.eip712
          
          // Ensure proper typing for EIP712 data
          const typedData = {
            types: permitData?.types || {},
            domain: permitData?.domain || {},
            primaryType: permitData?.primaryType || 'PermitTransferFrom',
            message: permitData?.message || {}
          }
          
          console.log('🔄 TBA: Signing permit2 with data:', {
            domain: typedData.domain,
            primaryType: typedData.primaryType,
            messageOwner: typedData.message.from || 'unknown',
            tbaAddress: tbaAddress,
            userAddress: userAddress,
            messageDetails: {
              token: typedData.message.permitted?.token,
              amount: typedData.message.permitted?.amount,
              spender: typedData.message.spender,
              nonce: typedData.message.nonce,
              deadline: typedData.message.deadline
            }
          })
          
          // Verify the permit message is for the TBA (security check)
          if (typedData.message.from && 
              typedData.message.from.toLowerCase() !== tbaAddress.toLowerCase()) {
            console.error('❌ TBA: Permit2 message mismatch!', {
              messageFrom: typedData.message.from,
              expectedTBA: tbaAddress
            })
            throw new Error(`Permit2 message owner mismatch. Expected ${tbaAddress}, got ${typedData.message.from}`)
          }
          
          // User signs the EIP-712 message on behalf of the TBA
          // This works because the permit message specifies the TBA as the token owner
          const signature = await provider.request({
            method: 'eth_signTypedData_v4',
            params: [
              userAddress,
              JSON.stringify(typedData)
            ]
          })
          
          console.log('✅ TBA: Permit2 signature obtained:', {
            signatureLength: signature.length,
            signature: signature.slice(0, 20) + '...',
            signedBy: userAddress,
            onBehalfOf: tbaAddress
          })
          
          // Append signature length and signature data to transaction
          // Following 0x documentation format: <transaction_data><signature_length><signature_data>
          const signatureBytes = signature.slice(2) // Remove 0x prefix
          const signatureLengthHex = (signatureBytes.length / 2).toString(16).padStart(64, '0') // 32-byte length
          
          transactionData = `${transactionData}${signatureLengthHex}${signatureBytes}` as `0x${string}`
          
          console.log('🔄 TBA: Appended Permit2 signature to transaction data')
        } catch (signError) {
          console.error('❌ TBA: Failed to sign Permit2 message:', signError)
          throw new Error(`Failed to sign Permit2 message: ${signError}`)
        }
      }
      
      // Update status for swap execution
      onStatusUpdate?.('executing swap through your agent account...')
      
      // Execute 0x transaction with Permit2 signature (if applicable)
      hash = await tokenboundClient.execute({
        account: tbaAddress as `0x${string}`,
        to: operation.transaction.to as `0x${string}`,
        value: operation.transaction.value ? BigInt(operation.transaction.value) : BigInt(0),
        data: transactionData
      })
    } else {
      // 3. Standard transaction through TBA
      console.log('🔄 TBA: Executing standard transaction...')
      onStatusUpdate?.('executing transaction through your agent account...')
      
      hash = await tokenboundClient.execute({
        account: tbaAddress as `0x${string}`,
        to: operation.transaction.to as `0x${string}`,
        value: operation.transaction.value ? BigInt(operation.transaction.value) : BigInt(0),
        data: (operation.transaction.data || '0x') as `0x${string}`
      })
    }

    return {
      success: true,
      hash
    }
  } catch (error: any) {
    console.error('Tokenbound execution failed:', error)
    return {
      success: false,
      hash: '',
      error: error.message || 'Transaction failed'
    }
  }
}

/**
 * Execute ETH transfer through tokenbound actions (legacy method)
 */
export const executeEthTransfer = async (
  amount: number,
  recipient: string,
  params: TokenboundExecutionParams
): Promise<TokenboundExecutionResult> => {
  const { userAddress, tbaAddress, provider } = params

  try {
    const walletClient = createWalletClient({
      account: userAddress as Address,
      chain: base,
      transport: custom(provider)
    })

    const tokenboundActions = createTokenboundActions(walletClient, tbaAddress)

    await tokenboundActions.transferETH({
      amount,
      recipientAddress: recipient as Address,
      chainId: base.id
    })

    return {
      success: true,
      hash: 'pending' // TokenboundActions doesn't return hash
    }
  } catch (error: any) {
    console.error('Tokenbound ETH transfer failed:', error)
    return {
      success: false,
      hash: '',
      error: error.message || 'Transfer failed'
    }
  }
}

/**
 * Execute ERC20 transfer through tokenbound actions (legacy method)
 */
export const executeErc20Transfer = async (
  amount: number,
  recipient: string,
  tokenAddress: string,
  params: TokenboundExecutionParams
): Promise<TokenboundExecutionResult> => {
  const { userAddress, tbaAddress, provider } = params

  try {
    const walletClient = createWalletClient({
      account: userAddress as Address,
      chain: base,
      transport: custom(provider)
    })

    const tokenboundActions = createTokenboundActions(walletClient, tbaAddress)

    await tokenboundActions.transferERC20({
      amount,
      recipientAddress: recipient as Address,
      erc20tokenAddress: tokenAddress as Address,
      erc20tokenDecimals: 18,
      chainId: base.id
    })

    return {
      success: true,
      hash: 'pending' // TokenboundActions doesn't return hash
    }
  } catch (error: any) {
    console.error('Tokenbound ERC20 transfer failed:', error)
    return {
      success: false,
      hash: '',
      error: error.message || 'Transfer failed'
    }
  }
}

/**
 * Execute NFT transfer through tokenbound actions (legacy method) 
 */
export const executeNftTransfer = async (
  tokenAddress: string,
  tokenId: string,
  recipient: string,
  tokenType: 'ERC721' | 'ERC1155',
  params: TokenboundExecutionParams,
  amount?: number
): Promise<TokenboundExecutionResult> => {
  const { userAddress, tbaAddress, provider } = params

  try {
    const walletClient = createWalletClient({
      account: userAddress as Address,
      chain: base,
      transport: custom(provider)
    })

    const tokenboundActions = createTokenboundActions(walletClient, tbaAddress)

    const result = await tokenboundActions.transferNFT(
      {
        contract_address: tokenAddress,
        token_id: tokenId,
        contract: { type: tokenType },
        chain: 'base'
      } as any,
      recipient as Address,
      amount
    )

    return {
      success: true,
      hash: result.hash
    }
  } catch (error: any) {
    console.error('Tokenbound NFT transfer failed:', error)
    return {
      success: false,
      hash: '',
      error: error.message || 'Transfer failed'
    }
  }
}
````

## File: src/modules/ensure/buttons/hooks/useOperations.ts
````typescript
import { useState, useCallback } from 'react'
import { usePrivy, useWallets } from '@privy-io/react-auth'
import { type Id } from 'react-toastify'
import type { 
  ButtonContext, 
  TokenInfo, 
  AccountSearchResult, 
  TokenType
} from '../types'
import { getTokenOperations } from '../operations'
import { executeOperation as executeAccountOperation } from '../accounts'
import {
  createTransactionToast,
  updateTransactionToast,
  successToast,
  errorToast,
  simpleErrorToast,
  permit2ApprovalToast,
  swapExecutionToast,
  stepTransactionToast
} from '../utils/notifications'

interface UseOperationsProps {
  context: ButtonContext
  contractAddress: string
  tokenId?: string
  tokenType?: TokenType
  tbaAddress?: string
  pricePerToken?: bigint
  primaryMintActive?: boolean
  tokenDecimals?: number
  tokenName?: string
  tokenSymbol?: string
}

export const useOperations = ({
  context,
  contractAddress,
  tokenId,
  tokenType = 'erc20',
  tbaAddress,
  pricePerToken,
  primaryMintActive = false,
  tokenDecimals = 18,
  tokenName,
  tokenSymbol
}: UseOperationsProps) => {
  const { login, authenticated, user } = usePrivy()
  const { wallets } = useWallets()
  
  // Loading states
  const [isLoading, setIsLoading] = useState(false)
  const [isBurning, setIsBurning] = useState(false)
  const [isSwapping, setIsSwapping] = useState(false)
  const [currentToast, setCurrentToast] = useState<Id | null>(null)

  /**
   * Get the appropriate wallet provider
   */
  const getProvider = useCallback(async () => {
    if (!user?.wallet?.address) {
      throw new Error("Please connect your wallet first")
    }

    const connectedWallet = wallets.find(wallet => 
      wallet.address.toLowerCase() === user.wallet?.address?.toLowerCase()
    )
    
    if (!connectedWallet) {
      throw new Error("No connected wallet found")
    }

    await connectedWallet.switchChain(8453) // Base chain ID
    return await connectedWallet.getEthereumProvider()
  }, [user?.wallet?.address, wallets])

  /**
   * Execute buy operation
   */
  const executeBuy = useCallback(async (amount: string, selectedToken?: TokenInfo): Promise<void> => {
    if (!authenticated) {
      login()
      return
    }

    // For specific context, check if primary mint is active
    if (context === 'specific' && !primaryMintActive) {
      simpleErrorToast('This policy is no longer issuing certificates')
      return
    }

    setIsLoading(true)
    const toastId = createTransactionToast('buy')
    setCurrentToast(toastId)

    try {
      const toastContext = context === 'tokenbound' ? 'tokenbound' : 'regular'
      stepTransactionToast(toastId, 'setting up transaction', toastContext)

      // Debug log for tokenId
      console.log('🔍 Buy operation - tokenId:', tokenId, 'tokenType:', tokenType)

      // Build operation parameters
      const params = {
        contractAddress,
        tokenId: tokenId || '0', // Use '0' as fallback for non-ERC1155 tokens
        amount,
        selectedToken,
        userAddress: user!.wallet!.address!,
        pricePerToken,
        // For tokenbound, TBA should receive the proceeds
        sendTo: context === 'tokenbound' ? tbaAddress : user!.wallet!.address
      }

      // Build the transaction using operations layer
      // For ERC1155 tokens, always use erc1155 operations regardless of spending token
      // For other tokens, use operation type based on what we're spending
      const operationType = tokenType === 'erc1155' 
        ? 'erc1155'
        : selectedToken 
          ? (selectedToken.type === 'native' ? 'native' : 'erc20')
          : tokenType!
      
      const tokenOps = getTokenOperations(operationType)
      const operation = await tokenOps.buildBuyTransaction(params)

      // Check if we need approval and update toast accordingly
      if (operation.needsApproval && selectedToken) {
        permit2ApprovalToast(toastId, selectedToken.symbol, toastContext)
      } else {
        // Direct execution (no approval needed)
        const fromSymbol = selectedToken?.symbol || 'ETH'
        const toSymbol = 'TOKEN' // Generic target token name
        swapExecutionToast(toastId, fromSymbol, toSymbol, toastContext)
      }

      // Execute using accounts layer
      const provider = await getProvider()
      
      // Create status update function for tokenbound coordination
      const onStatusUpdate = (message: string) => {
        updateTransactionToast(toastId, message)
      }
      
      const executionParams = context === 'tokenbound' 
        ? { 
            userAddress: user!.wallet!.address!, 
            tbaAddress: tbaAddress!, 
            provider,
            toastId,
            onStatusUpdate
          }
        : { userAddress: user!.wallet!.address!, provider }

      const result = await executeAccountOperation(context, operation, executionParams)

      if (result.success) {
        successToast(toastId, 'buy', result.hash)
      } else {
        throw new Error(result.error || 'Transaction failed')
      }
    } catch (error: any) {
      console.error('Buy operation failed:', error)
      if (error?.code === 4001 || error?.message?.includes('rejected')) {
        errorToast(toastId, 'Transaction cancelled', 'Buy cancelled')
      } else {
        errorToast(toastId, error, 'Buy failed')
      }
      throw error
    } finally {
      setIsLoading(false)
      setCurrentToast(null)
    }
  }, [
    authenticated, 
    login, 
    context, 
    primaryMintActive, 
    contractAddress, 
    tokenId, 
    tokenType, 
    tbaAddress, 
    pricePerToken, 
    user, 
    getProvider
  ])

  /**
   * Execute swap operation
   */
  const executeSwap = useCallback(async (amount: string, selectedToken: TokenInfo): Promise<void> => {
    if (!authenticated) {
      login()
      return
    }

    setIsSwapping(true)
    const toastId = createTransactionToast('swap')
    setCurrentToast(toastId)

    try {
      const toastContext = context === 'tokenbound' ? 'tokenbound' : 'regular'
      
      // For swap: we're selling the target token to get the selected token
      // fromSymbol = target token (what we own and are selling)
      // toSymbol = selected token (what we're buying)
      const fromSymbol = tokenName || tokenSymbol || 'Token' // Target token display name
      const toSymbol = selectedToken.symbol // Selected token symbol
      
      stepTransactionToast(toastId, 'setting up swap', toastContext)

      // Build operation parameters
      const params = {
        contractAddress,
        tokenId: tokenId || '',
        amount,
        selectedToken,
        userAddress: user!.wallet!.address!,
        // For tokenbound, TBA should receive the proceeds
        sendTo: context === 'tokenbound' ? tbaAddress : user!.wallet!.address
      }

      // Build the transaction using operations layer
      const tokenOps = getTokenOperations(tokenType!)
      const operation = await tokenOps.buildSwapTransaction(params)

      // Check if we need approval
      if (operation.needsApproval) {
        permit2ApprovalToast(toastId, fromSymbol, toastContext)
      } else {
        swapExecutionToast(toastId, fromSymbol, toSymbol, toastContext)
      }

      // Execute using accounts layer
      const provider = await getProvider()
      
      // Create status update function for tokenbound coordination
      const onStatusUpdate = (message: string) => {
        updateTransactionToast(toastId, message)
      }
      
      const executionParams = context === 'tokenbound' 
        ? { 
            userAddress: user!.wallet!.address!, 
            tbaAddress: tbaAddress!, 
            provider,
            toastId,
            onStatusUpdate
          }
        : { userAddress: user!.wallet!.address!, provider }

      const result = await executeAccountOperation(context, operation, executionParams)

      if (result.success) {
        successToast(toastId, 'swap', result.hash, fromSymbol, toSymbol)
      } else {
        throw new Error(result.error || 'Transaction failed')
      }
    } catch (error: any) {
      console.error('Swap operation failed:', error)
      if (error?.code === 4001 || error?.message?.includes('rejected')) {
        errorToast(toastId, 'Transaction cancelled', 'Swap cancelled')
      } else {
        errorToast(toastId, error, 'Swap failed')
      }
      throw error
    } finally {
      setIsSwapping(false)
      setCurrentToast(null)
    }
  }, [
    authenticated, 
    login, 
    contractAddress, 
    tokenId, 
    tokenType, 
    context, 
    tbaAddress, 
    user, 
    getProvider,
    tokenName,
    tokenSymbol
  ])

  /**
   * Execute send operation
   */
  const executeSend = useCallback(async (amount: string, recipient: string): Promise<void> => {
    if (!authenticated) {
      login()
      return
    }

    setIsLoading(true)
    const toastId = createTransactionToast('send')
    setCurrentToast(toastId)

    try {
      updateTransactionToast(toastId, 'preparing transfer...')

      // Build operation parameters
      const params = {
        contractAddress,
        tokenId: tokenId || '',
        amount,
        recipient,
        userAddress: user!.wallet!.address!,
        tokenDecimals
      }

      // Build the transaction using operations layer
      const tokenOps = getTokenOperations(tokenType!)
      const operation = await tokenOps.buildSendTransaction(params)

      updateTransactionToast(toastId, 'executing transfer...')

      // Execute using accounts layer
      const provider = await getProvider()
      const executionParams = context === 'tokenbound' 
        ? { userAddress: user!.wallet!.address!, tbaAddress: tbaAddress!, provider }
        : { userAddress: user!.wallet!.address!, provider }

      const result = await executeAccountOperation(context, operation, executionParams)

      if (result.success) {
        successToast(toastId, 'send', result.hash)
      } else {
        throw new Error(result.error || 'Transaction failed')
      }
    } catch (error: any) {
      console.error('Send operation failed:', error)
      if (error?.code === 4001 || error?.message?.includes('rejected')) {
        errorToast(toastId, 'Transaction cancelled', 'Send cancelled')
      } else {
        errorToast(toastId, error, 'Send failed')
      }
      throw error
    } finally {
      setIsLoading(false)
      setCurrentToast(null)
    }
  }, [
    authenticated, 
    login, 
    contractAddress, 
    tokenId, 
    tokenType, 
    context, 
    tbaAddress, 
    user, 
    getProvider,
    tokenDecimals
  ])

  /**
   * Execute burn operation
   */
  const executeBurn = useCallback(async (amount: string): Promise<void> => {
    if (!authenticated) {
      login()
      return
    }

    setIsBurning(true)
    const toastId = createTransactionToast('burn')
    setCurrentToast(toastId)

    try {
      updateTransactionToast(toastId, 'preparing burn...')

      // Build operation parameters
      const params = {
        contractAddress,
        tokenId: tokenId || '',
        amount,
        userAddress: user!.wallet!.address!,
        tokenDecimals
      }

      // Build the transaction using operations layer
      const tokenOps = getTokenOperations(tokenType!)
      const operation = await tokenOps.buildBurnTransaction(params)

      updateTransactionToast(toastId, 'executing burn...')

      // Execute using accounts layer
      const provider = await getProvider()
      const executionParams = context === 'tokenbound' 
        ? { userAddress: user!.wallet!.address!, tbaAddress: tbaAddress!, provider }
        : { userAddress: user!.wallet!.address!, provider }

      const result = await executeAccountOperation(context, operation, executionParams)

      if (result.success) {
        successToast(toastId, 'burn', result.hash)
      } else {
        throw new Error(result.error || 'Transaction failed')
      }
    } catch (error: any) {
      console.error('Burn operation failed:', error)
      if (error?.code === 4001 || error?.message?.includes('rejected')) {
        errorToast(toastId, 'Transaction cancelled', 'Burn cancelled')
      } else {
        errorToast(toastId, error, 'Burn failed')
      }
      throw error
    } finally {
      setIsBurning(false)
      setCurrentToast(null)
    }
  }, [
    authenticated, 
    login, 
    contractAddress, 
    tokenId, 
    tokenType, 
    context, 
    tbaAddress, 
    user, 
    getProvider,
    tokenDecimals
  ])

  return {
    // Loading states
    isLoading,
    isBurning,
    isSwapping,
    
    // Operations
    executeBuy,
    executeSwap,
    executeSend,
    executeBurn,
    
    // Auth
    login,
    authenticated,
    userAddress: user?.wallet?.address
  }
}
````

## File: src/modules/ensure/buttons/modals/burn.tsx
````typescript
'use client'

import { useState, useEffect } from 'react'
import { usePrivy } from '@privy-io/react-auth'
import { createPublicClient, http, type Address } from 'viem'
import { base } from 'viem/chains'
import Image from 'next/image'
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"
import { Input } from "@/components/ui/input"
import { Button } from "@/components/ui/button"
import { Flame, ExternalLink } from 'lucide-react'
import type { ButtonContext, TokenType } from '../types'
import { handleAmountChange } from '../utils/input'
import { formatBalance } from '../utils/formatting'
import { useOperations } from '../hooks/useOperations'

interface BurnModalProps {
  isOpen: boolean
  onClose: () => void
  tokenSymbol: string
  tokenName?: string
  imageUrl?: string
  tokenType?: TokenType
  context: ButtonContext
  contractAddress: string
  tokenId?: string
  tbaAddress?: string
  pricePerToken?: bigint
  primaryMintActive?: boolean
  onRefreshBalance?: () => void
}

export function BurnModal({
  isOpen,
  onClose,
  tokenSymbol,
  tokenName,
  imageUrl = '/assets/no-image-found.png',
  tokenType = 'erc20',
  context,
  contractAddress,
  tokenId,
  tbaAddress,
  pricePerToken,
  primaryMintActive = false,
  onRefreshBalance
}: BurnModalProps) {
  const { authenticated, user, login } = usePrivy()
  
  // Token balance state
  const [tokenBalance, setTokenBalance] = useState<bigint>(BigInt(0))
  const [targetTokenDecimals, setTargetTokenDecimals] = useState<number>(18)
  
  // Create public client
  const publicClient = createPublicClient({
    chain: base,
    transport: http()
  })

  const {
    isBurning: isLoading,
    executeBurn
  } = useOperations({
    context,
    contractAddress,
    tokenId,
    tokenType,
    tbaAddress,
    pricePerToken,
    primaryMintActive,
    tokenDecimals: targetTokenDecimals
  })
  const [localAmount, setLocalAmount] = useState('')
  const [localFormattedAmount, setLocalFormattedAmount] = useState('')
  const [amountError, setAmountError] = useState('')

  // Helper function to get appropriate display name based on token type
  const getDisplayName = () => {
    if (tokenType === 'erc721' || tokenType === 'erc1155') {
      return tokenName || tokenSymbol
    }
    return tokenSymbol
  }

  // Fetch target token decimals using viem (like send.tsx and buy.tsx)
  const fetchTargetTokenDecimals = async () => {
    if ((tokenType as string) === 'erc1155') {
      setTargetTokenDecimals(0) // ERC1155 tokens don't have decimals
      return
    }

    if ((tokenType as string) === 'native') {
      setTargetTokenDecimals(18) // ETH has 18 decimals
      return
    }

    try {
      const decimals = await publicClient.readContract({
        address: contractAddress as Address,
        abi: [
          {
            inputs: [],
            name: 'decimals',
            outputs: [{ type: 'uint8' }],
            stateMutability: 'view',
            type: 'function'
          }
        ],
        functionName: 'decimals'
      })
      setTargetTokenDecimals(Number(decimals))
    } catch (error) {
      console.error('Error fetching target token decimals:', error)
      setTargetTokenDecimals(18) // Default fallback
    }
  }

  // Handle amount input changes
  const handleInputChange = (value: string) => {
    const maxDecimals = tokenType === 'erc721' ? 0 : tokenType === 'erc1155' ? 0 : targetTokenDecimals
    const result = handleAmountChange(value, tokenType, maxDecimals)
    
    setLocalAmount(result.cleanValue)
    setLocalFormattedAmount(result.formattedValue)
    
    // Validate amount against balance
    if (result.cleanValue && tokenBalance) {
      try {
        let inputAmount: bigint
        let currentBalance = tokenBalance
        
        if (tokenType === 'erc721') {
          inputAmount = BigInt(1)
        } else if (tokenType === 'erc1155') {
          inputAmount = BigInt(Math.floor(Number(result.cleanValue)))
        } else {
          // For ERC20/native tokens, convert using actual decimals
          const numericValue = Number(result.cleanValue)
          const decimals = targetTokenDecimals || 18 // Fallback to 18 if not set yet
          
          // Check if we have valid numbers before BigInt conversion
          if (isNaN(numericValue) || isNaN(decimals)) {
            setAmountError('Invalid amount')
            return
          }
          
          const scaledAmount = numericValue * Math.pow(10, decimals)
          
          // Check if the scaled amount is a valid number
          if (isNaN(scaledAmount) || !isFinite(scaledAmount)) {
            setAmountError('Amount too large')
            return
          }
          
          inputAmount = BigInt(Math.floor(scaledAmount))
        }
        
        if (inputAmount > currentBalance) {
          setAmountError('Amount exceeds available balance')
        } else {
          setAmountError('')
        }
      } catch (error) {
        setAmountError('Invalid amount')
      }
    } else {
      setAmountError('')
    }
  }

  // Fetch token balance
  const fetchTokenBalance = async () => {
    if (!user?.wallet?.address) return
    
    const addressToQuery = context === 'tokenbound' && tbaAddress ? tbaAddress : user.wallet.address

    try {
      if ((tokenType as string) === 'erc1155') {
        const balance = await publicClient.readContract({
          address: contractAddress as Address,
          abi: [
            {
              inputs: [
                { name: 'account', type: 'address' },
                { name: 'id', type: 'uint256' }
              ],
              name: 'balanceOf',
              outputs: [{ type: 'uint256' }],
              stateMutability: 'view',
              type: 'function'
            }
          ],
          functionName: 'balanceOf',
          args: [addressToQuery as Address, BigInt(tokenId || '0')]
        })
        setTokenBalance(balance as bigint)
      } else if ((tokenType as string) === 'native') {
        const balance = await publicClient.getBalance({
          address: addressToQuery as Address
        })
        setTokenBalance(balance)
      } else if ((tokenType as string) === 'erc20' || (tokenType as string) === 'erc721') {
        const balance = await publicClient.readContract({
          address: contractAddress as Address,
          abi: [
            {
              inputs: [{ name: 'account', type: 'address' }],
              name: 'balanceOf',
              outputs: [{ type: 'uint256' }],
              stateMutability: 'view',
              type: 'function'
            }
          ],
          functionName: 'balanceOf',
          args: [addressToQuery as Address]
        })
        setTokenBalance(balance as bigint)
      }
    } catch (error) {
      console.error('Error fetching token balance:', error)
      setTokenBalance(BigInt(0))
    }
  }

  // Reset form and load data when modal opens
  useEffect(() => {
    if (isOpen) {
      setLocalAmount('')
      setLocalFormattedAmount('')
      setAmountError('')
      
      if (authenticated) {
        fetchTokenBalance()
        fetchTargetTokenDecimals()
      }
    }
  }, [isOpen, authenticated])

  const handleExecute = async () => {
    if (!authenticated) {
      login()
      return
    }

    if (!localAmount && tokenType !== 'erc721') return
    
    const burnAmount = tokenType === 'erc721' ? '1' : localAmount
    
    try {
      await executeBurn(burnAmount)
      
      // Refresh balance and close modal
      onRefreshBalance?.()
      onClose()
    } catch (error) {
      console.error('Burn execution error:', error)
    }
  }

  const getDisplayAmount = () => {
    if (tokenType === 'erc721') return '1'
    return localFormattedAmount || '0'
  }

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-[500px] bg-black/95 border border-gray-800 shadow-xl backdrop-blur-xl">
        <DialogHeader className="border-b border-gray-800 pb-4">
          <div className="flex items-center justify-between">
            <div className="flex flex-col gap-2">
              <DialogTitle className="text-xl font-bold text-white">
                burn
              </DialogTitle>
              <div className="text-3xl font-bold text-white">
                {getDisplayName()}
              </div>
            </div>
            <div className="relative w-20 h-20 rounded-lg overflow-hidden">
              <Image
                src={imageUrl}
                alt={tokenSymbol}
                fill
                className="object-cover"
              />
            </div>
          </div>
        </DialogHeader>

        <div className="py-6 space-y-6">
          {!authenticated ? (
            /* Not Connected - Show Connect Account */
            <div className="space-y-6 text-center">
              <div className="space-y-4">
                <div className="w-16 h-16 mx-auto bg-orange-500/10 rounded-full flex items-center justify-center">
                  <Flame className="w-8 h-8 text-orange-500" />
                </div>
                <div className="text-xl font-semibold text-white">
                  connect to burn
                </div>
              </div>
            </div>
          ) : tokenBalance === BigInt(0) ? (
            // Show guidance when no balance
            <div className="space-y-6 text-center">
              <div className="text-lg text-gray-300">
                buy to burn
              </div>
              <p className="text-sm text-gray-400">
                You need {getDisplayName()} tokens to burn them
              </p>
            </div>
          ) : (
            <div className="space-y-6">
              {/* Amount Input (hide for ERC721) */}
              {tokenType !== 'erc721' && (
                <div className="space-y-3">
                  <label className="text-sm font-medium text-gray-300">
                    quantity to burn
                  </label>
                  <Input
                    type="text"
                    value={localFormattedAmount}
                    onChange={(e) => handleInputChange(e.target.value)}
                    placeholder="enter amount"
                    className={`bg-gray-900/50 border-gray-800 text-white placeholder:text-gray-500 h-12 text-lg font-medium ${
                      amountError ? 'border-red-500' : ''
                    }`}
                  />
                  {amountError && (
                    <div className="text-sm text-red-500">
                      {amountError}
                    </div>
                  )}
                  <div className="text-sm text-gray-400">
                    balance: {formatBalance(tokenBalance.toString(), tokenType, targetTokenDecimals)} {getDisplayName()}
                  </div>
                </div>
              )}

              {/* Burn Summary */}
              {(localAmount || tokenType === 'erc721') && (
                <div className="mt-4 p-4 bg-gray-900/50 rounded-lg border border-gray-800">
                  <div className="flex justify-between items-center mb-2">
                    <span className="text-gray-400">You will burn:</span>
                    <span className="text-white">
                      {getDisplayAmount()} {getDisplayName()}
                    </span>
                  </div>
                  
                  <div className="text-sm text-gray-400 flex items-start gap-2 mt-3 p-3 bg-orange-500/10 rounded border border-orange-500/20">
                    <Flame className="w-4 h-4 text-orange-500 mt-0.5 flex-shrink-0" />
                    <div>
                      <div className="text-orange-200 font-medium">Perpetual Funding</div>
                      <div className="text-orange-300/80 text-xs mt-1">
                        Burning permanently removes assets from circulation. 
                        This reduces total supply, making remaining assets more scarce and protecting their value.
                        {(context === 'specific' || (context === 'tokenbound' && tokenType === 'erc1155') || (context === 'operator' && tokenType === 'erc1155')) && (
                          <>
                            {' '}Burning in this context creates{' '}
                            <a 
                              href="https://ensurance.app/proceeds/0xa187F8CBdd36D63967c33f5BD4dD4B9ECA51270e" 
                              target="_blank" 
                              rel="noopener noreferrer"
                              className="text-orange-400 hover:text-orange-300 inline-flex items-center gap-1"
                            >
                              ensurance proceeds
                              <ExternalLink className="w-3 h-3" />
                            </a>
                          </>
                        )}
                      </div>
                    </div>
                  </div>
                </div>
              )}
            </div>
          )}
        </div>

        {/* Action Buttons */}
        <div className="flex justify-end gap-3 pt-6 border-t border-gray-800">
          <Button 
            variant="ghost" 
            onClick={onClose}
            className="text-gray-400 hover:text-gray-300"
          >
            Cancel
          </Button>
          <Button
            onClick={handleExecute}
            disabled={
              authenticated && (
                isLoading || 
                tokenBalance === BigInt(0) ||
                (tokenType !== 'erc721' && (!localAmount || Number(localAmount) <= 0)) ||
                !!amountError
              )
            }
            className="min-w-[120px] bg-orange-600 hover:bg-orange-500"
          >
            {isLoading ? (
              <div className="flex items-center gap-2">
                <div className="w-4 h-4 border-2 border-white/30 border-t-white rounded-full animate-spin" />
                <span>Processing...</span>
              </div>
            ) : authenticated ? (
              'BURN'
            ) : (
              'CONNECT'
            )}
          </Button>
        </div>
      </DialogContent>
    </Dialog>
  )
}
````

## File: src/modules/ensure/buttons/modals/buy.tsx
````typescript
'use client'

import { useState, useEffect } from 'react'
import { useDebounce } from '@/hooks/useDebounce'
import { usePrivy } from '@privy-io/react-auth'
import { createPublicClient, http, type Address } from 'viem'
import { base } from 'viem/chains'
import Image from 'next/image'
import { PlusCircle } from 'lucide-react'
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"
import { Input } from "@/components/ui/input"
import { Button } from "@/components/ui/button"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import type { TokenInfo, ButtonContext, TokenType } from '../types'
import { handleAmountChange } from '../utils/input'
import { formatNumber, getTokenDecimals } from '../utils/formatting'
import { useOperations } from '../hooks/useOperations'

interface BuyModalProps {
  isOpen: boolean
  onClose: () => void
  tokenSymbol: string
  tokenName?: string
  imageUrl?: string
  context: ButtonContext
  tokenType?: TokenType
  contractAddress: string
  tokenId?: string
  tbaAddress?: string
  pricePerToken?: bigint
  primaryMintActive?: boolean
  onRefreshBalance?: () => void
}

export function BuyModal({
  isOpen,
  onClose,
  tokenSymbol,
  tokenName,
  imageUrl = '/assets/no-image-found.png',
  context,
  tokenType = 'erc20',
  contractAddress,
  tokenId,
  tbaAddress,
  pricePerToken,
  primaryMintActive = false,
  onRefreshBalance
}: BuyModalProps) {
  const { authenticated, user, login } = usePrivy()
  
  // Modal state
  const [localAmount, setLocalAmount] = useState('')
  const [localFormattedAmount, setLocalFormattedAmount] = useState('')
  const [localAmountError, setLocalAmountError] = useState('')
  const [selectedToken, setSelectedToken] = useState<TokenInfo | null>(null)
  
  // Trading state
  const [availableTokens, setAvailableTokens] = useState<TokenInfo[]>([])
  const [isLoadingTokens, setIsLoadingTokens] = useState(false)
  const [estimatedOutput, setEstimatedOutput] = useState('0')
  const [isSimulating, setIsSimulating] = useState(false)
  const [usdcBalance, setUsdcBalance] = useState<bigint>(BigInt(0))
  const [tokenImages, setTokenImages] = useState<Record<string, string>>({})
  const [targetTokenDecimals, setTargetTokenDecimals] = useState<number>(18)
  
  // Debounce amount for quote fetching
  const debouncedAmount = useDebounce(localAmount, 500)
  
  // Create public client
  const publicClient = createPublicClient({
    chain: base,
    transport: http()
  })

  const {
    isLoading,
    executeBuy
  } = useOperations({
    context,
    contractAddress,
    tokenId,
    tokenType,
    tbaAddress,
    pricePerToken,
    primaryMintActive
  })

  // Fetch available tokens for trading
  const fetchAvailableTokens = async () => {
    if (!authenticated || !user?.wallet?.address) return

    setIsLoadingTokens(true)
    try {
      const addressToQuery = context === 'tokenbound' && tbaAddress ? tbaAddress : user.wallet.address
      
      // Get supported tokens and user balances
      const [currenciesRes, certificatesRes, alchemyRes] = await Promise.all([
        fetch('/api/currencies'),
        fetch('/api/general'),
        fetch(`/api/alchemy/fungible?address=${addressToQuery}`)
      ])

      if (!currenciesRes.ok || !certificatesRes.ok || !alchemyRes.ok) {
        throw new Error('Failed to fetch supported tokens')
      }

      const [currencies, certificates, alchemyData] = await Promise.all([
        currenciesRes.json(),
        certificatesRes.json(),
        alchemyRes.json()
      ])

      // Create a map of supported token addresses
      const supportedTokens = new Set([
        ...currencies.map((c: any) => c.address.toLowerCase()),
        ...certificates.map((c: any) => c.contract_address.toLowerCase())
      ])

      // Filter and map tokens
      const tokens: TokenInfo[] = alchemyData.data.tokens
        .filter((t: any) => {
          // Handle ETH case
          if (!t.tokenAddress) {
            const ethPlaceholder = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE'
            return contractAddress.toLowerCase() !== ethPlaceholder.toLowerCase()
          }
          // For other tokens: must be supported and not the destination token
          return supportedTokens.has(t.tokenAddress.toLowerCase()) &&
                 t.tokenAddress.toLowerCase() !== contractAddress.toLowerCase()
        })
        .map((t: any): TokenInfo | null => {
          // Handle native ETH
          if (!t.tokenAddress) {
            return {
              symbol: 'ETH',
              address: '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE' as Address,
              decimals: 18,
              balance: t.tokenBalance,
              type: 'native'
            }
          }
          // Handle other tokens
          if (t.tokenMetadata?.decimals != null && t.tokenMetadata?.symbol) {
            const isCurrency = currencies.some((c: any) => 
              c.address.toLowerCase() === t.tokenAddress.toLowerCase()
            )
            return {
              symbol: t.tokenMetadata.symbol,
              address: t.tokenAddress as Address,
              decimals: t.tokenMetadata.decimals,
              balance: t.tokenBalance,
              type: isCurrency ? 'currency' : 'certificate'
            }
          }
          return null
        })
        .filter((t: TokenInfo | null): t is TokenInfo => t !== null)
        .sort((a: TokenInfo, b: TokenInfo) => {
          // ETH first, then by type, then by balance
          const ETH_ADDRESS = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE'.toLowerCase()
          if (a.address.toLowerCase() === ETH_ADDRESS) return -1
          if (b.address.toLowerCase() === ETH_ADDRESS) return 1

          if (a.type !== b.type) {
            if (a.type === 'currency') return -1
            if (b.type === 'currency') return 1
          }

          const balanceA = Number(a.balance) / Math.pow(10, a.decimals)
          const balanceB = Number(b.balance) / Math.pow(10, b.decimals)
          return balanceB - balanceA
        })

      setAvailableTokens(tokens)
      
      // Fetch images for the tokens
      if (tokens.length > 0) {
        fetchTokenImages(tokens)
      }
    } catch (error) {
      console.error('Error fetching tokens:', error)
    } finally {
      setIsLoadingTokens(false)
    }
  }

  // Fetch USDC balance for ERC1155 tokens
  const fetchUsdcBalance = async () => {
    if (!user?.wallet?.address || (tokenType as string) !== 'erc1155') return
    
    const addressToQuery = context === 'tokenbound' && tbaAddress ? tbaAddress : user.wallet.address
    
    try {
      const balance = await publicClient.readContract({
        address: '0x833589fcd6edb6e08f4c7c32d4f71b54bda02913' as Address,
        abi: [
          {
            inputs: [{ name: 'account', type: 'address' }],
            name: 'balanceOf',
            outputs: [{ type: 'uint256' }],
            stateMutability: 'view',
            type: 'function'
          }
        ],
        functionName: 'balanceOf',
        args: [addressToQuery as Address]
      })
      setUsdcBalance(balance as bigint)
    } catch (error) {
      console.error('Error fetching USDC balance:', error)
      setUsdcBalance(BigInt(0))
    }
  }

  // Fetch token images
  const fetchTokenImages = async (tokens: TokenInfo[]) => {
    const imagePromises = tokens.map(async (token) => {
      try {
        const response = await fetch(`/api/utilities/image?address=${token.address}`)
        if (response.ok) {
          const data = await response.json()
          return { address: token.address, url: data.url }
        }
      } catch (error) {
        console.error(`Error fetching image for ${token.address}:`, error)
      }
      return { address: token.address, url: null }
    })

    const results = await Promise.all(imagePromises)
    const imageMap: Record<string, string> = {}
    
    results.forEach(({ address, url }) => {
      if (url) {
        imageMap[address] = url
      }
    })
    
    setTokenImages(imageMap)
  }

  // Fetch target token decimals using viem
  const fetchTargetTokenDecimals = async () => {
    if ((tokenType as string) === 'erc1155') {
      setTargetTokenDecimals(0) // ERC1155 tokens don't have decimals
      return
    }

    try {
      const decimals = await publicClient.readContract({
        address: contractAddress as Address,
        abi: [
          {
            inputs: [],
            name: 'decimals',
            outputs: [{ type: 'uint8' }],
            stateMutability: 'view',
            type: 'function'
          }
        ],
        functionName: 'decimals'
      })
      setTargetTokenDecimals(Number(decimals))
    } catch (error) {
      console.error('Error fetching target token decimals:', error)
      setTargetTokenDecimals(18) // Default fallback
    }
  }

  // Get price quote from 0x API
  const fetchQuote = async (
    sellToken: string,
    buyToken: string, 
    sellAmount: string
  ) => {
    if (!user?.wallet?.address || !sellAmount || Number(sellAmount) <= 0) {
      setEstimatedOutput('0')
      return
    }

    const takerAddress = context === 'tokenbound' && tbaAddress ? tbaAddress : user.wallet.address

    setIsSimulating(true)
    try {
      const params = new URLSearchParams({
        action: 'quote',
        sellToken,
        buyToken,
        sellAmount,
        taker: takerAddress,
        slippageBps: '200',
        swapFeeBps: '100'
      })

      const response = await fetch(`/api/0x?${params}`)
      if (!response.ok) {
        setEstimatedOutput('0')
        return
      }
      
      const data = await response.json()
      
      if (!data.liquidityAvailable || !data.buyAmount) {
        setEstimatedOutput('0')
        return
      }
      
      const amount = Number(data.buyAmount) / Math.pow(10, targetTokenDecimals)
      const formattedAmount = formatNumber(amount, targetTokenDecimals)
      setEstimatedOutput(formattedAmount)
    } catch (error) {
      console.error('Error getting quote:', error)
      setEstimatedOutput('0')
    } finally {
      setIsSimulating(false)
    }
  }

  // Helper functions
  const getDisplayName = () => {
    return tokenName || tokenSymbol
  }

  const getImageUrl = () => {
    return imageUrl
  }

  const isButtonDisabled = () => {
    if (isLoading || !localAmount || Number(localAmount) <= 0) return true
    
    if ((tokenType as string) === 'erc1155') {
      return !!localAmountError
    }
    
    if (!selectedToken) return true
    return !!localAmountError
  }

  // Handle amount input changes
  const handleInputChange = (value: string) => {
    // For ERC1155 tokens, only allow whole numbers
    if ((tokenType as string) === 'erc1155') {
      // Remove any non-digit characters and ensure it's a whole number
      const wholeNumberValue = value.replace(/[^\d]/g, '')
      setLocalAmount(wholeNumberValue)
      setLocalFormattedAmount(wholeNumberValue)
      
      // Validate against USDC balance
      if (wholeNumberValue && pricePerToken && usdcBalance) {
        const quantity = BigInt(Math.floor(Number(wholeNumberValue)))
        const totalCost = quantity * pricePerToken
        
        if (totalCost > usdcBalance) {
          setLocalAmountError('Insufficient USDC balance')
        } else {
          setLocalAmountError('')
        }
      } else {
        setLocalAmountError('')
      }
      return
    }
    
    // For other token types, use existing logic
    const maxDecimals = selectedToken ? getTokenDecimals(selectedToken.symbol, selectedToken.decimals) : 18
    const inputTokenType = selectedToken?.type === 'native' ? 'native' : 'erc20'
    const result = handleAmountChange(value, inputTokenType, maxDecimals)
    
    setLocalAmount(result.cleanValue)
    setLocalFormattedAmount(result.formattedValue)

    // Validate based on token type
    if ((tokenType as string) === 'erc1155') {
      // For ERC1155 tokens, validate against USDC balance
      if (result.cleanValue && pricePerToken && usdcBalance) {
        const quantity = BigInt(Math.floor(Number(result.cleanValue)))
        const totalCost = quantity * pricePerToken
        
        if (totalCost > usdcBalance) {
          setLocalAmountError('Insufficient USDC balance')
        } else {
          setLocalAmountError('')
        }
      } else {
        setLocalAmountError('')
      }
    } else {
      // For ERC20/native tokens, validate against selected token balance
      if (result.cleanValue && selectedToken?.balance) {
        const inputAmount = Number(result.cleanValue)
        const availableBalance = Number(selectedToken.balance) / Math.pow(10, selectedToken.decimals)
        
        if (inputAmount > availableBalance) {
          setLocalAmountError(`Insufficient ${selectedToken.symbol} balance`)
        } else {
          setLocalAmountError('')
        }
      } else {
        setLocalAmountError('')
      }
    }
  }

  // Reset and load data when modal opens
  useEffect(() => {
    if (isOpen) {
      setLocalAmount('')
      setLocalFormattedAmount('')
      setLocalAmountError('')
      setSelectedToken(null)
      setEstimatedOutput('0')
      
      // Always fetch target token decimals
      fetchTargetTokenDecimals()
      
      if (authenticated) {
        fetchAvailableTokens()
        fetchUsdcBalance()
      }
    }
  }, [isOpen, authenticated])

  // Set initial selected token when available tokens load
  useEffect(() => {
    if (availableTokens.length > 0 && !selectedToken) {
      const ethToken = availableTokens.find(t => t.type === 'native')
      if (ethToken) {
        setSelectedToken(ethToken)
      }
    }
  }, [availableTokens, selectedToken])

  // Clear estimate immediately when user starts typing (prevents stale estimates)
  useEffect(() => {
    if (localAmount !== debouncedAmount && (tokenType as string) !== 'erc1155') {
      setEstimatedOutput('0')
    }
  }, [localAmount, debouncedAmount, tokenType])

  // Fetch quote when debounced amount changes
  useEffect(() => {
    if (selectedToken && debouncedAmount && (tokenType as string) !== 'erc1155') {
      const sellAmount = (Number(debouncedAmount) * Math.pow(10, selectedToken.decimals)).toString()
      fetchQuote(selectedToken.address, contractAddress, sellAmount)
    }
  }, [debouncedAmount, selectedToken, contractAddress, tokenType])

  const handleExecute = async () => {
    if (!authenticated) {
      login()
      return
    }

    try {
      if ((tokenType as string) === 'erc1155') {
        await executeBuy(localAmount)
      } else {
        if (!selectedToken) return
        await executeBuy(localAmount, selectedToken)
      }
      
      // Refresh balance and close modal
      onRefreshBalance?.()
      onClose()
    } catch (error) {
      console.error('Buy execution error:', error)
    }
  }

  return (
    <Dialog 
      open={isOpen} 
      onOpenChange={onClose}
      modal={true}
    >
      <DialogContent 
        className="sm:max-w-[500px] bg-black/95 border border-gray-800 shadow-xl backdrop-blur-xl z-[9999] fixed"
        onClick={(e) => {
          e.stopPropagation()
        }}
        onMouseDown={(e) => {
          e.stopPropagation()
        }}
        onKeyDown={(e) => e.stopPropagation()}
        onPointerDown={(e) => e.stopPropagation()}
      >
        <DialogHeader className="border-b border-gray-800 pb-4">
          <div className="flex items-center justify-between">
            <div className="flex flex-col gap-2">
              <DialogTitle className="text-xl font-bold text-white">
                ensure
              </DialogTitle>
              <div className="text-3xl font-bold text-white">
                {getDisplayName()}
              </div>
            </div>
            <div className="relative w-20 h-20 rounded-lg overflow-hidden">
              <Image
                src={getImageUrl()}
                alt={getDisplayName()}
                fill
                className="object-cover"
              />
            </div>
          </div>
        </DialogHeader>

        <div className="py-6 space-y-6">
          {!authenticated ? (
            /* Not Connected - Show Connect Account */
            <div className="space-y-6 text-center">
              <div className="space-y-4">
                <div className="w-16 h-16 mx-auto bg-green-500/10 rounded-full flex items-center justify-center">
                  <PlusCircle className="w-8 h-8 text-green-500" />
                </div>
                <div className="text-xl font-semibold text-white">
                  connect to ensure
                </div>
              </div>
            </div>
          ) : (
            /* Authenticated - Show Buy Form */
            <div className="space-y-4">
              {/* ERC1155: Show USDC payment info */}
              {(tokenType as string) === 'erc1155' ? (
              <div className="space-y-2">
                <label className="text-sm font-medium text-gray-300">
                  PAY WITH USDC
                </label>
                <div className="bg-gray-900/50 border border-gray-800 rounded-lg p-4">
                  <div className="flex items-center gap-3 mb-3">
                    <div className="w-8 h-8 rounded-full bg-blue-500 flex items-center justify-center">
                      <span className="text-sm font-bold text-white">$</span>
                    </div>
                    <div className="flex items-baseline gap-2">
                      <div className="text-2xl font-bold text-white">
                        {pricePerToken ? (Number(pricePerToken) / 1_000_000).toFixed(2) : '0.00'}
                      </div>
                      <div className="text-sm text-gray-400">USDC per certificate</div>
                    </div>
                  </div>
                  
                  <div className="pt-2 border-t border-gray-700">
                    <div className="text-sm text-gray-400">
                      Your balance: {formatNumber(Number(usdcBalance) / 1_000_000, 2)} USDC
                      {(!usdcBalance || Number(usdcBalance) === 0) && (
                        <div className="text-xs text-amber-400 mt-1">
                          💡 You need USDC on Base network to purchase certificates
                        </div>
                      )}
                    </div>
                  </div>
                </div>
              </div>
            ) : (
              /* ERC20/Native: Token Selection */
              <div className="space-y-2">
                <label className="text-sm font-medium text-gray-300">
                  PAY WITH
                </label>
                <Select
                  value={selectedToken?.address}
                  onValueChange={(value) => {
                    const token = availableTokens.find(t => t.address === value)
                    if (token) setSelectedToken(token)
                  }}
                >
                  <SelectTrigger className="bg-gray-900/50 border-gray-800 text-white h-12 text-lg font-medium">
                    <SelectValue placeholder="Select token" />
                  </SelectTrigger>
                  <SelectContent className="bg-gray-900 border-gray-800 z-[10000]">
                    {isLoadingTokens ? (
                      <div className="flex items-center justify-center p-4">
                        <div className="w-5 h-5 border-2 border-gray-400 border-t-transparent rounded-full animate-spin" />
                      </div>
                    ) : (
                      availableTokens.map((token) => (
                        <SelectItem
                          key={token.address}
                          value={token.address}
                          className="text-white hover:bg-gray-800 focus:bg-gray-800"
                        >
                          <div className="flex items-center gap-2">
                            <div className="w-6 h-6 rounded-full overflow-hidden bg-gray-800 flex items-center justify-center">
                              {tokenImages[token.address] ? (
                                <Image
                                  src={tokenImages[token.address]}
                                  alt={token.symbol}
                                  width={24}
                                  height={24}
                                  className="object-cover"
                                />
                              ) : (
                                <div className="w-6 h-6 bg-gray-700 rounded-full" />
                              )}
                            </div>
                            <div className="flex flex-col">
                              <span className="font-medium">{token.symbol}</span>
                              {token.balance && (
                                <span className="text-xs text-gray-400">
                                  Balance: {formatNumber(Number(token.balance) / Math.pow(10, token.decimals), token.decimals)}
                                </span>
                              )}
                            </div>
                          </div>
                        </SelectItem>
                      ))
                    )}
                  </SelectContent>
                </Select>
              </div>
            )}

            {/* Amount Input */}
            {(((tokenType as string) === 'erc1155') || selectedToken) && (
              <div className="space-y-2">
                <label className="text-sm font-medium text-gray-300">
                  {(tokenType as string) === 'erc1155' ? 
                    'certificates to purchase' : 
                    `spend ${selectedToken?.symbol}`
                  }
                </label>
                <Input
                  type="text"
                  value={localFormattedAmount}
                  onChange={(e) => handleInputChange(e.target.value)}
                  placeholder={(tokenType as string) === 'erc1155' ? 
                    'enter certificate quantity' : 
                    `enter ${selectedToken?.symbol} amount`
                  }
                  className={`bg-gray-900/50 border-gray-800 text-white placeholder:text-gray-500 h-12 text-lg font-medium ${
                    localAmountError ? 'border-red-500' : ''
                  }`}
                />
                {localAmountError && (
                  <div className="text-sm text-red-500">
                    {localAmountError}
                  </div>
                )}
              </div>
            )}

            {/* Output Display */}
            {(((tokenType as string) === 'erc1155') ? localAmount : (selectedToken && localAmount)) && (
              <div className="space-y-2">
                <label className="text-sm font-medium text-gray-300">
                  {(tokenType as string) === 'erc1155' ? 'TOTAL COST' : 'ESTIMATED OUTPUT'}
                </label>
                <div className="bg-gray-900/50 border border-gray-800 rounded-lg p-4">
                  <div className="flex items-center justify-between">
                    <div className="flex items-center gap-2">
                      <div className="w-6 h-6 rounded-full overflow-hidden bg-gray-800 flex items-center justify-center">
                        {(tokenType as string) === 'erc1155' ? (
                          <div className="w-6 h-6 rounded-full bg-blue-500 flex items-center justify-center">
                            <span className="text-xs font-bold text-white">$</span>
                          </div>
                        ) : (
                          <Image
                            src={getImageUrl()}
                            alt={getDisplayName()}
                            width={24}
                            height={24}
                            className="object-cover"
                          />
                        )}
                      </div>
                      <span className="text-lg font-medium">
                        {(tokenType as string) === 'erc1155' ? (
                          pricePerToken && localAmount ? 
                            `$${(Number(BigInt(Math.floor(Number(localAmount))) * pricePerToken) / 1_000_000).toFixed(2)}` : 
                            '$0.00'
                        ) : (
                          isSimulating ? (
                            <div className="w-5 h-5 border-2 border-gray-400 border-t-transparent rounded-full animate-spin" />
                          ) : (
                            estimatedOutput
                          )
                        )}
                      </span>
                    </div>
                    <span className="text-gray-400">
                      {(tokenType as string) === 'erc1155' ? '' : getDisplayName()}
                    </span>
                  </div>
                </div>
              </div>
            )}
          </div>
        )}
        </div>

        {/* Action Buttons */}
        <div className="flex justify-end gap-3 pt-6 border-t border-gray-800">
          <Button 
            variant="ghost" 
            onClick={onClose}
            className="text-gray-400 hover:text-gray-300"
          >
            Cancel
          </Button>
          <Button
            onClick={handleExecute}
            disabled={authenticated && isButtonDisabled()}
            className="min-w-[120px] bg-green-600 hover:bg-green-500"
          >
            {isLoading ? (
              <div className="flex items-center gap-2">
                <div className="w-4 h-4 border-2 border-white/30 border-t-white rounded-full animate-spin" />
                <span>Processing...</span>
              </div>
            ) : authenticated ? (
              'ENSURE'
            ) : (
              'CONNECT'
            )}
          </Button>
        </div>
      </DialogContent>
    </Dialog>
  )
}
````

## File: src/modules/ensure/buttons/modals/send.tsx
````typescript
'use client'

import { useState, useEffect } from 'react'
import { useDebounce } from '@/hooks/useDebounce'
import { usePrivy } from '@privy-io/react-auth'
import { createPublicClient, http, type Address } from 'viem'
import { base } from 'viem/chains'
import Image from 'next/image'
import { Send } from 'lucide-react'
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"
import { Input } from "@/components/ui/input"
import { Button } from "@/components/ui/button"
import AccountImage from '@/modules/accounts/AccountImage'
import type { ButtonContext, TokenType, AccountSearchResult } from '../types'
import { handleAmountChange, truncateAddress } from '../utils/input'
import { formatBalance, getTokenDecimals } from '../utils/formatting'
import { useOperations } from '../hooks/useOperations'

interface SendModalProps {
  isOpen: boolean
  onClose: () => void
  tokenSymbol: string
  tokenName?: string
  imageUrl?: string
  context: ButtonContext
  tokenType?: TokenType
  contractAddress: string
  tokenId?: string
  tbaAddress?: string
  onRefreshBalance?: () => void
}

export function SendModal({
  isOpen,
  onClose,
  tokenSymbol,
  tokenName,
  imageUrl = '/assets/no-image-found.png',
  context,
  tokenType = 'erc20',
  contractAddress,
  tokenId,
  tbaAddress,
  onRefreshBalance
}: SendModalProps) {
  const { authenticated, user, login } = usePrivy()
  
  // Modal state
  const [localAmount, setLocalAmount] = useState('')
  const [localFormattedAmount, setLocalFormattedAmount] = useState('')
  const [localAmountError, setLocalAmountError] = useState('')
  
  // Account search state
  const [accountSearchQuery, setAccountSearchQuery] = useState('')
  const [allAccounts, setAllAccounts] = useState<AccountSearchResult[]>([])
  const [filteredAccounts, setFilteredAccounts] = useState<AccountSearchResult[]>([])
  const [isLoadingAccounts, setIsLoadingAccounts] = useState(false)
  const [selectedAccount, setSelectedAccount] = useState<AccountSearchResult | null>(null)
  const [recipientAddress, setRecipientAddress] = useState('')
  
  // Keyboard navigation state
  const [selectedIndex, setSelectedIndex] = useState(-1)
  
  // Token balance and decimals state
  const [tokenBalance, setTokenBalance] = useState<bigint>(BigInt(0))
  const [targetTokenDecimals, setTargetTokenDecimals] = useState<number>(18)
  
  // Debounce search query
  const debouncedSearchQuery = useDebounce(accountSearchQuery, 300)
  
  // Create public client
  const publicClient = createPublicClient({
    chain: base,
    transport: http()
  })

  const {
    isLoading,
    executeSend
  } = useOperations({
    context,
    contractAddress,
    tokenId,
    tokenType,
    tbaAddress,
    pricePerToken: undefined,
    primaryMintActive: false,
    tokenDecimals: targetTokenDecimals
  })

  // Fetch target token decimals using viem (like buy.tsx)
  const fetchTargetTokenDecimals = async () => {
    if ((tokenType as string) === 'erc1155') {
      setTargetTokenDecimals(0) // ERC1155 tokens don't have decimals
      return
    }

    if ((tokenType as string) === 'native') {
      setTargetTokenDecimals(18) // ETH has 18 decimals
      return
    }

    try {
      const decimals = await publicClient.readContract({
        address: contractAddress as Address,
        abi: [
          {
            inputs: [],
            name: 'decimals',
            outputs: [{ type: 'uint8' }],
            stateMutability: 'view',
            type: 'function'
          }
        ],
        functionName: 'decimals'
      })
      setTargetTokenDecimals(Number(decimals))
    } catch (error) {
      console.error('Error fetching target token decimals:', error)
      setTargetTokenDecimals(18) // Default fallback
    }
  }

  // Fetch all accounts (like AccountsGrid does)
  const fetchAllAccounts = async () => {
    setIsLoadingAccounts(true)
    try {
      const response = await fetch('/api/accounts')
      if (!response.ok) throw new Error('Failed to fetch accounts')
      const accountsData = await response.json()
      
      // Transform to match AccountSearchResult interface
      const transformedAccounts: AccountSearchResult[] = accountsData.map((account: any) => ({
        full_account_name: account.full_account_name,
        token_id: account.token_id,
        is_agent: account.is_agent,
        group_name: account.group_name,
        tba_address: account.tba_address,
        name: account.full_account_name, // For display compatibility
        type: 'account' as const,
        path: `/${account.full_account_name}`
      }))

      // Add operator as special recipient if in tokenbound context
      const recipients: AccountSearchResult[] = []
      
      if (context === 'tokenbound' && user?.wallet?.address) {
        recipients.push({
          full_account_name: 'operator.wallet',
          token_id: 0,
          is_agent: false,
          group_name: 'system',
          tba_address: user.wallet.address, // Use wallet address directly
          name: 'OPERATOR (connected wallet)',
          type: 'operator' as const,
          path: '/operator'
        })
      }
      
      // Add all other accounts
      recipients.push(...transformedAccounts)
      
      setAllAccounts(recipients)
    } catch (error) {
      console.error('Error fetching accounts:', error)
      setAllAccounts([])
    } finally {
      setIsLoadingAccounts(false)
    }
  }

  // Filter accounts based on search query
  const filterAccounts = (query: string) => {
    if (!query || query.length < 2) {
      setFilteredAccounts([])
      setSelectedIndex(-1)
      return
    }

    const searchLower = query.toLowerCase()
    const operatorTerms = ['me', 'my', 'wallet', 'operator', 'my wallet', 'owner']
    
    const filtered = allAccounts.filter(account => {
      // For operator account, check special search terms
      if (account.type === 'operator') {
        return operatorTerms.some(term => term.includes(searchLower)) ||
               searchLower.includes('operator') ||
               account.name?.toLowerCase().includes(searchLower)
      }
      
      // For regular accounts, search by name
      return account.full_account_name?.toLowerCase().includes(searchLower)
    })

    // Sort: operator first, then agents, then alphabetically
    const sorted = filtered.sort((a, b) => {
      // Operator always first
      if (a.type === 'operator' && b.type !== 'operator') return -1
      if (b.type === 'operator' && a.type !== 'operator') return 1
      
      // Then agents
      if (a.is_agent !== b.is_agent) return a.is_agent ? -1 : 1
      
      // Then alphabetically
      const nameA = a.name || a.full_account_name || ''
      const nameB = b.name || b.full_account_name || ''
      return nameA.localeCompare(nameB)
    })

    setFilteredAccounts(sorted)
    setSelectedIndex(-1) // Reset selection
  }

  // Fetch token balance
  const fetchTokenBalance = async () => {
    if (!user?.wallet?.address) return
    
    const addressToQuery = context === 'tokenbound' && tbaAddress ? tbaAddress : user.wallet.address

    try {
      if ((tokenType as string) === 'erc1155') {
        const balance = await publicClient.readContract({
          address: contractAddress as Address,
          abi: [
            {
              inputs: [
                { name: 'account', type: 'address' },
                { name: 'id', type: 'uint256' }
              ],
              name: 'balanceOf',
              outputs: [{ type: 'uint256' }],
              stateMutability: 'view',
              type: 'function'
            }
          ],
          functionName: 'balanceOf',
          args: [addressToQuery as Address, BigInt(tokenId || '0')]
        })
        setTokenBalance(balance as bigint)
      } else if ((tokenType as string) === 'native') {
        const balance = await publicClient.getBalance({
          address: addressToQuery as Address
        })
        setTokenBalance(balance)
      } else if ((tokenType as string) === 'erc20' || (tokenType as string) === 'erc721') {
        const balance = await publicClient.readContract({
          address: contractAddress as Address,
          abi: [
            {
              inputs: [{ name: 'account', type: 'address' }],
              name: 'balanceOf',
              outputs: [{ type: 'uint256' }],
              stateMutability: 'view',
              type: 'function'
            }
          ],
          functionName: 'balanceOf',
          args: [addressToQuery as Address]
        })
        setTokenBalance(balance as bigint)
      }
    } catch (error) {
      console.error('Error fetching token balance:', error)
      setTokenBalance(BigInt(0))
    }
  }

  // Helper functions
  const getDisplayName = () => {
    if (tokenType === 'erc1155') {
      return tokenName || 'Certificate'
    }
    if (tokenType === 'erc721') {
      return tokenName || tokenSymbol
    }
    return tokenSymbol
  }

  const getImageUrl = () => {
    return imageUrl
  }

  const isButtonDisabled = () => {
    if (isLoading || !recipientAddress) return true
    
    // For ERC721, no amount needed
    if (tokenType === 'erc721') {
      return false
    }
    
    // For other types, need valid amount
    if (!localAmount || Number(localAmount) <= 0) return true
    return !!localAmountError
  }

  // Handle amount input changes
  const handleInputChange = (value: string) => {
    // For ERC721, no amount input needed
    if (tokenType === 'erc721') {
      setLocalAmount('1')
      setLocalFormattedAmount('1')
      setLocalAmountError('')
      return
    }
    
    // For ERC1155, only allow whole numbers
    if ((tokenType as string) === 'erc1155') {
      const wholeNumberValue = value.replace(/[^\d]/g, '')
      setLocalAmount(wholeNumberValue)
      setLocalFormattedAmount(wholeNumberValue)
      
      // Validate against balance
      if (wholeNumberValue && tokenBalance) {
        const inputAmount = BigInt(Math.floor(Number(wholeNumberValue)))
        if (inputAmount > tokenBalance) {
          setLocalAmountError('Amount exceeds available balance')
        } else {
          setLocalAmountError('')
        }
      } else {
        setLocalAmountError('')
      }
      return
    }
    
    // For ERC20/native tokens, use actual decimals from token contract
    const maxDecimals = targetTokenDecimals
    const inputTokenType = tokenType === 'native' ? 'native' : 'erc20'
    const result = handleAmountChange(value, inputTokenType, maxDecimals)
    
    setLocalAmount(result.cleanValue)
    setLocalFormattedAmount(result.formattedValue)

    // Validate against balance using actual decimals
    if (result.cleanValue && tokenBalance) {
      const numericValue = Number(result.cleanValue)
      const decimals = targetTokenDecimals || 18 // Fallback to 18 if not set yet
      
      // Check if we have valid numbers before BigInt conversion
      if (isNaN(numericValue) || isNaN(decimals)) {
        setLocalAmountError('Invalid amount')
        return
      }
      
      const scaledAmount = numericValue * Math.pow(10, decimals)
      
      // Check if the scaled amount is a valid number
      if (isNaN(scaledAmount) || !isFinite(scaledAmount)) {
        setLocalAmountError('Amount too large')
        return
      }
      
      const inputAmount = BigInt(Math.floor(scaledAmount))
      
      if (inputAmount > tokenBalance) {
        setLocalAmountError('Amount exceeds available balance')
      } else {
        setLocalAmountError('')
      }
    } else {
      setLocalAmountError('')
    }
  }

  // Handle account selection
  const handleAccountSelect = (account: AccountSearchResult) => {
    setSelectedAccount(account)
    setAccountSearchQuery(account.name || account.full_account_name)
    setRecipientAddress(account.tba_address || '')
    setFilteredAccounts([]) // Hide dropdown
    setSelectedIndex(-1)
  }

  // Handle search query change
  const handleSearchQueryChange = (query: string) => {
    setAccountSearchQuery(query)
    if (selectedAccount) {
      setSelectedAccount(null) // Clear selection when typing
      setRecipientAddress('')
    }
  }

  // Handle keyboard navigation
  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (filteredAccounts.length === 0) return

    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault()
        setSelectedIndex(prev => 
          prev < filteredAccounts.length - 1 ? prev + 1 : 0
        )
        break
      case 'ArrowUp':
        e.preventDefault()
        setSelectedIndex(prev => 
          prev > 0 ? prev - 1 : filteredAccounts.length - 1
        )
        break
      case 'Enter':
        e.preventDefault()
        if (selectedIndex >= 0 && selectedIndex < filteredAccounts.length) {
          handleAccountSelect(filteredAccounts[selectedIndex])
        }
        break
      case 'Escape':
        e.preventDefault()
        setFilteredAccounts([])
        setSelectedIndex(-1)
        break
    }
  }

  // Reset and load data when modal opens
  useEffect(() => {
    if (isOpen) {
      setLocalAmount('')
      setLocalFormattedAmount('')
      setLocalAmountError('')
      setAccountSearchQuery('')
      setFilteredAccounts([])
      setSelectedAccount(null)
      setRecipientAddress('')
      setSelectedIndex(-1)
      
      // Always fetch target token decimals
      fetchTargetTokenDecimals()
      
      if (authenticated) {
        fetchTokenBalance()
        fetchAllAccounts()
      }
    }
  }, [isOpen, authenticated])

  // Filter accounts when search query changes
  useEffect(() => {
    filterAccounts(debouncedSearchQuery)
  }, [debouncedSearchQuery, allAccounts])

  const handleExecute = async () => {
    if (!authenticated) {
      login()
      return
    }

    if (!recipientAddress) return
    
    const sendAmount = tokenType === 'erc721' ? '1' : localAmount

    try {
      await executeSend(sendAmount, recipientAddress)
      
      // Refresh balance and close modal
      onRefreshBalance?.()
      onClose()
    } catch (error) {
      console.error('Send execution error:', error)
    }
  }

  const getDisplayAmount = () => {
    if (tokenType === 'erc721') return '1'
    return localFormattedAmount || '0'
  }

  const getAccountDisplayName = (account: AccountSearchResult) => {
    if (account.type === 'operator') {
      return account.name || 'My Wallet'
    }
    return account.full_account_name
  }

  const getAccountIcon = (account: AccountSearchResult) => {
    if (account.type === 'operator') {
      return (
        <div className="w-6 h-6 rounded-full bg-blue-500 flex items-center justify-center">
          <span className="text-xs font-bold text-white">W</span>
        </div>
      )
    }
    
    return (
      <AccountImage
        tokenId={account.token_id}
        groupName={account.group_name?.replace('.', '')}
        variant="circle"
        className="w-6 h-6"
      />
    )
  }

  return (
    <Dialog 
      open={isOpen} 
      onOpenChange={onClose}
      modal={true}
    >
      <DialogContent 
        className="sm:max-w-[500px] bg-black/95 border border-gray-800 shadow-xl backdrop-blur-xl z-[9999] fixed"
        onClick={(e) => {
          e.stopPropagation()
        }}
        onMouseDown={(e) => {
          e.stopPropagation()
        }}
        onKeyDown={(e) => e.stopPropagation()}
        onPointerDown={(e) => e.stopPropagation()}
      >
        <DialogHeader className="border-b border-gray-800 pb-4">
          <div className="flex items-center justify-between">
            <div className="flex flex-col gap-2">
              <DialogTitle className="text-xl font-bold text-white">
                send
              </DialogTitle>
              <div className="text-3xl font-bold text-white">
                {getDisplayName()}
              </div>
              {tokenName && tokenName !== tokenSymbol && tokenType !== 'erc1155' && (
                <div className="text-sm text-gray-400">
                  {tokenName}
                </div>
              )}
            </div>
            <div className="relative w-20 h-20 rounded-lg overflow-hidden">
              <Image
                src={getImageUrl()}
                alt={getDisplayName()}
                fill
                className="object-cover"
              />
            </div>
          </div>
        </DialogHeader>

        <div className="py-6 space-y-6">
          {!authenticated ? (
            /* Not Connected - Show Connect Account */
            <div className="space-y-6 text-center">
              <div className="space-y-4">
                <div className="w-16 h-16 mx-auto bg-amber-500/10 rounded-full flex items-center justify-center">
                  <Send className="w-8 h-8 text-amber-500" />
                </div>
                <div className="text-xl font-semibold text-white">
                  connect to send
                </div>
              </div>
            </div>
          ) : (
            /* Authenticated - Show Send Form */
            <div className="space-y-6">
              {/* Recipient Search */}
              <div className="space-y-3">
            <label className="text-sm font-medium text-gray-300">
              RECIPIENT
            </label>
            <div className="relative">
              <Input
                type="text"
                value={accountSearchQuery}
                onChange={(e) => handleSearchQueryChange(e.target.value)}
                onKeyDown={handleKeyDown}
                placeholder={context === 'tokenbound' ? "Search accounts or type 'my wallet'..." : "Search for an account..."}
                className="w-full bg-gray-900/50 border-gray-800 text-white placeholder:text-gray-500 h-12 text-lg font-medium"
              />
              {isLoadingAccounts && (
                <div className="absolute right-3 top-1/2 -translate-y-1/2">
                  <div className="w-5 h-5 border-2 border-gray-400 border-t-transparent rounded-full animate-spin" />
                </div>
              )}
              {filteredAccounts.length > 0 && !selectedAccount && (
                <div className="absolute z-10 w-full mt-1 bg-gray-900 border border-gray-800 rounded-lg shadow-lg max-h-60 overflow-auto">
                  {filteredAccounts.map((result, index) => (
                    <button
                      key={`${result.type}-${index}`}
                      onClick={() => handleAccountSelect(result)}
                      className={`w-full px-4 py-2 text-left transition-colors flex items-center gap-2 ${
                        index === selectedIndex 
                          ? 'bg-gray-700' 
                          : 'hover:bg-gray-800'
                      }`}
                    >
                      <div className="w-6 h-6 rounded-full overflow-hidden bg-gray-800 flex items-center justify-center">
                        {getAccountIcon(result)}
                      </div>
                      <div className="flex flex-col flex-1">
                        <span className="font-mono">{getAccountDisplayName(result)}</span>
                        {result.type === 'operator' && (
                          <span className="text-xs text-blue-400">
                            your wallet address
                          </span>
                        )}
                        {result.is_agent && result.type !== 'operator' && (
                          <span className="text-xs px-2 py-1 bg-blue-500/20 text-blue-400 rounded w-fit">
                            agent
                          </span>
                        )}
                      </div>
                    </button>
                  ))}
                </div>
              )}
            </div>
            {selectedAccount && recipientAddress && (
              <div className="flex items-center gap-3 mt-2">
                <div className="flex-1 space-y-1">
                  <div className="text-sm text-gray-400">
                    {getAccountDisplayName(selectedAccount)}
                  </div>
                  <div className="text-xs text-gray-500 font-mono">
                    {truncateAddress(recipientAddress)}
                  </div>
                </div>
                <div className="w-8 h-8 rounded-full overflow-hidden bg-gray-800 flex items-center justify-center">
                  {selectedAccount.type === 'operator' ? (
                    <div className="w-8 h-8 rounded-full bg-blue-500 flex items-center justify-center">
                      <span className="text-sm font-bold text-white">W</span>
                    </div>
                  ) : (
                    <AccountImage
                      tokenId={selectedAccount.token_id}
                      groupName={selectedAccount.group_name?.replace('.', '')}
                      variant="circle"
                      className="w-8 h-8"
                    />
                  )}
                </div>
              </div>
            )}
          </div>

          {/* Amount Input (hide for ERC721) */}
          {tokenType !== 'erc721' && (
            <div className="space-y-2">
              <label className="text-sm font-medium text-gray-300">
                AMOUNT
              </label>
              <Input
                type="text"
                value={localFormattedAmount}
                onChange={(e) => handleInputChange(e.target.value)}
                placeholder={tokenType === 'erc1155' ? 'enter amount' : `enter ${getDisplayName()} amount`}
                className={`bg-gray-900/50 border-gray-800 text-white placeholder:text-gray-500 h-12 text-lg font-medium ${
                  localAmountError ? 'border-red-500' : ''
                }`}
              />
              {localAmountError && (
                <div className="text-sm text-red-500">
                  {localAmountError}
                </div>
              )}
                                <div className="text-sm text-gray-400">
                    Balance: {formatBalance(tokenBalance.toString(), tokenType, targetTokenDecimals)}{tokenType === 'erc1155' ? '' : ` ${getDisplayName()}`}
                  </div>
            </div>
          )}

          {/* Send Summary */}
          {(recipientAddress && (localAmount || tokenType === 'erc721')) && (
            <div className="space-y-2">
              <label className="text-sm font-medium text-gray-300">
                SEND SUMMARY
              </label>
              <div className="bg-gray-900/50 border border-gray-800 rounded-lg p-4">
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-2">
                    <div className="w-6 h-6 rounded-full overflow-hidden bg-gray-800 flex items-center justify-center">
                      <Image
                        src={getImageUrl()}
                        alt={getDisplayName()}
                        width={24}
                        height={24}
                        className="object-cover"
                      />
                    </div>
                    <span className="text-lg font-medium">
                      {getDisplayAmount()}
                    </span>
                  </div>
                  {tokenType !== 'erc1155' && (
                    <span className="text-gray-400">
                      {getDisplayName()}
                    </span>
                  )}
                </div>
              </div>
            </div>
          )}
            </div>
          )}
        </div>

        {/* Action Buttons */}
        <div className="flex justify-end gap-3 pt-6 border-t border-gray-800">
          <Button 
            variant="ghost" 
            onClick={onClose}
            className="text-gray-400 hover:text-gray-300"
          >
            Cancel
          </Button>
          <Button
            onClick={handleExecute}
            disabled={authenticated && isButtonDisabled()}
            className="min-w-[120px] bg-amber-600 hover:bg-amber-500"
          >
            {isLoading ? (
              <div className="flex items-center gap-2">
                <div className="w-4 h-4 border-2 border-white/30 border-t-white rounded-full animate-spin" />
                <span>Processing...</span>
              </div>
            ) : authenticated ? (
              'SEND'
            ) : (
              'CONNECT'
            )}
          </Button>
        </div>
      </DialogContent>
    </Dialog>
  )
}
````

## File: src/modules/ensure/buttons/modals/swap.tsx
````typescript
'use client'

import { useState, useEffect } from 'react'
import { useDebounce } from '@/hooks/useDebounce'
import { usePrivy } from '@privy-io/react-auth'
import { createPublicClient, http, type Address } from 'viem'
import { base } from 'viem/chains'
import Image from 'next/image'
import { RefreshCw, ChevronDown, Loader2 } from 'lucide-react'
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"
import { Input } from "@/components/ui/input"
import { Button } from "@/components/ui/button"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import type { TokenInfo, ButtonContext, TokenType } from '../types'
import { handleAmountChange } from '../utils/input'
import { formatNumber, getTokenDecimals } from '../utils/formatting'
import { useOperations } from '../hooks/useOperations'
import { toast } from 'react-toastify'

interface SwapModalProps {
  isOpen: boolean
  onClose: () => void
  tokenSymbol: string
  tokenName?: string
  imageUrl?: string
  context: ButtonContext
  tokenType?: TokenType
  contractAddress: string
  tokenId?: string
  tbaAddress?: string
  pricePerToken?: bigint
  primaryMintActive?: boolean
  onRefreshBalance?: () => void
}

export function SwapModal({
  isOpen,
  onClose,
  tokenSymbol,
  tokenName,
  imageUrl = '/assets/no-image-found.png',
  context,
  tokenType = 'erc20',
  contractAddress,
  tokenId,
  tbaAddress,
  pricePerToken,
  primaryMintActive = false,
  onRefreshBalance
}: SwapModalProps) {
  const { authenticated, user, login } = usePrivy()
  
  // Modal state
  const [localAmount, setLocalAmount] = useState('')
  const [localFormattedAmount, setLocalFormattedAmount] = useState('')
  const [localAmountError, setLocalAmountError] = useState('')
  const [selectedToken, setSelectedToken] = useState<TokenInfo | null>(null)
  
  // Trading state
  const [availableTokens, setAvailableTokens] = useState<TokenInfo[]>([])
  const [isLoadingTokens, setIsLoadingTokens] = useState(false)
  const [estimatedOutput, setEstimatedOutput] = useState('0')
  const [isSimulating, setIsSimulating] = useState(false)
  const [tokenBalance, setTokenBalance] = useState<bigint>(BigInt(0))
  const [tokenImages, setTokenImages] = useState<Record<string, string>>({})
  const [targetTokenDecimals, setTargetTokenDecimals] = useState<number>(18)
  
  // Debounce amount for quote fetching
  const debouncedAmount = useDebounce(localAmount, 500)
  
  // Create public client
  const publicClient = createPublicClient({
    chain: base,
    transport: http()
  })

  const {
    isSwapping: isLoading,
    executeSwap
  } = useOperations({
    context,
    contractAddress,
    tokenId,
    tokenType,
    tbaAddress,
    pricePerToken,
    primaryMintActive,
    tokenName,
    tokenSymbol
  })

  // Add effect to fetch available tokens when modal opens
  useEffect(() => {
    const fetchAvailableTokens = async () => {
      if (!isOpen || !authenticated) return
      
      setIsLoadingTokens(true)
      try {
        // Get all supported tokens from both currencies and general certificates
        const [currenciesRes, certificatesRes] = await Promise.all([
          fetch('/api/currencies'),
          fetch('/api/general')
        ])

        if (!currenciesRes.ok || !certificatesRes.ok) {
          throw new Error('Failed to fetch supported tokens')
        }

        const [currencies, certificates] = await Promise.all([
          currenciesRes.json(),
          certificatesRes.json()
        ])

        // Create comprehensive token list for "TRANSFORM TO" dropdown
        const tokens: TokenInfo[] = []
        
        // Add native ETH if current token is not ETH
        if (tokenType !== 'native') {
          tokens.push({
            symbol: 'ETH',
            address: '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE' as Address,
            decimals: 18,
            type: 'native'
          })
        }
        
        // Add currencies (except the current one if it's a currency) sorted by symbol
        const filteredCurrencies = currencies
          .filter((c: any) => c.address.toLowerCase() !== contractAddress.toLowerCase())
          .map((c: any) => ({
            symbol: c.symbol,
            address: c.address as Address,
            decimals: c.decimals,
            type: 'currency' as const
          }))
          .sort((a: any, b: any) => a.symbol.localeCompare(b.symbol))
        
        tokens.push(...filteredCurrencies)
        
        // Add certificates (except the current one) sorted by symbol
        const filteredCertificates = certificates
          .filter((c: any) => c.contract_address.toLowerCase() !== contractAddress.toLowerCase())
          .map((c: any) => ({
            symbol: c.symbol,
            address: c.contract_address as Address,
            decimals: 18, // Certificates are always 18 decimals
            type: 'certificate' as const
          }))
          .sort((a: any, b: any) => a.symbol.localeCompare(b.symbol))
        
        tokens.push(...filteredCertificates)

        setAvailableTokens(tokens)
        // Set initial selected token to ETH
        setSelectedToken(tokens[0])
        
        // Fetch images for the tokens
        if (tokens.length > 0) {
          fetchTokenImages(tokens)
        }
      } catch (error) {
        console.error('Error fetching tokens:', error)
        toast.error('Failed to load available tokens')
      } finally {
        setIsLoadingTokens(false)
      }
    }

    fetchAvailableTokens()
  }, [isOpen, authenticated, contractAddress])

  // Fetch token images
  const fetchTokenImages = async (tokens: TokenInfo[]) => {
    console.log('Fetching images for tokens:', tokens.map(t => ({ symbol: t.symbol, address: t.address, type: t.type })))
    
    const imagePromises = tokens.map(async (token) => {
      try {
        console.log(`Fetching image for ${token.symbol} (${token.address})`)
        const response = await fetch(`/api/utilities/image?address=${token.address}`)
        console.log(`Image response for ${token.symbol}:`, response.status, response.ok)
        
        if (response.ok) {
          const data = await response.json()
          console.log(`Image data for ${token.symbol}:`, data)
          return { address: token.address, url: data.url }
        }
      } catch (error) {
        console.error(`Error fetching image for ${token.address}:`, error)
      }
      return { address: token.address, url: null }
    })

    const results = await Promise.all(imagePromises)
    const imageMap: Record<string, string> = {}
    
    results.forEach(({ address, url }) => {
      if (url) {
        imageMap[address] = url
      }
    })
    
    console.log('Final image map:', imageMap)
    setTokenImages(imageMap)
  }

  // Fetch target token decimals using viem
  const fetchTargetTokenDecimals = async () => {
    if ((tokenType as string) === 'erc1155') {
      setTargetTokenDecimals(0) // ERC1155 tokens don't have decimals
      return
    }

    try {
      const decimals = await publicClient.readContract({
        address: contractAddress as Address,
        abi: [
          {
            inputs: [],
            name: 'decimals',
            outputs: [{ type: 'uint8' }],
            stateMutability: 'view',
            type: 'function'
          }
        ],
        functionName: 'decimals'
      })
      setTargetTokenDecimals(Number(decimals))
    } catch (error) {
      console.error('Error fetching target token decimals:', error)
      setTargetTokenDecimals(18) // Default fallback
    }
  }

  // Fetch token balance (what we're swapping FROM)
  const fetchTokenBalance = async () => {
    if (!user?.wallet?.address) return
    
    const addressToQuery = context === 'tokenbound' && tbaAddress ? tbaAddress : user.wallet.address

    try {
      if ((tokenType as string) === 'erc1155') {
        const balance = await publicClient.readContract({
          address: contractAddress as Address,
          abi: [
            {
              inputs: [
                { name: 'account', type: 'address' },
                { name: 'id', type: 'uint256' }
              ],
              name: 'balanceOf',
              outputs: [{ type: 'uint256' }],
              stateMutability: 'view',
              type: 'function'
            }
          ],
          functionName: 'balanceOf',
          args: [addressToQuery as Address, BigInt(tokenId || '0')]
        })
        setTokenBalance(balance as bigint)
      } else if ((tokenType as string) === 'native') {
        const balance = await publicClient.getBalance({
          address: addressToQuery as Address
        })
        setTokenBalance(balance)
      } else if ((tokenType as string) === 'erc20' || (tokenType as string) === 'erc721') {
        const balance = await publicClient.readContract({
          address: contractAddress as Address,
          abi: [
            {
              inputs: [{ name: 'account', type: 'address' }],
              name: 'balanceOf',
              outputs: [{ type: 'uint256' }],
              stateMutability: 'view',
              type: 'function'
            }
          ],
          functionName: 'balanceOf',
          args: [addressToQuery as Address]
        })
        setTokenBalance(balance as bigint)
      }
    } catch (error) {
      console.error('Error fetching token balance:', error)
      setTokenBalance(BigInt(0))
    }
  }

  // Get price quote from 0x API
  const fetchQuote = async (
    sellToken: string,
    buyToken: string, 
    sellAmount: string
  ) => {
    if (!user?.wallet?.address || !sellAmount || Number(sellAmount) <= 0) {
      setEstimatedOutput('0')
      return
    }

    const takerAddress = context === 'tokenbound' && tbaAddress ? tbaAddress : user.wallet.address

    setIsSimulating(true)
    try {
      const params = new URLSearchParams({
        action: 'quote',
        sellToken,
        buyToken,
        sellAmount,
        taker: takerAddress,
        slippageBps: '200',
        swapFeeBps: '100'
      })

      const response = await fetch(`/api/0x?${params}`)
      if (!response.ok) {
        setEstimatedOutput('0')
        return
      }
      
      const data = await response.json()
      
      if (!data.liquidityAvailable || !data.buyAmount) {
        setEstimatedOutput('0')
        return
      }
      
      const amount = Number(data.buyAmount) / Math.pow(10, selectedToken?.decimals || 18)
      const formattedAmount = formatNumber(amount, selectedToken?.decimals || 18)
      setEstimatedOutput(formattedAmount)
    } catch (error) {
      console.error('Error getting quote:', error)
      setEstimatedOutput('0')
    } finally {
      setIsSimulating(false)
    }
  }

  // Helper functions
  const getDisplayName = () => {
    return tokenName || tokenSymbol
  }

  const getImageUrl = () => {
    return imageUrl
  }

  const isButtonDisabled = () => {
    if (isLoading || !localAmount || Number(localAmount) <= 0) return true
    if (!selectedToken) return true
    return !!localAmountError
  }

  // Handle amount input changes
  const handleInputChange = (value: string) => {
    // For ERC721 tokens, only allow 1
    if ((tokenType as string) === 'erc721') {
      setLocalAmount('1')
      setLocalFormattedAmount('1')
      setLocalAmountError('')
      return
    }
    
    // For ERC1155 tokens, only allow whole numbers
    if ((tokenType as string) === 'erc1155') {
      const wholeNumberValue = value.replace(/[^\d]/g, '')
      setLocalAmount(wholeNumberValue)
      setLocalFormattedAmount(wholeNumberValue)
      
      // Validate against balance
      if (wholeNumberValue && tokenBalance) {
        const inputAmount = BigInt(Math.floor(Number(wholeNumberValue)))
        if (inputAmount > tokenBalance) {
          setLocalAmountError('Amount exceeds available balance')
        } else {
          setLocalAmountError('')
        }
      } else {
        setLocalAmountError('')
      }
      return
    }
    
    // For ERC20/native tokens, use actual decimals from token contract
    const maxDecimals = targetTokenDecimals
    const inputTokenType = tokenType === 'native' ? 'native' : 'erc20'
    const result = handleAmountChange(value, inputTokenType, maxDecimals)
    
    setLocalAmount(result.cleanValue)
    setLocalFormattedAmount(result.formattedValue)

    // Validate against balance using actual decimals
    if (result.cleanValue && tokenBalance) {
      const numericValue = Number(result.cleanValue)
      const decimals = targetTokenDecimals || 18 // Fallback to 18 if not set yet
      
      // Check if we have valid numbers before BigInt conversion
      if (isNaN(numericValue) || isNaN(decimals)) {
        setLocalAmountError('Invalid amount')
        return
      }
      
      const scaledAmount = numericValue * Math.pow(10, decimals)
      
      // Check if the scaled amount is a valid number
      if (isNaN(scaledAmount) || !isFinite(scaledAmount)) {
        setLocalAmountError('Amount too large')
        return
      }
      
      const inputAmount = BigInt(Math.floor(scaledAmount))
      
      if (inputAmount > tokenBalance) {
        setLocalAmountError('Amount exceeds available balance')
      } else {
        setLocalAmountError('')
      }
    } else {
      setLocalAmountError('')
    }
  }

  // Reset and load data when modal opens
  useEffect(() => {
    if (isOpen) {
      setLocalAmount('')
      setLocalFormattedAmount('')
      setLocalAmountError('')
      setSelectedToken(null)
      setEstimatedOutput('0')
      
      // Always fetch target token decimals
      fetchTargetTokenDecimals()
      
      if (authenticated) {
        fetchTokenBalance()
      }
    }
  }, [isOpen, authenticated])

  // Set initial selected token when available tokens load
  useEffect(() => {
    if (availableTokens.length > 0 && !selectedToken) {
      const ethToken = availableTokens.find(t => t.type === 'native')
      if (ethToken) {
        setSelectedToken(ethToken)
      }
    }
  }, [availableTokens, selectedToken])

  // Clear estimate immediately when user starts typing (prevents stale estimates)
  useEffect(() => {
    if (localAmount !== debouncedAmount) {
      setEstimatedOutput('0')
    }
  }, [localAmount, debouncedAmount])

  // Fetch quote when debounced amount changes
  useEffect(() => {
    if (selectedToken && debouncedAmount) {
      const sellAmount = (Number(debouncedAmount) * Math.pow(10, targetTokenDecimals)).toString()
      fetchQuote(contractAddress, selectedToken.address, sellAmount)
    }
  }, [debouncedAmount, selectedToken, contractAddress, targetTokenDecimals])

  const handleExecute = async () => {
    if (!authenticated) {
      login()
      return
    }

    if (!localAmount || !selectedToken) return
    
    try {
      await executeSwap(localAmount, selectedToken)
      
      // Refresh balance and close modal
      onRefreshBalance?.()
      onClose()
    } catch (error) {
      console.error('Swap execution error:', error)
    }
  }

  const getDisplayAmount = () => {
    if (tokenType === 'erc721') return '1'
    return localFormattedAmount || '0'
  }

  return (
    <Dialog 
      open={isOpen} 
      onOpenChange={onClose}
      modal={true}
    >
      <DialogContent 
        className="sm:max-w-[500px] bg-black/95 border border-gray-800 shadow-xl backdrop-blur-xl z-[9999] fixed"
        onClick={(e) => {
          e.stopPropagation()
        }}
        onMouseDown={(e) => {
          e.stopPropagation()
        }}
        onKeyDown={(e) => e.stopPropagation()}
        onPointerDown={(e) => e.stopPropagation()}
      >
        <DialogHeader className="border-b border-gray-800 pb-4">
          <div className="flex items-center justify-between">
            <div className="flex flex-col gap-2">
              <DialogTitle className="text-xl font-bold text-white">
                transform
              </DialogTitle>
              <div className="text-3xl font-bold text-white">
                {getDisplayName()}
              </div>
            </div>
            <div className="relative w-20 h-20 rounded-lg overflow-hidden">
              <Image
                src={getImageUrl()}
                alt={getDisplayName()}
                fill
                className="object-cover"
              />
            </div>
          </div>
        </DialogHeader>

        <div className="py-6 space-y-6">
          {!authenticated ? (
            /* Not Connected - Show Connect Account */
            <div className="space-y-6 text-center">
              <div className="space-y-4">
                <div className="w-16 h-16 mx-auto bg-blue-500/10 rounded-full flex items-center justify-center">
                  <RefreshCw className="w-8 h-8 text-blue-500" />
                </div>
                <div className="text-xl font-semibold text-white">
                  connect to transform
                </div>
              </div>
            </div>
          ) : tokenBalance === BigInt(0) ? (
            // Show guidance when no balance
            <div className="space-y-6 text-center">
              <div className="text-lg text-gray-300">
                buy to transform
              </div>
              <p className="text-sm text-gray-400">
                You need {getDisplayName()} to transform them
              </p>
            </div>
          ) : (
            /* Authenticated - Show Swap Form */
            <div className="space-y-4">
              {/* Token Selection */}
              <div className="space-y-2">
                <label className="text-sm font-medium text-gray-300">
                  TRANSFORM TO
                </label>
                <Select
                  value={selectedToken?.address}
                  onValueChange={(value) => {
                    const token = availableTokens.find(t => t.address === value)
                    if (token) setSelectedToken(token)
                  }}
                >
                  <SelectTrigger className="bg-gray-900/50 border-gray-800 text-white h-12 text-lg font-medium">
                    <SelectValue placeholder="Select token" />
                  </SelectTrigger>
                  <SelectContent className="bg-gray-900 border-gray-800 z-[10000]">
                    {isLoadingTokens ? (
                      <div className="flex items-center justify-center p-4">
                        <div className="w-5 h-5 border-2 border-gray-400 border-t-transparent rounded-full animate-spin" />
                      </div>
                    ) : (
                      availableTokens.map((token) => (
                        <SelectItem
                          key={token.address}
                          value={token.address}
                          className="text-white hover:bg-gray-800 focus:bg-gray-800"
                        >
                          <div className="flex items-center gap-2">
                            <div className="w-6 h-6 rounded-full overflow-hidden bg-gray-800 flex items-center justify-center">
                              {tokenImages[token.address] ? (
                                <Image
                                  src={tokenImages[token.address]}
                                  alt={token.symbol}
                                  width={24}
                                  height={24}
                                  className="object-cover"
                                />
                              ) : (
                                <div className="w-6 h-6 bg-gray-700 rounded-full" />
                              )}
                            </div>
                            <div className="flex flex-col">
                              <span className="font-medium">{token.symbol}</span>
                              {token.balance && (
                                <span className="text-xs text-gray-400">
                                  Balance: {formatNumber(Number(token.balance) / Math.pow(10, token.decimals), token.decimals)}
                                </span>
                              )}
                            </div>
                          </div>
                        </SelectItem>
                      ))
                    )}
                  </SelectContent>
                </Select>
              </div>

              {/* Amount Input */}
              {selectedToken && (
                <div className="space-y-2">
                  <label className="text-sm font-medium text-gray-300">
                    {`spend ${getDisplayName()}`}
                  </label>
                  <Input
                    type="text"
                    value={localFormattedAmount}
                    onChange={(e) => handleInputChange(e.target.value)}
                    placeholder={`enter ${getDisplayName()} amount`}
                    className={`bg-gray-900/50 border-gray-800 text-white placeholder:text-gray-500 h-12 text-lg font-medium ${
                      localAmountError ? 'border-red-500' : ''
                    }`}
                  />
                  {localAmountError && (
                    <div className="text-sm text-red-500">
                      {localAmountError}
                    </div>
                  )}
                  <div className="text-sm text-gray-400">
                    Balance: {formatNumber(Number(tokenBalance) / Math.pow(10, targetTokenDecimals), targetTokenDecimals)} {getDisplayName()}
                  </div>
                </div>
              )}

              {/* Output Display */}
              {selectedToken && localAmount && (
                <div className="space-y-2">
                  <label className="text-sm font-medium text-gray-300">
                    ESTIMATED OUTPUT
                  </label>
                  <div className="bg-gray-900/50 border border-gray-800 rounded-lg p-4">
                    <div className="flex items-center justify-between">
                      <div className="flex items-center gap-2">
                        <div className="w-6 h-6 rounded-full overflow-hidden bg-gray-800 flex items-center justify-center">
                          <Image
                            src={tokenImages[selectedToken.address] || '/assets/no-image-found.png'}
                            alt={selectedToken.symbol}
                            width={24}
                            height={24}
                            className="object-cover"
                          />
                        </div>
                        <span className="text-lg font-medium">
                          {isSimulating ? (
                            <div className="w-5 h-5 border-2 border-gray-400 border-t-transparent rounded-full animate-spin" />
                          ) : (
                            estimatedOutput
                          )}
                        </span>
                      </div>
                      <span className="text-gray-400">
                        {selectedToken.symbol}
                      </span>
                    </div>
                  </div>
                </div>
              )}
            </div>
          )}
        </div>

        {/* Action Buttons */}
        <div className="flex justify-end gap-3 pt-6 border-t border-gray-800">
          <Button 
            variant="ghost" 
            onClick={onClose}
            className="text-gray-400 hover:text-gray-300"
          >
            Cancel
          </Button>
          <Button
            onClick={handleExecute}
            disabled={authenticated && isButtonDisabled()}
            className="min-w-[120px] bg-blue-600 hover:bg-blue-500"
          >
            {isLoading ? (
              <div className="flex items-center gap-2">
                <div className="w-4 h-4 border-2 border-white/30 border-t-white rounded-full animate-spin" />
                <span>Processing...</span>
              </div>
            ) : authenticated ? (
              'TRANSFORM'
            ) : (
              'CONNECT'
            )}
          </Button>
        </div>
      </DialogContent>
    </Dialog>
  )
}
````

## File: src/modules/ensure/buttons/operations/erc1155.ts
````typescript
import { encodeFunctionData, type Address } from 'viem'
import { parseTokenAmount } from '../utils/input'
import type { OperationResult, OperationParams } from './types'

// Contract addresses for ERC1155 operations
const CONTRACTS = {
  usdc: '0x833589fcd6edb6e08f4c7c32d4f71b54bda02913' as Address,
  erc20Minter: '0x777777e8850d8d6d98de2b5f64fae401f96eff31' as Address,
  mintReferral: '0x3CeDe7eae1feA81b4AEFf1f348f7497e6794ff96' as Address,
  proceeds: '0xa187F8CBdd36D63967c33f5BD4dD4B9ECA51270e' as Address
} as const

// Zora ERC20 Minter ABI fragment
const ZORA_ERC20_MINTER_ABI = [
  {
    inputs: [
      { name: 'mintTo', type: 'address' },
      { name: 'quantity', type: 'uint256' },
      { name: 'tokenAddress', type: 'address' },
      { name: 'tokenId', type: 'uint256' },
      { name: 'totalValue', type: 'uint256' },
      { name: 'currency', type: 'address' },
      { name: 'mintReferral', type: 'address' },
      { name: 'comment', type: 'string' }
    ],
    name: 'mint',
    outputs: [],
    stateMutability: 'payable',
    type: 'function'
  }
] as const

// ERC1155 ABI fragment
const ERC1155_ABI = [
  {
    inputs: [
      { name: 'from', type: 'address' },
      { name: 'to', type: 'address' },
      { name: 'id', type: 'uint256' },
      { name: 'amount', type: 'uint256' },
      { name: 'data', type: 'bytes' }
    ],
    name: 'safeTransferFrom',
    outputs: [],
    stateMutability: 'nonpayable',
    type: 'function'
  }
] as const

/**
 * ERC1155 Operations
 * 
 * Key features:
 * - Buy = Direct minting with USDC
 * - Requires USDC approval to minter contract
 * - Burn = Transfer to proceeds address
 */

export interface ERC1155Params extends OperationParams {
  tokenId: string
  pricePerToken?: bigint
  sendTo?: string
}

/**
 * Build a buy transaction - mint ERC1155 with USDC
 */
export const buildBuyTransaction = async (params: ERC1155Params): Promise<OperationResult> => {
  const { contractAddress, tokenId, amount, pricePerToken, userAddress, sendTo } = params
  
  if (!tokenId) {
    throw new Error('Token ID required for ERC1155 buy')
  }
  
  if (!pricePerToken) {
    throw new Error('Price per token required for ERC1155 buy')
  }

  const quantity = BigInt(Math.floor(Number(amount)))
  const totalPrice = pricePerToken * quantity
  const recipient = sendTo || userAddress

  // Build the mint transaction
  const data = encodeFunctionData({
    abi: ZORA_ERC20_MINTER_ABI,
    functionName: 'mint',
    args: [
      recipient as Address,           // recipient (maps to contract's mintTo param)
      quantity,                       // quantity
      contractAddress as Address,     // tokenAddress
      BigInt(tokenId),               // tokenId
      totalPrice,                    // totalValue
      CONTRACTS.usdc,                // currency
      CONTRACTS.mintReferral,        // mintReferral
      ''                             // comment
    ]
  })

  // Build USDC approval data
  const approvalData = encodeFunctionData({
    abi: [
      {
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' }
        ],
        name: 'approve',
        outputs: [{ type: 'bool' }],
        stateMutability: 'nonpayable',
        type: 'function'
      }
    ],
    functionName: 'approve',
    args: [CONTRACTS.erc20Minter, totalPrice]
  })

  return {
    transaction: {
      to: CONTRACTS.erc20Minter,
      data,
      value: '0x0'
    },
    needsApproval: true,
    approvalData: {
      to: CONTRACTS.usdc,
      data: approvalData,
      value: '0x0',
      spender: CONTRACTS.erc20Minter
    }
  }
}

/**
 * Build a swap transaction - not yet implemented for ERC1155
 */
export const buildSwapTransaction = async (params: ERC1155Params): Promise<OperationResult> => {
  throw new Error('ERC1155 swap not yet implemented')
}

/**
 * Build a send transaction - transfer ERC1155 tokens
 */
export const buildSendTransaction = async (params: ERC1155Params): Promise<OperationResult> => {
  const { contractAddress, tokenId, amount, recipient, userAddress } = params
  
  if (!tokenId) {
    throw new Error('Token ID required for ERC1155 send')
  }
  
  if (!recipient) {
    throw new Error('Recipient required for ERC1155 send')
  }

  const sendAmount = BigInt(Math.floor(Number(amount)))

  const data = encodeFunctionData({
    abi: ERC1155_ABI,
    functionName: 'safeTransferFrom',
    args: [
      userAddress as Address,
      recipient as Address,
      BigInt(tokenId),
      sendAmount,
      '0x' // No data needed
    ]
  })

  return {
    transaction: {
      to: contractAddress,
      data,
      value: '0x0'
    },
    needsApproval: false
  }
}

/**
 * Build a burn transaction - transfer to proceeds address
 */
export const buildBurnTransaction = async (params: ERC1155Params): Promise<OperationResult> => {
  const { contractAddress, tokenId, amount, userAddress } = params
  
  if (!tokenId) {
    throw new Error('Token ID required for ERC1155 burn')
  }

  const burnAmount = BigInt(Math.floor(Number(amount)))

  const data = encodeFunctionData({
    abi: ERC1155_ABI,
    functionName: 'safeTransferFrom',
    args: [
      userAddress as Address,
      CONTRACTS.proceeds,
      BigInt(tokenId),
      burnAmount,
      '0x' // No data needed
    ]
  })

  return {
    transaction: {
      to: contractAddress,
      data,
      value: '0x0'
    },
    needsApproval: false
  }
}
````

## File: src/modules/ensure/buttons/operations/erc20.ts
````typescript
import { encodeFunctionData, type Address } from 'viem'
import { parseTokenAmount } from '../utils/input'
import type { OperationResult, OperationParams } from './types'

/**
 * ERC20 Operations
 * 
 * Key insight: Buy and Swap are the same operation - both use 0x API
 * The only difference is the direction of the trade
 */

/**
 * Build a buy transaction - spend selectedToken to get contractAddress token
 * Uses 0x API with permit2
 */
export const buildBuyTransaction = async (params: OperationParams): Promise<OperationResult> => {
  const { contractAddress, amount, selectedToken, userAddress, sendTo } = params
  
  if (!selectedToken) {
    throw new Error('Selected token required for ERC20 buy')
  }

  const sellToken = selectedToken.address // Token we're spending
  const buyToken = contractAddress // Token we're buying
  
  // Determine the correct token type for parsing the sell amount
  const isSellingEth = sellToken.toLowerCase() === '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE'.toLowerCase()
  const sellTokenType = isSellingEth ? 'native' : 'erc20'
  const sellAmount = parseTokenAmount(amount, sellTokenType, selectedToken.decimals).toString()

  // Get quote from 0x API
  // Use sendTo for tokenbound context (TBA receives tokens), otherwise use userAddress
  const taker = sendTo || userAddress
  
  const params0x = new URLSearchParams({
    action: 'quote',
    sellToken,
    buyToken,
    sellAmount,
    taker,
    slippageBps: '200', // 2% slippage
    swapFeeBps: '100'   // 1% fee
  })

  const response = await fetch(`/api/0x?${params0x}`)
  if (!response.ok) {
    const errorData = await response.json()
    throw new Error(`0x API error: ${errorData.message || 'Unknown error'}`)
  }
  
  const quoteData = await response.json()
  
  if (!quoteData.liquidityAvailable) {
    throw new Error('Insufficient liquidity for this trade')
  }

  // Check if we need approval (all ERC20 tokens need approval for permit2)
  const needsApproval = !isSellingEth && (quoteData.permit2 || quoteData.allowanceTarget)

  return {
    transaction: {
      ...quoteData.transaction,
      sellToken,
      buyToken,
      sellAmount
    },
    needsApproval,
    approvalData: {
      permit2: quoteData.permit2,
      allowanceTarget: quoteData.allowanceTarget
    }
  }
}

/**
 * Build a swap transaction - spend contractAddress token to get selectedToken
 * This is just buy in reverse direction!
 */
export const buildSwapTransaction = async (params: OperationParams): Promise<OperationResult> => {
  const { contractAddress, amount, selectedToken, userAddress, sendTo } = params
  
  if (!selectedToken) {
    throw new Error('Selected token required for ERC20 swap')
  }

  // Swap is just buy with reversed tokens
  const swapParams = {
    ...params,
    contractAddress: selectedToken.address, // Now we're buying the selected token
    selectedToken: {
      ...selectedToken,
      address: contractAddress, // And selling the original contract token
      decimals: 18 // Our tokens are 18 decimals
    },
    sendTo // Ensure sendTo is passed through for tokenbound context
  }

  return await buildBuyTransaction(swapParams)
}

/**
 * Build a send transaction - transfer ERC20 tokens
 */
export const buildSendTransaction = async (params: OperationParams): Promise<OperationResult> => {
  const { contractAddress, amount, recipient, tokenDecimals = 18 } = params
  
  if (!recipient) {
    throw new Error('Recipient required for ERC20 send')
  }

  const sendAmount = parseTokenAmount(amount, 'erc20', tokenDecimals)

  // ERC20 transfer function call
  const data = encodeFunctionData({
    abi: [
      {
        inputs: [
          { name: 'to', type: 'address' },
          { name: 'amount', type: 'uint256' }
        ],
        name: 'transfer',
        outputs: [{ type: 'bool' }],
        stateMutability: 'nonpayable',
        type: 'function'
      }
    ],
    functionName: 'transfer',
    args: [recipient as Address, sendAmount]
  })

  return {
    transaction: {
      to: contractAddress,
      data,
      value: '0x0'
    },
    needsApproval: false
  }
}

/**
 * Build a burn transaction - burn ERC20 tokens
 */
export const buildBurnTransaction = async (params: OperationParams): Promise<OperationResult> => {
  const { contractAddress, amount, tokenDecimals = 18 } = params
  
  const burnAmount = parseTokenAmount(amount, 'erc20', tokenDecimals)

  // ERC20 burn function call
  const data = encodeFunctionData({
    abi: [
      {
        inputs: [{ name: 'amount', type: 'uint256' }],
        name: 'burn',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function'
      }
    ],
    functionName: 'burn',
    args: [burnAmount]
  })

  return {
    transaction: {
      to: contractAddress,
      data,
      value: '0x0'
    },
    needsApproval: false
  }
}
````

## File: src/modules/ensure/buttons/operations/erc721.ts
````typescript
import { encodeFunctionData, type Address } from 'viem'
import type { OperationResult, OperationParams } from './types'

/**
 * ERC721 Operations
 * 
 * Key features:
 * - No buy operation (NFTs aren't typically bought via DEX)
 * - Send = safeTransferFrom
 * - No burn operation (transfer to burn address if needed)
 */

export interface ERC721Params extends OperationParams {
  tokenId: string
}

// ERC721 ABI fragment
const ERC721_ABI = [
  {
    inputs: [
      { name: 'from', type: 'address' },
      { name: 'to', type: 'address' },
      { name: 'tokenId', type: 'uint256' }
    ],
    name: 'safeTransferFrom',
    outputs: [],
    stateMutability: 'nonpayable',
    type: 'function'
  }
] as const

/**
 * Build a buy transaction - not typically supported for NFTs
 */
export const buildBuyTransaction = async (params: ERC721Params): Promise<OperationResult> => {
  throw new Error('Buy operation not supported for ERC721 tokens. Use marketplace instead.')
}

/**
 * Build a swap transaction - not typically supported for NFTs
 */
export const buildSwapTransaction = async (params: ERC721Params): Promise<OperationResult> => {
  throw new Error('Swap operation not supported for ERC721 tokens. Use marketplace instead.')
}

/**
 * Build a send transaction - transfer NFT
 */
export const buildSendTransaction = async (params: ERC721Params): Promise<OperationResult> => {
  const { contractAddress, tokenId, recipient, userAddress } = params
  
  if (!tokenId) {
    throw new Error('Token ID required for ERC721 send')
  }
  
  if (!recipient) {
    throw new Error('Recipient required for ERC721 send')
  }

  const data = encodeFunctionData({
    abi: ERC721_ABI,
    functionName: 'safeTransferFrom',
    args: [
      userAddress as Address,
      recipient as Address,
      BigInt(tokenId)
    ]
  })

  return {
    transaction: {
      to: contractAddress,
      data,
      value: '0x0'
    },
    needsApproval: false
  }
}

/**
 * Build a burn transaction - transfer to burn address
 */
export const buildBurnTransaction = async (params: ERC721Params): Promise<OperationResult> => {
  const { contractAddress, tokenId, userAddress } = params
  
  if (!tokenId) {
    throw new Error('Token ID required for ERC721 burn')
  }

  // Transfer to null address (burn)
  const BURN_ADDRESS = '0x000000000000000000000000000000000000dEaD' as Address

  const data = encodeFunctionData({
    abi: ERC721_ABI,
    functionName: 'safeTransferFrom',
    args: [
      userAddress as Address,
      BURN_ADDRESS,
      BigInt(tokenId)
    ]
  })

  return {
    transaction: {
      to: contractAddress,
      data,
      value: '0x0'
    },
    needsApproval: false
  }
}
````

## File: src/modules/ensure/buttons/operations/index.ts
````typescript
import { TokenType } from '../types'
import * as nativeOps from './native'
import * as erc20Ops from './erc20'
import * as erc721Ops from './erc721'
import * as erc1155Ops from './erc1155'
import type { OperationResult, OperationParams } from './types'

// Re-export types
export type { OperationResult, OperationParams } from './types'

/**
 * Route operations to the appropriate token type handler
 */
export const getTokenOperations = (tokenType: TokenType) => {
  switch (tokenType) {
    case 'native':
      return nativeOps
    case 'erc20':
      return erc20Ops
    case 'erc721':
      return erc721Ops
    case 'erc1155':
      return erc1155Ops
    default:
      throw new Error(`Unsupported token type: ${tokenType}`)
  }
}

/**
 * Universal operation router
 * Note: This is a convenience function for future use
 */
export const executeOperation = async (
  operation: 'buy' | 'sell' | 'send' | 'burn',
  tokenType: TokenType,
  params: OperationParams
): Promise<OperationResult> => {
  const ops = getTokenOperations(tokenType)
  
  // Type assertions for token-specific requirements
  if ((tokenType === 'erc721' || tokenType === 'erc1155') && !params.tokenId) {
    throw new Error(`Token ID required for ${tokenType} operations`)
  }
  
  switch (operation) {
    case 'buy':
      return await ops.buildBuyTransaction(params as any)
    case 'sell':
      return await ops.buildSwapTransaction(params as any)
    case 'send':
      return await ops.buildSendTransaction(params as any)
    case 'burn':
      return await ops.buildBurnTransaction(params as any)
    default:
      throw new Error(`Unsupported operation: ${operation}`)
  }
}

// Direct exports for convenience
export const native = nativeOps
export const erc20 = erc20Ops
export const erc721 = erc721Ops
export const erc1155 = erc1155Ops
````

## File: src/modules/ensure/buttons/operations/native.ts
````typescript
import { parseEther, type Address } from 'viem'
import type { OperationResult, OperationParams } from './types'

/**
 * Native ETH Operations
 * 
 * Key features:
 * - Buy = Swap ETH for tokens (uses 0x API like ERC20)
 * - Send = Direct ETH transfer
 * - No burn operation for native ETH
 */

/**
 * Build a buy transaction - spend ETH to get tokens
 * This delegates to 0x API just like ERC20
 */
export const buildBuyTransaction = async (params: OperationParams): Promise<OperationResult> => {
  const { contractAddress, amount, userAddress, sendTo } = params

  // Use sendTo for tokenbound context (TBA receives tokens), otherwise use userAddress
  const taker = sendTo || userAddress

  // Use 0x API to swap ETH for tokens
  const params0x = new URLSearchParams({
    action: 'quote',
    sellToken: '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE', // ETH placeholder
    buyToken: contractAddress,
    sellAmount: parseEther(amount).toString(),
    taker,
    slippageBps: '200', // 2% slippage
    swapFeeBps: '100'   // 1% fee
  })

  const response = await fetch(`/api/0x?${params0x}`)
  if (!response.ok) {
    const errorData = await response.json()
    throw new Error(`0x API error: ${errorData.message || 'Unknown error'}`)
  }
  
  const quoteData = await response.json()
  
  if (!quoteData.liquidityAvailable) {
    throw new Error('Insufficient liquidity for this trade')
  }

  return {
    transaction: quoteData.transaction,
    needsApproval: false // ETH doesn't need approval
  }
}

/**
 * Build a swap transaction - spend ETH to get selected token
 * This is essentially the same as buy, but with different parameter naming for clarity
 */
export const buildSwapTransaction = async (params: OperationParams): Promise<OperationResult> => {
  const { selectedToken, amount, userAddress, sendTo } = params

  if (!selectedToken) {
    throw new Error('Selected token required for ETH swap')
  }

  // Use sendTo for tokenbound context (TBA receives tokens), otherwise use userAddress
  const taker = sendTo || userAddress

  // Use 0x API to swap ETH for selected token
  const params0x = new URLSearchParams({
    action: 'quote',
    sellToken: '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE', // ETH
    buyToken: selectedToken.address, // The token we want to get
    sellAmount: parseEther(amount).toString(), // ETH amount we're spending
    taker,
    slippageBps: '200', // 2% slippage
    swapFeeBps: '100'   // 1% fee  
  })

  const response = await fetch(`/api/0x?${params0x}`)
  if (!response.ok) {
    const errorData = await response.json()
    throw new Error(`0x API error: ${errorData.message || 'Unknown error'}`)
  }
  
  const quoteData = await response.json()
  
  if (!quoteData.liquidityAvailable) {
    throw new Error('Insufficient liquidity for this trade')
  }

  return {
    transaction: quoteData.transaction,
    needsApproval: false // ETH doesn't need approval
  }
}

/**
 * Build a send transaction - transfer ETH
 */
export const buildSendTransaction = async (params: OperationParams): Promise<OperationResult> => {
  const { amount, recipient } = params
  
  if (!recipient) {
    throw new Error('Recipient required for ETH send')
  }

  const sendAmount = parseEther(amount)

  return {
    transaction: {
      to: recipient as Address,
      value: `0x${sendAmount.toString(16)}`,
      data: '0x'
    },
    needsApproval: false
  }
}

/**
 * Build a burn transaction - not applicable for native ETH
 */
export const buildBurnTransaction = async (params: OperationParams): Promise<OperationResult> => {
  throw new Error('Burn operation not applicable for native ETH')
}
````

## File: src/modules/ensure/buttons/operations/types.ts
````typescript
export type OperationResult = {
  transaction: any
  needsApproval?: boolean
  approvalData?: any
}

export type OperationParams = {
  contractAddress: string
  tokenId?: string
  amount: string
  recipient?: string
  selectedToken?: any
  userAddress: string
  pricePerToken?: bigint
  sendTo?: string
  tokenDecimals?: number
}
````

## File: src/modules/ensure/buttons/utils/formatting.ts
````typescript
import { formatEther, formatUnits } from 'viem'
import type { TokenType } from '../types'

/**
 * Format a number for display with appropriate decimals and commas
 */
export const formatNumber = (num: number, decimals: number = 18): string => {
  if (num === 0) return '0'
  if (num < 0.000001) return '< 0.000001'
  
  // For tokens with lower decimals (like USDC), show more precise amounts
  if (decimals <= 8) {
    if (num < 0.01) return num.toFixed(6)
    if (num < 1) return num.toFixed(4)
    return num.toLocaleString('en-US', {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    })
  }
  
  // For tokens with high decimals (like ETH)
  if (num < 0.01) return num.toFixed(6)
  if (num < 1) return num.toFixed(4)
  if (num < 1000) {
    const fixed = num.toFixed(2)
    return fixed.endsWith('.00') ? fixed.slice(0, -3) : fixed
  }
  return num.toLocaleString('en-US', { maximumFractionDigits: 0 })
}

/**
 * Format token balance for display
 */
export const formatTokenBalance = (balance: string | undefined, decimals: number): number => {
  if (!balance) return 0
  const divisor = Math.pow(10, decimals)
  return Number(BigInt(balance)) / divisor
}

/**
 * Format balance based on token type
 */
export const formatBalance = (rawBalance: string | bigint, tokenType: TokenType, decimals?: number): string => {
  if (tokenType === 'erc721') {
    return '1'
  }
  
  if (tokenType === 'erc1155') {
    return rawBalance.toString()
  }
  
  // For fungible tokens (ETH and ERC20)
  const formatted = tokenType === 'native' 
    ? formatEther(BigInt(rawBalance))
    : formatUnits(BigInt(rawBalance), decimals || 18)
  
  const value = parseFloat(formatted)
  
  // For values >= 1, show full number with commas, no decimals
  if (value >= 1) {
    return Math.floor(value).toLocaleString('en-US')
  }
  
  // For small values, show more decimals to capture small amounts
  return value.toLocaleString('en-US', { 
    minimumSignificantDigits: 1,
    maximumSignificantDigits: 6
  })
}

/**
 * Format input value with appropriate decimals for display
 */
export const formatInputValue = (value: string): string => {
  const num = Number(value)
  if (num === 0 || isNaN(num)) return '0'
  
  if (num < 1) {
    return num.toLocaleString('en-US', {
      minimumFractionDigits: 0,
      maximumFractionDigits: 6
    })
  } else if (num < 1000) {
    return num.toLocaleString('en-US', {
      minimumFractionDigits: 0,
      maximumFractionDigits: 4
    })
  } else {
    return num.toLocaleString('en-US', {
      minimumFractionDigits: 0,
      maximumFractionDigits: 2
    })
  }
}

/**
 * Get token decimals based on token info
 */
export const getTokenDecimals = (symbol?: string, decimals?: number): number => {
  if (decimals) return decimals
  if (symbol === 'USDC') return 6
  return 18 // Default for most tokens
}
````

## File: src/modules/ensure/buttons/utils/images.ts
````typescript
const CACHE_KEY = 'token_images_cache'
const CACHE_EXPIRY = 3600000 // 1 hour in milliseconds

interface CachedImage {
  url: string
  timestamp: number
}

/**
 * Get token image from localStorage cache
 */
export const getImageFromCache = (address: string): string | null => {
  try {
    const cache = localStorage.getItem(CACHE_KEY)
    if (!cache) return null

    const images = JSON.parse(cache) as Record<string, CachedImage>
    const cached = images[address]

    if (!cached) return null

    // Check if cache is expired
    if (Date.now() - cached.timestamp > CACHE_EXPIRY) {
      return null
    }

    return cached.url
  } catch (error) {
    console.error('Error reading from image cache:', error)
    return null
  }
}

/**
 * Save token image to localStorage cache
 */
export const saveImageToCache = (address: string, url: string): void => {
  try {
    const cache = localStorage.getItem(CACHE_KEY)
    const images = cache ? JSON.parse(cache) : {}
    
    images[address] = {
      url,
      timestamp: Date.now()
    }

    localStorage.setItem(CACHE_KEY, JSON.stringify(images))
  } catch (error) {
    console.error('Error saving to image cache:', error)
  }
}

/**
 * Fetch token image from API
 */
export const fetchTokenImage = async (address: string): Promise<string | null> => {
  // Check cache first
  const cached = getImageFromCache(address)
  if (cached) return cached

  try {
    const response = await fetch(`/api/utilities/image?address=${address}`)
    const data = await response.json()
    if (data.url) {
      // Save to cache
      saveImageToCache(address, data.url)
      return data.url
    }
  } catch (error) {
    console.error('Error fetching token image:', error)
  }
  return null
}

/**
 * Get default image based on token type
 */
export const getDefaultTokenImage = (): string => {
  return '/assets/no-image-found.png'
}

/**
 * Batch fetch images for multiple tokens
 */
export const batchFetchTokenImages = async (
  addresses: string[],
  onProgress?: (address: string, url: string | null) => void
): Promise<Record<string, string | null>> => {
  const results: Record<string, string | null> = {}
  
  // Process in batches of 5 to avoid overwhelming the API
  const batchSize = 5
  for (let i = 0; i < addresses.length; i += batchSize) {
    const batch = addresses.slice(i, i + batchSize)
    
    // Fetch images in parallel for this batch
    const batchPromises = batch.map(async (address) => {
      const url = await fetchTokenImage(address)
      results[address] = url
      if (onProgress) {
        onProgress(address, url)
      }
      return { address, url }
    })

    await Promise.all(batchPromises)
  }

  return results
}
````

## File: src/modules/ensure/buttons/utils/index.ts
````typescript
// Re-export formatting utilities
export * from './formatting'

// Re-export input utilities
export * from './input'

// Re-export image utilities
export * from './images'

// Re-export notification utilities
export * from './notifications'

// Re-export tooltip utilities
export * from './tooltips'
````

## File: src/modules/ensure/buttons/utils/input.ts
````typescript
import { formatUnits, parseEther } from 'viem'
import type { TokenType, TokenInfo } from '../types'
import { getTokenDecimals } from './formatting'

/**
 * Handle amount input changes with formatting and validation
 */
export const handleAmountChange = (
  value: string, 
  tokenType: TokenType,
  maxDecimals?: number
): { cleanValue: string; formattedValue: string; isValid: boolean } => {
  // Remove existing commas first
  const withoutCommas = value.replace(/,/g, '')
  
  let cleanValue: string
  
  if (tokenType === 'erc721') {
    // Only allow whole number (1) for ERC721
    cleanValue = '1'
  } else if (tokenType === 'erc1155') {
    // Only allow whole numbers for ERC1155
    cleanValue = withoutCommas.replace(/[^\d]/g, '')
  } else {
    // Allow numbers and one decimal point for ERC20 and native ETH
    cleanValue = withoutCommas.replace(/[^\d.]/g, '').replace(/(\..*)\./g, '$1')
    
    // Handle decimal places
    if (cleanValue.includes('.')) {
      const [whole, fraction] = cleanValue.split('.')
      const decimals = maxDecimals || 18
      // Limit decimal places to token's decimals
      if (fraction && fraction.length > decimals) {
        cleanValue = `${whole}.${fraction.slice(0, decimals)}`
      }
    }
  }
  
  // Format with commas for display
  let formattedValue = ''
  if (cleanValue) {
    if (tokenType === 'erc721') {
      formattedValue = '1'
    } else if (tokenType === 'erc1155') {
      formattedValue = cleanValue.replace(/\B(?=(\d{3})+(?!\d))/g, ',')
    } else {
      const parts = cleanValue.split('.')
      const wholeNumber = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ',')
      formattedValue = parts.length > 1 ? `${wholeNumber}.${parts[1]}` : wholeNumber
    }
  }
  
  const isValid = cleanValue !== '' && !isNaN(Number(cleanValue)) && Number(cleanValue) > 0
  
  return { cleanValue, formattedValue, isValid }
}

/**
 * Validate amount against balance
 */
export const validateAmount = (
  amount: string,
  balance: string | bigint,
  tokenType: TokenType,
  decimals: number = 18
): string | null => {
  if (!amount || Number(amount) <= 0) {
    return 'Amount must be greater than zero'
  }
  
  try {
    let inputAmount: bigint
    let currentBalance: bigint
    
    if (tokenType === 'erc721') {
      inputAmount = BigInt(1)
      currentBalance = BigInt(balance)
    } else if (tokenType === 'erc1155') {
      inputAmount = BigInt(Math.floor(Number(amount)))
      currentBalance = BigInt(balance)
    } else {
      // For ERC20 and native tokens
      const multiplier = Math.pow(10, decimals)
      inputAmount = BigInt(Math.floor(Number(amount) * multiplier))
      currentBalance = BigInt(balance)
    }
    
    if (inputAmount > currentBalance) {
      return 'Amount exceeds available balance'
    }
    
    return null
  } catch (error) {
    return 'Invalid amount'
  }
}

/**
 * Parse user amount for transaction (convert to BigInt with proper decimals)
 */
export const parseAmount = (amount: string, decimals: number = 18): bigint => {
  // Remove commas from the amount string
  const cleanAmount = amount.replace(/,/g, '')
  // Convert to base units
  const [whole, fraction = ''] = cleanAmount.split('.')
  const paddedFraction = fraction.padEnd(decimals, '0')
  const trimmedFraction = paddedFraction.slice(0, decimals)
  const combined = whole + trimmedFraction
  return BigInt(combined)
}

/**
 * Parse amount for different token types
 */
export const parseTokenAmount = (
  amount: string,
  tokenType: TokenType,
  decimals: number = 18
): bigint => {
  if (tokenType === 'erc721') {
    return BigInt(1)
  } else if (tokenType === 'erc1155') {
    return BigInt(Math.floor(Number(amount.replace(/,/g, ''))))
  } else if (tokenType === 'native') {
    return parseEther(amount.replace(/,/g, ''))
  } else {
    // ERC20
    return parseAmount(amount, decimals)
  }
}

/**
 * Check if address is ETH placeholder
 */
export const isEthAddress = (address: string): boolean => {
  return address.toLowerCase() === '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE'.toLowerCase()
}

/**
 * Truncate address for display
 */
export const truncateAddress = (address: string): string => {
  if (!address) return ''
  return `${address.slice(0, 6)}...${address.slice(-4)}`
}
````

## File: src/modules/ensure/buttons/utils/notifications.ts
````typescript
import { toast, type Id } from 'react-toastify'
import React from 'react'
import type { OperationType } from '../types'

/**
 * Create initial transaction toast
 */
export const createTransactionToast = (operation: OperationType): Id => {
  return toast.loading('setting everything up...')
}

/**
 * Update transaction toast with new message
 */
export const updateTransactionToast = (
  toastId: Id, 
  message: string, 
  type: 'info' | 'success' | 'error' = 'info'
): void => {
  toast.update(toastId, {
    render: message,
    type,
    isLoading: type === 'info'
  })
}

/**
 * Success toast with transaction link
 */
export const successToast = (
  toastId: Id, 
  operation: OperationType, 
  txHash: string, 
  fromSymbol?: string, 
  toSymbol?: string
): void => {
  const message = getSuccessMessage(operation, fromSymbol, toSymbol)
  
  // Create React element with clickable link
  const ToastContent = React.createElement(
    'div',
    {},
    React.createElement('div', {}, message),
    React.createElement(
      'a',
      {
        href: `https://basescan.org/tx/${txHash}`,
        target: '_blank',
        rel: 'noopener noreferrer',
        className: 'text-sm text-blue-400 hover:text-blue-300 underline mt-1 block'
      },
      'View transaction'
    )
  )
  
  toast.update(toastId, {
    render: ToastContent,
    type: 'success',
    isLoading: false,
    autoClose: 5000
  })
}

/**
 * Error toast with user-friendly messages
 */
export const errorToast = (
  toastId: Id, 
  error: any, 
  defaultMessage: string = 'Transaction failed'
): void => {
  let userMessage = defaultMessage
  
  if (error?.code === 4001 || error?.message?.includes('rejected')) {
    userMessage = 'Transaction cancelled'
  } else if (error?.message?.includes('failed on-chain')) {
    userMessage = 'Transaction failed on-chain. This may be due to slippage or contract issues.'
  } else if (error?.message?.includes('insufficient funds')) {
    userMessage = 'Insufficient funds to complete this transaction'
  } else if (error?.message?.includes('gas')) {
    userMessage = 'Transaction failed due to gas estimation issues'
  } else if (error?.message) {
    userMessage = error.message
  }
  
  toast.update(toastId, {
    render: userMessage,
    type: 'error',
    isLoading: false,
    autoClose: 5000
  })
}

/**
 * Simple error toast (not updating existing)
 */
export const simpleErrorToast = (message: string): void => {
  toast.error(message)
}

/**
 * Simple success toast (not updating existing)
 */
export const simpleSuccessToast = (message: string): void => {
  toast.success(message)
}

/**
 * Get success message based on operation type
 */
const getSuccessMessage = (
  operation: OperationType, 
  fromSymbol?: string, 
  toSymbol?: string
): string => {
  switch (operation) {
    case 'buy':
      return 'success! you have ensured what matters'
    case 'swap':
      return `success! ${fromSymbol || 'tokens'} transformed to ${toSymbol || 'tokens'}`
    case 'send':
      return 'transfer successful!'
    case 'burn':
      return 'tokens burned successfully'
    default:
      return 'transaction successful!'
  }
}

/**
 * Handle approval-related toasts
 */
export const approvalToast = (toastId: Id, tokenSymbol: string): void => {
  toast.update(toastId, {
    render: `${tokenSymbol} approved! Click ENSURE again to complete purchase.`,
    type: 'success',
    isLoading: false,
    autoClose: 5000
  })
}

/**
 * Permit2 approval step messaging
 */
export const permit2ApprovalToast = (
  toastId: Id, 
  tokenSymbol: string, 
  context: 'tokenbound' | 'regular' = 'regular'
): void => {
  const message = context === 'tokenbound' 
    ? `approving ${tokenSymbol} spending for your agent account...`
    : `approving ${tokenSymbol} spending...`
    
  toast.update(toastId, {
    render: message,
    type: 'info',
    isLoading: true
  })
}

/**
 * Swap execution step messaging  
 */
export const swapExecutionToast = (
  toastId: Id,
  fromSymbol: string,
  toSymbol: string,
  context: 'tokenbound' | 'regular' = 'regular'
): void => {
  const message = context === 'tokenbound'
    ? `executing ${fromSymbol} → ${toSymbol} swap through your agent account...`
    : `executing ${fromSymbol} → ${toSymbol} swap...`
    
  toast.update(toastId, {
    render: message, 
    type: 'info',
    isLoading: true
  })
}

/**
 * Generic step-based transaction messaging
 */
export const stepTransactionToast = (
  toastId: Id,
  step: string,
  context: 'tokenbound' | 'regular' = 'regular'
): void => {
  const contextSuffix = context === 'tokenbound' ? ' through your agent account' : ''
  
  toast.update(toastId, {
    render: `${step}${contextSuffix}...`,
    type: 'info', 
    isLoading: true
  })
}

/**
 * Permit2 signature step messaging
 */
export const permit2SignatureToast = (
  toastId: Id,
  context: 'tokenbound' | 'regular' = 'regular'
): void => {
  const message = context === 'tokenbound' 
    ? 'signing permit2 message for your agent account...'
    : 'signing permit2 message...'
    
  toast.update(toastId, {
    render: message,
    type: 'info',
    isLoading: true
  })
}
````

## File: src/modules/ensure/buttons/utils/permit2.ts
````typescript
import { 
  createPublicClient,
  createWalletClient,
  custom,
  http,
  type Address,
  maxUint256,
  encodeFunctionData
} from 'viem'
import { base } from 'viem/chains'

export const PERMIT2_ADDRESS = '0x000000000022D473030F116dDEE9F6B43aC78BA3' as const

const ERC20_ABI = [
  {
    inputs: [
      { name: 'owner', type: 'address' },
      { name: 'spender', type: 'address' }
    ],
    name: 'allowance',
    outputs: [{ type: 'uint256' }],
    stateMutability: 'view',
    type: 'function'
  },
  {
    inputs: [
      { name: 'spender', type: 'address' },
      { name: 'amount', type: 'uint256' }
    ],
    name: 'approve',
    outputs: [{ type: 'bool' }],
    stateMutability: 'nonpayable',
    type: 'function'
  }
] as const

export interface Permit2CheckParams {
  sellToken: Address
  sellAmount: bigint
  allowanceTarget: Address
  userAddress: Address
  provider: any
  onStatus?: (message: string, type?: 'info' | 'success' | 'error') => void
}

export interface Permit2ApprovalResult {
  needsApproval: boolean
  currentAllowance: bigint
  approvalHash?: string
}

/**
 * Check if permit2 approval is needed and handle approval if required
 */
export const checkAndHandlePermit2Approval = async ({
  sellToken,
  sellAmount,
  allowanceTarget,
  userAddress,
  provider,
  onStatus
}: Permit2CheckParams): Promise<Permit2ApprovalResult> => {
  // Create clients
  const publicClient = createPublicClient({
    chain: base,
    transport: http()
  })

  const walletClient = createWalletClient({
    chain: base,
    transport: custom(provider)
  })

  // Validate addresses
  if (!allowanceTarget || !sellToken) {
    throw new Error('Invalid address parameters for permit2 approval')
  }

  const formattedAllowanceTarget = allowanceTarget.startsWith('0x') 
    ? allowanceTarget 
    : `0x${allowanceTarget}`

  if (formattedAllowanceTarget.length !== 42) {
    throw new Error('Invalid allowance target address format')
  }

  try {
    onStatus?.('checking if approval is needed...', 'info')

    // Check current allowance
    const currentAllowance = await publicClient.readContract({
      address: sellToken,
      abi: ERC20_ABI,
      functionName: 'allowance',
      args: [userAddress, formattedAllowanceTarget as Address]
    })

    console.log('Permit2 allowance check:', {
      token: sellToken,
      spender: formattedAllowanceTarget,
      currentAllowance: currentAllowance.toString(),
      requiredAmount: sellAmount.toString(),
      needsApproval: currentAllowance < sellAmount
    })

    // If allowance is sufficient, no approval needed
    if (currentAllowance >= sellAmount) {
      console.log('Sufficient allowance already exists')
      return {
        needsApproval: false,
        currentAllowance
      }
    }

    // Need approval - execute it
    onStatus?.('approving token spending...', 'info')

    const approvalHash = await walletClient.writeContract({
      address: sellToken,
      abi: ERC20_ABI,
      functionName: 'approve',
      args: [formattedAllowanceTarget as Address, maxUint256],
      account: userAddress
    })

    // Wait for approval confirmation
    onStatus?.('waiting for approval confirmation...', 'info')
    const receipt = await publicClient.waitForTransactionReceipt({ 
      hash: approvalHash,
      timeout: 120_000 // 2 minute timeout
    })

    if (!receipt.status) {
      throw new Error('Approval transaction failed')
    }

    onStatus?.('approval confirmed!', 'success')

    // Verify the allowance was set correctly
    await new Promise(resolve => setTimeout(resolve, 2000)) // Wait for network propagation
    
    const newAllowance = await publicClient.readContract({
      address: sellToken,
      abi: ERC20_ABI,
      functionName: 'allowance',
      args: [userAddress, formattedAllowanceTarget as Address]
    })

    console.log('New allowance after approval:', newAllowance.toString())
    
    if (newAllowance < sellAmount) {
      throw new Error('Allowance not set correctly after approval')
    }

    return {
      needsApproval: true,
      currentAllowance: newAllowance,
      approvalHash
    }

  } catch (error) {
    console.error('Error in permit2 approval check/set:', error)
    throw error
  }
}

/**
 * For tokenbound accounts - execute permit2 approval through TBA
 */
export const handleTokenboundPermit2Approval = async ({
  sellToken,
  sellAmount,
  allowanceTarget,
  userAddress,
  tbaAddress,
  tokenboundClient,
  provider,
  onStatus
}: Permit2CheckParams & { 
  tbaAddress: Address
  tokenboundClient: any
}): Promise<Permit2ApprovalResult> => {
  // Create public client for reading
  const publicClient = createPublicClient({
    chain: base,
    transport: http()
  })

  const formattedAllowanceTarget = allowanceTarget.startsWith('0x') 
    ? allowanceTarget 
    : `0x${allowanceTarget}`

  try {
    onStatus?.('checking if approval is needed...', 'info')

    // Check current allowance for the TBA
    const currentAllowance = await publicClient.readContract({
      address: sellToken,
      abi: ERC20_ABI,
      functionName: 'allowance',
      args: [tbaAddress, formattedAllowanceTarget as Address]
    })

    console.log('TBA Permit2 allowance check:', {
      token: sellToken,
      tbaAddress,
      spender: formattedAllowanceTarget,
      currentAllowance: currentAllowance.toString(),
      requiredAmount: sellAmount.toString(),
      needsApproval: currentAllowance < sellAmount
    })

    // If allowance is sufficient, no approval needed
    if (currentAllowance >= sellAmount) {
      console.log('TBA has sufficient allowance')
      return {
        needsApproval: false,
        currentAllowance
      }
    }

    // Need approval - execute through tokenbound
    onStatus?.('approving token spending for your agent account...', 'info')

    // Encode the approval transaction data
    const approvalData = encodeFunctionData({
      abi: ERC20_ABI,
      functionName: 'approve',
      args: [formattedAllowanceTarget as Address, maxUint256]
    })

    // Execute through tokenbound client
    const approvalHash = await tokenboundClient.execute({
      account: tbaAddress,
      to: sellToken,
      value: BigInt(0),
      data: approvalData
    })

    // Wait for approval confirmation
    onStatus?.('waiting for approval confirmation...', 'info')
    const receipt = await publicClient.waitForTransactionReceipt({ 
      hash: approvalHash,
      timeout: 120_000 // 2 minute timeout
    })

    if (!receipt.status) {
      throw new Error('TBA approval transaction failed')
    }

    onStatus?.('approval confirmed!', 'success')

    // Verify the allowance was set correctly
    await new Promise(resolve => setTimeout(resolve, 2000))
    
    const newAllowance = await publicClient.readContract({
      address: sellToken,
      abi: ERC20_ABI,
      functionName: 'allowance',
      args: [tbaAddress, formattedAllowanceTarget as Address]
    })

    console.log('New TBA allowance after approval:', newAllowance.toString())
    
    if (newAllowance < sellAmount) {
      throw new Error('TBA allowance not set correctly after approval')
    }

    return {
      needsApproval: true,
      currentAllowance: newAllowance,
      approvalHash
    }

  } catch (error) {
    console.error('Error in TBA permit2 approval:', error)
    throw error
  }
}
````

## File: src/modules/ensure/buttons/utils/tooltips.ts
````typescript
import type { Operation } from '../types'

interface TooltipEntry {
  default: string
  variants?: Record<string, string>
}

type TooltipConfig = Record<Operation, TooltipEntry>

const TOOLTIP_CONFIG: TooltipConfig = {
  buy: {
    default: 'buy'
  },
  swap: {
    default: 'swap'
  },
  send: {
    default: 'send'
  },
  burn: {
    default: 'burn'
  }
}

/**
 * Get tooltip text for an operation
 * @param operation - The operation type
 * @param variant - Optional variant for custom tooltip text
 * @returns The tooltip text
 */
export const getTooltipText = (operation: Operation, variant?: string): string => {
  const config = TOOLTIP_CONFIG[operation]
  
  if (variant && config.variants && config.variants[variant]) {
    return config.variants[variant]
  }
  
  return config.default
}

/**
 * Update tooltip for a specific operation and variant
 * @param operation - The operation type
 * @param text - The new tooltip text
 * @param variant - Optional variant name, defaults to 'default'
 */
export const updateTooltip = (operation: Operation, text: string, variant: string = 'default'): void => {
  if (variant === 'default') {
    TOOLTIP_CONFIG[operation].default = text
  } else {
    if (!TOOLTIP_CONFIG[operation].variants) {
      TOOLTIP_CONFIG[operation].variants = {}
    }
    TOOLTIP_CONFIG[operation].variants![variant] = text
  }
}

/**
 * Add a new tooltip variant
 * @param operation - The operation type
 * @param variant - The variant name
 * @param text - The tooltip text
 */
export const addTooltipVariant = (operation: Operation, variant: string, text: string): void => {
  updateTooltip(operation, text, variant)
}

// Example usage:
// To add a context-specific variant:
// addTooltipVariant('buy', 'erc1155', 'ensure')
// addTooltipVariant('buy', 'general', 'acquire')
// 
// To use a variant:
// getTooltipText('buy', 'erc1155') // returns 'ensure'
// getTooltipText('buy') // returns 'buy' (default)
````

## File: src/modules/ensure/buttons/EnsureButtons.tsx
````typescript
'use client'

import React, { useState } from 'react'
import { PlusCircle, RefreshCw, Flame, Send } from 'lucide-react'
import {
  Tooltip,
  TooltipProvider,
  TooltipTrigger,
  TooltipContent,
} from "@/components/ui/tooltip"
import { cn } from '@/lib/utils'
import { BuyModal } from './modals/buy'
import { SwapModal } from './modals/swap'
import { SendModal } from './modals/send'
import { BurnModal } from './modals/burn'
import type { 
  ButtonContext, 
  Operation, 
  TokenType
} from './types'
import { getTooltipText } from './utils'

// TODO: Re-enable swap functionality once implemented
const SWAP_ENABLED = true
const BURN_ENABLED = true

interface EnsureButtonsProps {
  // Basic token info
  tokenSymbol: string
  tokenName?: string
  imageUrl?: string
  contractAddress: string
  tokenId?: string
  tokenType?: TokenType
  context: ButtonContext
  
  // Optional TBA info
  tbaAddress?: string
  pricePerToken?: bigint
  primaryMintActive?: boolean
  
  // Button visibility control
  showBuy?: boolean
  showSwap?: boolean
  showSend?: boolean
  showBurn?: boolean
  
  // New props for muted state
  muted?: boolean
  mutedTooltip?: string
  
  // Styling
  variant?: 'grid' | 'list' | 'portfolio'
  size?: 'sm' | 'md'
  className?: string
  
  // Callbacks
  onRefreshBalance?: () => void
}

export default function EnsureButtons({
  tokenSymbol,
  tokenName,
  imageUrl,
  contractAddress,
  tokenId,
  tokenType = 'erc20',
  context,
  tbaAddress,
  pricePerToken,
  primaryMintActive = false,
  showBuy = true,
  showSwap = true,
  showSend = true,
  showBurn = true,
  muted = false,
  mutedTooltip = 'Actions not available',
  variant = 'grid',
  size = 'md',
  className = '',
  onRefreshBalance
}: EnsureButtonsProps) {
  // Modal state
  const [modalOpen, setModalOpen] = useState(false)
  const [currentOperation, setCurrentOperation] = useState<Operation | null>(null)

  const handleOpenModal = (operation: Operation) => {
    setCurrentOperation(operation)
    setModalOpen(true)
  }

  const handleCloseModal = () => {
    setModalOpen(false)
    setCurrentOperation(null)
  }

  // Icon sizing based on size prop
  const iconSize = size === 'sm' ? 'w-4 h-4' : 'w-5 h-5'
  const buttonSize = size === 'sm' ? 'p-1.5' : 'p-2'

  // Determine button availability based on token type and context
  const buttonConfig = {
    buy: {
      available: showBuy,
      icon: PlusCircle,
      color: 'stroke-green-500 hover:stroke-green-400',
      tooltip: getTooltipText('buy'),
      disabled: false
    },
    swap: {
      available: showSwap && tokenType !== 'erc1155' && context !== 'specific' && SWAP_ENABLED,
      icon: RefreshCw,
      color: SWAP_ENABLED ? 'stroke-blue-500 hover:stroke-blue-400' : 'stroke-gray-600',
      tooltip: SWAP_ENABLED ? getTooltipText('swap') : 'coming soon',
      disabled: !SWAP_ENABLED
    },
    send: {
      available: showSend,
      icon: Send,
      color: 'stroke-amber-500 hover:stroke-amber-400',
      tooltip: getTooltipText('send'),
      disabled: false
    },
    burn: {
      available: showBurn && BURN_ENABLED,
      icon: Flame,
      color: BURN_ENABLED ? 'stroke-orange-500 hover:stroke-orange-400' : 'stroke-gray-600',
      tooltip: BURN_ENABLED ? getTooltipText('burn') : 'coming soon',
      disabled: !BURN_ENABLED
    }
  }

  // Filter available buttons (including disabled ones for "coming soon" display)
  const visibleButtons = Object.entries(buttonConfig).filter(([key, config]) => {
    if (key === 'swap') {
      return showSwap && tokenType !== 'erc1155' && context !== 'specific'
    }
    if (key === 'burn') {
      return showBurn
    }
    return config.available
  })

  if (visibleButtons.length === 0) {
    return null
  }

  // If muted, wrap all buttons in a single tooltip
  if (muted) {
    return (
      <TooltipProvider>
        <Tooltip>
          <TooltipTrigger asChild>
            <div className={cn(
              "flex items-center gap-1",
              variant === 'list' && "justify-end",
              className
            )}>
              {visibleButtons.map(([operation, config]) => {
                const IconComponent = config.icon
                const isDisabled = config.disabled || muted
                const tooltipText = muted ? mutedTooltip : config.tooltip
                
                return (
                  <button
                    key={operation}
                    disabled={isDisabled}
                    className={cn(
                      "rounded-md transition-colors cursor-not-allowed",
                      "text-gray-600",
                      buttonSize
                    )}
                  >
                    <IconComponent className={cn(iconSize, "stroke-gray-600", "transition-colors")} />
                  </button>
                )
              })}
            </div>
          </TooltipTrigger>
          <TooltipContent>
            <p>{mutedTooltip}</p>
          </TooltipContent>
        </Tooltip>
      </TooltipProvider>
    )
  }

  return (
    <>
      <div className={cn(
        "flex items-center gap-1",
        variant === 'list' && "justify-end",
        className
      )}>
        {visibleButtons.map(([operation, config]) => {
          const IconComponent = config.icon
          const isDisabled = config.disabled || muted
          const tooltipText = muted ? mutedTooltip : config.tooltip
          
          return (
            <TooltipProvider key={operation}>
              <Tooltip>
                <TooltipTrigger asChild>
                  <button
                    onClick={(e) => {
                      if (isDisabled) return
                      e.preventDefault()
                      e.stopPropagation()
                      e.nativeEvent.stopImmediatePropagation()
                      handleOpenModal(operation as Operation)
                    }}
                    onMouseDown={(e) => {
                      e.stopPropagation()
                    }}
                    disabled={isDisabled}
                    className={cn(
                      "rounded-md transition-colors",
                      isDisabled 
                        ? "cursor-not-allowed text-gray-600" 
                        : "hover:bg-white/10 text-gray-300 hover:text-gray-100",
                      buttonSize
                    )}
                  >
                    <IconComponent className={cn(iconSize, config.color, "transition-colors")} />
                  </button>
                </TooltipTrigger>
                <TooltipContent>
                  <p>{tooltipText}</p>
                </TooltipContent>
              </Tooltip>
            </TooltipProvider>
          )
        })}
      </div>

      {/* Only render modals when actually open to prevent unnecessary hook calls */}
      {modalOpen && currentOperation === 'buy' && (
        <BuyModal
          isOpen={true}
          onClose={handleCloseModal}
          tokenSymbol={tokenSymbol}
          tokenName={tokenName}
          imageUrl={imageUrl}
          context={context}
          tokenType={tokenType}
          contractAddress={contractAddress}
          tokenId={tokenId}
          tbaAddress={tbaAddress}
          pricePerToken={pricePerToken}
          primaryMintActive={primaryMintActive}
          onRefreshBalance={onRefreshBalance}
        />
      )}

      {modalOpen && currentOperation === 'swap' && (
        <SwapModal
          isOpen={true}
          onClose={handleCloseModal}
          tokenSymbol={tokenSymbol}
          tokenName={tokenName}
          imageUrl={imageUrl}
          context={context}
          tokenType={tokenType}
          contractAddress={contractAddress}
          tokenId={tokenId}
          tbaAddress={tbaAddress}
          pricePerToken={pricePerToken}
          primaryMintActive={primaryMintActive}
          onRefreshBalance={onRefreshBalance}
        />
      )}

      {modalOpen && currentOperation === 'send' && (
        <SendModal
          isOpen={true}
          onClose={handleCloseModal}
          tokenSymbol={tokenSymbol}
          tokenName={tokenName}
          imageUrl={imageUrl}
          context={context}
          tokenType={tokenType}
          contractAddress={contractAddress}
          tokenId={tokenId}
          tbaAddress={tbaAddress}
          onRefreshBalance={onRefreshBalance}
        />
      )}

      {modalOpen && currentOperation === 'burn' && (
        <BurnModal
          isOpen={true}
          onClose={handleCloseModal}
          tokenSymbol={tokenSymbol}
          tokenName={tokenName}
          imageUrl={imageUrl}
          context={context}
          tokenType={tokenType}
          contractAddress={contractAddress}
          tokenId={tokenId}
          tbaAddress={tbaAddress}
          pricePerToken={pricePerToken}
          primaryMintActive={primaryMintActive}
          onRefreshBalance={onRefreshBalance}
        />
      )}
    </>
  )
}
````

## File: src/modules/ensure/buttons/EnsureButtonsDetails.tsx
````typescript
'use client'

import React, { useState, useMemo, useCallback, useEffect } from 'react'
import { PlusCircle, RefreshCw, Flame, Send } from 'lucide-react'
import { usePrivy } from '@privy-io/react-auth'
import { createPublicClient, http, type Address } from 'viem'
import { base } from 'viem/chains'
import {
  Tooltip,
  TooltipProvider,
  TooltipTrigger,
  TooltipContent,
} from "@/components/ui/tooltip"
import { cn } from '@/lib/utils'
import { BuyModal } from './modals/buy'
import { SwapModal } from './modals/swap'
import { SendModal } from './modals/send'
import { BurnModal } from './modals/burn'
import type { 
  ButtonContext, 
  Operation, 
  TokenType
} from './types'
import { useOperations } from './hooks/useOperations'
import { formatBalance, getTooltipText } from './utils'

// TODO: Re-enable swap functionality once implemented
const SWAP_ENABLED = true
const BURN_ENABLED = true

interface EnsureButtonsProps {
  tokenSymbol: string
  tokenName?: string
  imageUrl?: string
  contractAddress: string
  tokenId?: string
  context: ButtonContext
  tokenType?: TokenType
  tbaAddress?: string
  primaryMintActive?: boolean
  pricePerToken?: bigint
  className?: string
  variant?: 'buy-only' | 'portfolio' | 'page'
  showSwap?: boolean
  showSend?: boolean
  showBurn?: boolean
  onRefreshBalance?: () => void
}

export default function EnsureButtons({
  tokenSymbol,
  tokenName,
  imageUrl,
  contractAddress,
  tokenId,
  context,
  tokenType = 'erc20',
  tbaAddress,
  primaryMintActive = false,
  pricePerToken,
  className = '',
  variant = 'page',
  showSwap = true,
  showSend = true,
  showBurn = true,
  onRefreshBalance
}: EnsureButtonsProps) {
  const { authenticated, user } = usePrivy()
  
  // Modal state
  const [modalOpen, setModalOpen] = useState(false)
  const [currentOperation, setCurrentOperation] = useState<Operation | null>(null)
  const [tokenBalance, setTokenBalance] = useState<bigint>(BigInt(0))

  // Create public client
  const publicClient = useMemo(() => createPublicClient({
    chain: base,
    transport: http()
  }), [])

  // Simple token balance fetcher
  const fetchTokenBalance = useCallback(async () => {
    if (!user?.wallet?.address) return
    
    const addressToQuery = context === 'tokenbound' && tbaAddress ? tbaAddress : user.wallet.address

    try {
      if ((tokenType as string) === 'erc1155') {
        const balance = await publicClient.readContract({
          address: contractAddress as Address,
          abi: [
            {
              inputs: [
                { name: 'account', type: 'address' },
                { name: 'id', type: 'uint256' }
              ],
              name: 'balanceOf',
              outputs: [{ type: 'uint256' }],
              stateMutability: 'view',
              type: 'function'
            }
          ],
          functionName: 'balanceOf',
          args: [addressToQuery as Address, BigInt(tokenId || '0')]
        })
        setTokenBalance(balance as bigint)
      } else if ((tokenType as string) === 'native') {
        const balance = await publicClient.getBalance({
          address: addressToQuery as Address
        })
        setTokenBalance(balance)
      } else if ((tokenType as string) === 'erc20') {
        const balance = await publicClient.readContract({
          address: contractAddress as Address,
          abi: [
            {
              inputs: [{ name: 'account', type: 'address' }],
              name: 'balanceOf',
              outputs: [{ type: 'uint256' }],
              stateMutability: 'view',
              type: 'function'
            }
          ],
          functionName: 'balanceOf',
          args: [addressToQuery as Address]
        })
        setTokenBalance(balance as bigint)
      }
    } catch (error) {
      console.error('Error fetching token balance:', error)
      setTokenBalance(BigInt(0))
    }
  }, [context, contractAddress, tokenId, tokenType, tbaAddress, user?.wallet?.address, publicClient])

  // Fetch balance on mount and when user changes
  useEffect(() => {
    if (authenticated && user?.wallet?.address) {
      fetchTokenBalance()
    }
  }, [authenticated, user?.wallet?.address, fetchTokenBalance])

  const {
    isLoading,
    isBurning,
    isSwapping,
    executeBurn
  } = useOperations({
    context,
    contractAddress,
    tokenId,
    tokenType,
    tbaAddress,
    pricePerToken,
    primaryMintActive
  })

  // Determine button availability based on variant
  const buttonConfig = useMemo(() => {
    const isERC1155 = (tokenType as string) === 'erc1155'
    const hasBalance = tokenBalance && tokenBalance > BigInt(0)
    
    return {
      buy: {
        available: true,
        disabled: isLoading,
        text: isERC1155 ? 'ensure' : 'buy',
        tooltip: getTooltipText('buy')
      },
      swap: {
        available: !isERC1155 && showSwap,
        disabled: !SWAP_ENABLED || isSwapping || !hasBalance,
        text: 'swap',
        tooltip: SWAP_ENABLED ? getTooltipText('swap') : 'coming soon'
      },
      send: {
        available: showSend,
        disabled: isLoading || !hasBalance,
        text: 'send',
        tooltip: getTooltipText('send')
      },
      burn: {
        available: showBurn,
        disabled: !BURN_ENABLED || isBurning || !hasBalance,
        text: 'burn',
        tooltip: BURN_ENABLED ? getTooltipText('burn') : 'coming soon'
      }
    }
  }, [tokenType, tokenBalance, isLoading, isSwapping, isBurning, showSwap, showSend, showBurn])

  const handleOpenModal = (operation: Operation) => {
    setCurrentOperation(operation)
    setModalOpen(true)
  }

  const handleCloseModal = () => {
    setModalOpen(false)
    setCurrentOperation(null)
  }

  const handleRefreshBalance = () => {
    fetchTokenBalance()
    onRefreshBalance?.()
  }

  // Don't render if not authenticated for tokenbound context
  if (context === 'tokenbound' && !authenticated) {
    return null
  }

  const iconSize = variant === 'page' ? 'w-10 h-10' : 'w-6 h-6'

  return (
    <>
      <div className="flex flex-col items-center gap-2">
        <div className={cn(
          "flex gap-8",
          className
        )}>
          {/* Ensure (buy) button - green */}
          {buttonConfig.buy.available && (
            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger asChild>
                  <button
                    onClick={() => handleOpenModal('buy')}
                    className="flex items-center gap-2 text-gray-300 hover:text-gray-100 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                    disabled={buttonConfig.buy.disabled}
                  >
                    <PlusCircle className={`${iconSize} stroke-[1.5] stroke-green-500 hover:stroke-green-400 transition-colors`} />
                  </button>
                </TooltipTrigger>
                <TooltipContent>
                  <p>{buttonConfig.buy.tooltip}</p>
                </TooltipContent>
              </Tooltip>
            </TooltipProvider>
          )}

          {/* Transform (swap) button - blue */}
          {buttonConfig.swap.available && (
            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger asChild>
                  <button
                    onClick={() => !buttonConfig.swap.disabled && handleOpenModal('swap')}
                    className={cn(
                      "flex items-center gap-2 transition-colors",
                      buttonConfig.swap.disabled 
                        ? "text-gray-600 cursor-not-allowed opacity-50" 
                        : "text-gray-300 hover:text-gray-100"
                    )}
                    disabled={buttonConfig.swap.disabled}
                  >
                    <RefreshCw className={cn(
                      `${iconSize} stroke-[1.5] transition-colors`,
                      buttonConfig.swap.disabled 
                        ? "stroke-gray-600" 
                        : "stroke-blue-500 hover:stroke-blue-400"
                    )} />
                  </button>
                </TooltipTrigger>
                <TooltipContent>
                  <p>{buttonConfig.swap.tooltip}</p>
                </TooltipContent>
              </Tooltip>
            </TooltipProvider>
          )}

          {/* Send button - amber */}
          {buttonConfig.send.available && (
            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger asChild>
                  <button
                    onClick={() => handleOpenModal('send')}
                    className="flex items-center gap-2 text-gray-300 hover:text-gray-100 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                    disabled={buttonConfig.send.disabled}
                  >
                    <Send className={`${iconSize} stroke-[1.5] stroke-amber-500 hover:stroke-amber-400 transition-colors`} />
                  </button>
                </TooltipTrigger>
                <TooltipContent>
                  <p>{buttonConfig.send.tooltip}</p>
                </TooltipContent>
              </Tooltip>
            </TooltipProvider>
          )}

          {/* Burn button - orange */}
          {buttonConfig.burn.available && (
            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger asChild>
                  <button
                    onClick={() => !buttonConfig.burn.disabled && handleOpenModal('burn')}
                    className={cn(
                      "flex items-center gap-2 transition-colors",
                      buttonConfig.burn.disabled 
                        ? "text-gray-600 cursor-not-allowed opacity-50" 
                        : "text-gray-300 hover:text-gray-100"
                    )}
                    disabled={buttonConfig.burn.disabled}
                  >
                    <Flame className={cn(
                      `${iconSize} stroke-[1.5] transition-colors`,
                      buttonConfig.burn.disabled 
                        ? "stroke-gray-600" 
                        : "stroke-orange-500 hover:stroke-orange-400"
                    )} />
                  </button>
                </TooltipTrigger>
                <TooltipContent>
                  <p>{buttonConfig.burn.tooltip}</p>
                </TooltipContent>
              </Tooltip>
            </TooltipProvider>
          )}
        </div>

        {/* Balance display - only show on page variant */}
        {variant === 'page' && (
          <div className="text-sm text-gray-400 text-center">
            balance: {!authenticated ? 'connect to see balance' : tokenBalance ? formatBalance(tokenBalance, tokenType, 18) : '0'}
          </div>
        )}
      </div>

      {/* Buy Modal */}
      <BuyModal
        isOpen={modalOpen && currentOperation === 'buy'}
        onClose={handleCloseModal}
        tokenSymbol={tokenSymbol}
        tokenName={tokenName}
        imageUrl={imageUrl}
        context={context}
        tokenType={tokenType}
        contractAddress={contractAddress}
        tokenId={tokenId}
        tbaAddress={tbaAddress}
        pricePerToken={pricePerToken}
        primaryMintActive={primaryMintActive}
        onRefreshBalance={handleRefreshBalance}
      />

      {/* Swap Modal */}
      <SwapModal
        isOpen={modalOpen && currentOperation === 'swap'}
        onClose={handleCloseModal}
        tokenSymbol={tokenSymbol}
        tokenName={tokenName}
        imageUrl={imageUrl}
        context={context}
        tokenType={tokenType}
        contractAddress={contractAddress}
        tokenId={tokenId}
        tbaAddress={tbaAddress}
        pricePerToken={pricePerToken}
        primaryMintActive={primaryMintActive}
        onRefreshBalance={handleRefreshBalance}
      />

      {/* Send Modal */}
      <SendModal
        isOpen={modalOpen && currentOperation === 'send'}
        onClose={handleCloseModal}
        tokenSymbol={tokenSymbol}
        tokenName={tokenName}
        imageUrl={imageUrl}
        context={context}
        tokenType={tokenType}
        contractAddress={contractAddress}
        tokenId={tokenId}
        tbaAddress={tbaAddress}
        onRefreshBalance={handleRefreshBalance}
      />

      {/* Burn Modal */}
      <BurnModal
        isOpen={modalOpen && currentOperation === 'burn'}
        onClose={handleCloseModal}
        tokenSymbol={tokenSymbol}
        tokenName={tokenName}
        imageUrl={imageUrl}
        context={context}
        tokenType={tokenType}
        contractAddress={contractAddress}
        tokenId={tokenId}
        tbaAddress={tbaAddress}
        pricePerToken={pricePerToken}
        primaryMintActive={primaryMintActive}
        onRefreshBalance={handleRefreshBalance}
      />
    </>
  )
}
````

## File: src/modules/ensure/buttons/index.ts
````typescript
// Detailed component for single pages (with balance fetching)
export { default as EnsureButtons } from './EnsureButtonsDetails'

// Lightweight component for grids/lists (no balance fetching)
export { default as EnsureButtonsLite } from './EnsureButtons'

// More explicit naming exports
export { default as EnsureButtonsDetails } from './EnsureButtonsDetails'
export { default as EnsureButtonsGrid } from './EnsureButtons'

// Default export is the detailed version
export { default } from './EnsureButtonsDetails'

// Export new simplified hooks
export { useOperations } from './hooks/useOperations'

// Export operation functions
export { getTokenOperations } from './operations'

// Export types
export * from './types'

// Export accounts
export * from './accounts'

// Export individual modals for custom implementations
export { BuyModal } from './modals/buy'
export { SendModal } from './modals/send'
````

## File: src/modules/ensure/buttons/types.ts
````typescript
import type { Address } from 'viem'

export type TokenType = 'native' | 'erc20' | 'erc721' | 'erc1155'
export type Operation = 'buy' | 'swap' | 'send' | 'burn'
export type ButtonContext = 'general' | 'specific' | 'tokenbound' | 'operator'

// Legacy type alias for backwards compatibility
export type OperationType = Operation

export interface TokenInfo {
  symbol: string
  address: Address
  decimals: number
  balance?: string
  type?: 'native' | 'currency' | 'certificate'
  imageUrl?: string
}

export interface AccountSearchResult {
  full_account_name: string
  token_id: number
  is_agent: boolean
  group_name: string
  tba_address?: string
  // Special fields for display in search
  name?: string // Will be set to full_account_name for compatibility
  type?: 'account' | 'operator'
  path?: string // For compatibility with existing search
}

export interface EnsureButtonsProps {
  // Core token info
  contractAddress: Address
  tokenId?: string
  tokenType?: TokenType
  
  // Button config
  showMinus?: boolean
  showBurn?: boolean
  showSend?: boolean
  showSwap?: boolean
  size?: 'sm' | 'md' | 'lg'
  variant?: 'grid' | 'list' | 'page'
  
  // Display options
  imageUrl?: string
  showBalance?: boolean
  tokenName?: string
  tokenSymbol?: string
  
  // Context-specific props
  context: ButtonContext
  tbaAddress?: Address
  isOwner?: boolean
  isDeployed?: boolean
  
  // Balance data (for portfolio integration)
  initialBalance?: string
  
  // Specific token props (ERC1155)
  maxSupply?: bigint
  totalMinted?: bigint
  pricePerToken?: bigint
  primaryMintActive?: boolean
}

export interface OperationParams {
  amount?: string
  recipient?: string
  selectedToken?: TokenInfo
  selectedAccount?: AccountSearchResult
}

export interface TransactionResult {
  success: boolean
  txHash?: string
  error?: string
}

export interface BalanceInfo {
  raw: string
  formatted: string
  symbol: string
  decimals: number
}

export interface QuoteResult {
  estimatedOutput: string
  isLoading: boolean
  liquidityAvailable: boolean
  error?: string
}

// New types for ERC1155/USDC operations
export interface UsdcOperationData {
  totalPrice: bigint
  quantity: bigint
  needsApproval: boolean
  userBalance: bigint
  pricePerToken: bigint
}

export interface ERC1155BalanceInfo {
  tokenBalance: bigint
  usdcBalance: bigint
  formattedTokenBalance: string
  formattedUsdcBalance: string 
}

// Constants for specific contract operations
export const SPECIFIC_CONTRACTS = {
  specific: '0x7DFaa8f8E2aA32b6C2112213B395b4C9889580dd' as Address,
  usdc: '0x833589fcd6edb6e08f4c7c32d4f71b54bda02913' as Address,
  erc20Minter: '0x777777e8850d8d6d98de2b5f64fae401f96eff31' as Address,
  mintReferral: '0x3CeDe7eae1feA81b4AEFf1f348f7497e6794ff96' as Address,
  proceeds: '0xa187F8CBdd36D63967c33f5BD4dD4B9ECA51270e' as Address
} as const
````

## File: src/modules/ensure/EnsureGrid.tsx
````typescript
'use client'

import { useState, useEffect, useMemo, useCallback } from 'react'
import Link from 'next/link'
import Image from 'next/image'
import { Card, CardContent } from "@/components/ui/card"
import { Skeleton } from "@/components/ui/skeleton"
import { Button } from "@/components/ui/button"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { ArrowUpDown, PlusCircle } from 'lucide-react'
import { getContractTokens, type TokenDisplayInfo } from '@/modules/specific/collect'
import { CONTRACTS } from '@/modules/specific/config'
import AccountImage from '@/modules/accounts/AccountImage'
import { cn } from '@/lib/utils'
import { useEnsureData, Certificate } from '@/hooks/useEnsureData'

interface EnsureGridProps {
  searchQuery?: string
  urlPrefix?: string
  onDataChange?: (data: Certificate[]) => void
  types?: ('general' | 'specific' | 'syndicate' | 'account' | 'group')[]
  variant?: 'default' | 'home'
}

const FALLBACK_IMAGE = '/assets/no-image-found.png'

// Helper function to check if item is natural capital
const isNaturalCapital = (item: Certificate) => {
  if (item.type === 'account') {
    return item.group_name === '.ensurance'
  }
  if (item.type === 'group') {
    return item.group_name === '.ensurance'
  }
  return false
}

// Convert IPFS URL to use a gateway
const convertIpfsUrl = (url: string) => {
  if (!url) return FALLBACK_IMAGE
  if (url.startsWith('ipfs://')) {
    return url.replace('ipfs://', 'https://magic.decentralized-content.com/ipfs/')
  }
  return url
}

// Status dot component for specific certificates
const StatusDot = ({ active }: { active: boolean }) => {
  return (
    <span className={`w-2 h-2 rounded-full relative after:content-[''] after:absolute after:inset-0 after:rounded-full after:animate-pulse ${
      active 
        ? "bg-green-500 after:bg-green-500/50" 
        : "bg-red-500 after:bg-red-500/50"
    }`} />
  )
}

const ITEMS_PER_PAGE = 12

type SortField = 'general' | 'specific' | 'syndicate' | 'account' | 'group'

interface SortConfig {
  field: SortField
}

const SORT_CYCLES: SortField[] = ['general', 'specific', 'syndicate', 'account', 'group']

export default function EnsureGrid({ 
  searchQuery = '',
  urlPrefix = '',
  onDataChange,
  types = ['general', 'specific', 'syndicate', 'account', 'group'],
  variant = 'default'
}: EnsureGridProps) {
  // Use the new hook for data
  const { items, loading, error, tokenMetadata } = useEnsureData({ waitForAll: false })
  const [page, setPage] = useState(1)
  const [selectedTypes, setSelectedTypes] = useState<typeof types>(types)
  const [sort, setSort] = useState<SortConfig>({ field: 'general' })

  const filterOptions = [
    { value: 'all', label: 'all' },
    { value: 'general', label: 'general' },
    { value: 'specific', label: 'specific' },
    { value: 'syndicate', label: 'syndicate' },
    { value: 'account', label: 'account' },
    { value: 'group', label: 'group' }
  ]

  // Reset page when search changes
  useEffect(() => {
    setPage(1)
  }, [searchQuery])

  const handleSortClick = () => {
    const fields = SORT_CYCLES
    const currentIndex = fields.indexOf(sort.field)
    
    // Move to next field, or back to first if at end
    const nextField = fields[(currentIndex + 1) % fields.length]
    
    setSort({
      field: nextField
    })
  }

  const getSortLabel = () => {
    const labels = {
      general: 'Show general certificates',
      specific: 'Show specific certificates',
      syndicate: 'Show syndicates',
      account: 'Show accounts',
      group: 'Show groups'
    }
    return labels[sort.field]
  }

  // Memoize filtered items
  const filteredItems = useMemo(() => {
    let filtered = items.filter(item => selectedTypes.includes(item.type))
    
    if (!searchQuery) return filtered
    
    const searchLower = searchQuery.toLowerCase()
    return filtered.filter(item => {
      if (item.type === 'general') {
        return (
          item.name?.toLowerCase().includes(searchLower) ||
          item.description?.toLowerCase().includes(searchLower)
        )
      } else if (item.type === 'specific') {
        const metadata = tokenMetadata[item.tokenURI]
        if (!metadata || metadata.error) return false
        return (
          metadata.name?.toLowerCase().includes(searchLower) ||
          metadata.description?.toLowerCase().includes(searchLower)
        )
      } else if (item.type === 'account') {
        return (
          item.full_account_name?.toLowerCase().includes(searchLower) ||
          item.description?.toLowerCase().includes(searchLower)
        )
      } else if (item.type === 'group') {
        return (
          item.group_name.toLowerCase().includes(searchLower) ||
          (item.name_front?.toLowerCase().includes(searchLower)) ||
          (item.tagline?.toLowerCase().includes(searchLower)) ||
          (item.description?.toLowerCase().includes(searchLower))
        )
      } else if (item.type === 'syndicate') {
        return (
          item.name?.toLowerCase().includes(searchLower) ||
          item.description?.toLowerCase().includes(searchLower)
        )
      }
      return false
    })
  }, [items, searchQuery, tokenMetadata, selectedTypes])

  // Sort filtered items
  const sortedItems = useMemo(() => {
    return [...filteredItems].sort((a, b) => {
      // Filter to show only the selected type
      return a.type === sort.field ? -1 : b.type === sort.field ? 1 : 0
    })
  }, [filteredItems, sort])

  // Memoize displayed items
  const displayedItems = useMemo(() => {
    return sortedItems.slice(0, page * ITEMS_PER_PAGE)
  }, [sortedItems, page])

  // Load more items
  const loadMore = useCallback(() => {
    if (displayedItems.length < sortedItems.length) {
      setPage(p => p + 1)
    }
  }, [displayedItems.length, sortedItems.length])

  // Handle scroll-based loading
  useEffect(() => {
    const handleScroll = () => {
      if (loading || displayedItems.length >= sortedItems.length) return;
      
      const scrolledToBottom = 
        window.innerHeight + window.scrollY >= 
        document.documentElement.scrollHeight - 1000;

      if (scrolledToBottom) {
        loadMore();
      }
    };

    window.addEventListener('scroll', handleScroll);
    return () => window.removeEventListener('scroll', handleScroll);
  }, [loading, loadMore, displayedItems.length, sortedItems.length]);

  if (items.length === 0 && loading) {
    return (
      <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
        {[...Array(8)].map((_, index) => (
          <Card key={`skeleton-${index}`} className="bg-primary-dark border-gray-800">
            <CardContent className="p-4">
              <Skeleton className="h-48 w-full mb-4 bg-gray-800" />
              <Skeleton className="h-4 w-3/4 mb-2 bg-gray-800" />
            </CardContent>
          </Card>
        ))}
      </div>
    )
  }

  if (error) {
    return (
      <div className="text-center py-8">
        <p className="text-red-500">{error}</p>
      </div>
    )
  }

  if (sortedItems.length === 0) {
    return (
      <div className="text-center py-8">
        <p className="text-lg text-gray-600 dark:text-gray-400">
          No items found{searchQuery ? ' matching your search' : ''}.
        </p>
      </div>
    )
  }

  return (
    <div className="space-y-6">
      {/* Controls Bar - Only show in default variant */}
      {variant === 'default' && (
        <div className="flex items-center justify-end gap-2">
          <button
            onClick={handleSortClick}
            className="bg-gray-900/30 p-1.5 rounded-lg text-gray-400 hover:text-white transition-colors"
            title={getSortLabel()}
          >
            <ArrowUpDown className="w-5 h-5" />
          </button>

          <Select 
            value={selectedTypes.length === 1 ? selectedTypes[0] : 'all'} 
            onValueChange={(value) => {
              if (value === 'all') {
                setSelectedTypes(['general', 'specific', 'syndicate', 'account', 'group'])
              } else {
                setSelectedTypes([value as typeof types[0]])
              }
            }}
          >
            <SelectTrigger className="text-xl font-medium bg-transparent border-0 hover:bg-transparent focus:ring-0 focus:ring-offset-0 focus-visible:ring-0 focus-visible:ring-offset-0 focus:outline-none pl-0 pr-2 h-auto w-auto">
              <SelectValue placeholder="all" />
            </SelectTrigger>
            <SelectContent className="bg-[#000] border-gray-800">
              {filterOptions.map((option) => (
                <SelectItem
                  key={option.value}
                  value={option.value}
                  className="text-white hover:bg-[#111] focus:bg-[#111] cursor-pointer"
                >
                  {option.label}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        </div>
      )}

      <div className={cn(
        "grid gap-6",
        variant === 'default' ? "grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4" : "grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6"
      )}>
        {displayedItems.map((item) => {
          if (item.type === 'general') {
            return (
              <Link 
                key={item.contract_address} 
                href={`${urlPrefix}/general/${item.contract_address}`}
                className="block"
              >
                <Card className={cn(
                  "bg-primary-dark border-gray-800 hover:border-gray-700 transition-colors",
                  variant === 'home' && "hover:scale-105"
                )}>
                  <CardContent className={cn(
                    "p-4",
                    variant === 'home' && "p-2"
                  )}>
                    <div className="flex flex-col gap-4">
                      <div className="relative w-full aspect-square rounded-lg overflow-hidden bg-black/20">
                        <Image
                          src={item.image_url || FALLBACK_IMAGE}
                          alt={item.name || 'Certificate'}
                          fill
                          sizes="(max-width: 640px) 100vw, (max-width: 768px) 50vw, (max-width: 1024px) 33vw, 25vw"
                          priority={false}
                          loading="lazy"
                          className="object-cover"
                          unoptimized={item.image_url?.toLowerCase?.()?.endsWith('.gif') || false}
                          onError={(e) => {
                            const img = e.target as HTMLImageElement;
                            img.src = FALLBACK_IMAGE;
                          }}
                        />
                        <div className={cn(
                          "absolute top-2 right-2 backdrop-blur-sm px-2.5 py-1 rounded-full text-xs font-medium tracking-wide",
                          isNaturalCapital(item) 
                            ? "bg-gradient-to-r from-amber-300 via-yellow-500 to-amber-600 text-black"
                            : "bg-black/60 text-white/90"
                        )}>
                          {isNaturalCapital(item) ? 'natural capital' : 'general'}
                        </div>
                      </div>
                      <div className={cn(
                        "text-center line-clamp-2",
                        variant === 'home' ? "text-sm font-medium text-white/90 mt-1" : "text-lg font-semibold text-white"
                      )}>
                        {item.name || 'Unnamed Certificate'}
                      </div>
                      {variant === 'default' && (
                        <button className="w-full flex justify-center items-center py-2">
                          <PlusCircle className="w-7 h-7 stroke-[1.5] stroke-green-500 hover:stroke-green-400 transition-colors" />
                        </button>
                      )}
                    </div>
                  </CardContent>
                </Card>
              </Link>
            )
          } else if (item.type === 'specific') {
            const metadata = tokenMetadata[item.tokenURI]
            const metadataError = metadata?.error
            let imageUrl = FALLBACK_IMAGE

            if (metadata && !metadataError && metadata.image) {
              imageUrl = convertIpfsUrl(metadata.image)
            }

            return (
              <Link 
                key={item.tokenURI} 
                href={`${urlPrefix}/specific/${CONTRACTS.specific}/${item.tokenURI.split('/').pop()}`}
                className="block"
              >
                <Card className={cn(
                  "bg-primary-dark border-gray-800 hover:border-gray-700 transition-colors",
                  variant === 'home' && "hover:scale-105"
                )}>
                  <CardContent className={cn(
                    "p-4",
                    variant === 'home' && "p-2"
                  )}>
                    <div className="flex flex-col gap-4">
                      <div className="relative w-full aspect-square rounded-lg overflow-hidden bg-black/20">
                        <Image
                          src={imageUrl}
                          alt={metadata?.name || 'Token'}
                          fill
                          sizes="(max-width: 640px) 100vw, (max-width: 768px) 50vw, (max-width: 1024px) 33vw, 25vw"
                          className="object-cover"
                          unoptimized={imageUrl?.toLowerCase?.()?.endsWith('.gif') || false}
                          onError={(e: any) => {
                            e.target.src = FALLBACK_IMAGE
                          }}
                        />
                        <div className={cn(
                          "absolute top-2 right-2 backdrop-blur-sm px-2.5 py-1 rounded-full text-xs font-medium tracking-wide",
                          isNaturalCapital(item) 
                            ? "bg-gradient-to-r from-amber-300 via-yellow-500 to-amber-600 text-black"
                            : "bg-black/60 text-white/90"
                        )}>
                          {isNaturalCapital(item) ? 'natural capital' : 'specific'}
                        </div>
                      </div>
                      <div className={cn(
                        "text-center line-clamp-2",
                        variant === 'home' ? "text-sm font-medium text-white/90 mt-1" : "text-lg font-semibold text-white"
                      )}>
                        {metadata && !metadataError ? metadata.name || 'Unnamed Token' : 'Unnamed Token'}
                      </div>
                      {variant === 'default' && (
                        <button className="w-full flex justify-center items-center py-2">
                          <PlusCircle className="w-7 h-7 stroke-[1.5] stroke-green-500 hover:stroke-green-400 transition-colors" />
                        </button>
                      )}
                    </div>
                  </CardContent>
                </Card>
              </Link>
            )
          } else if (item.type === 'account') {
            return (
              <Link 
                key={item.full_account_name} 
                href={`${urlPrefix}/${item.full_account_name}`}
                className="block"
              >
                <Card className={cn(
                  "bg-primary-dark border-gray-800 hover:border-gray-700 transition-colors",
                  variant === 'home' && "hover:scale-105"
                )}>
                  <CardContent className={cn(
                    "p-4",
                    variant === 'home' && "p-2"
                  )}>
                    <div className="flex flex-col gap-4">
                      <div className="relative w-full aspect-square rounded-lg overflow-hidden bg-black/20">
                        <div className="w-full h-full flex items-center justify-center">
                          <AccountImage
                            tokenId={item.token_id}
                            groupName={item.group_name?.replace('.', '')}
                            className="w-full h-full object-cover"
                          />
                        </div>
                        <div className={cn(
                          "absolute top-2 right-2 backdrop-blur-sm px-2.5 py-1 rounded-full text-xs font-medium tracking-wide",
                          isNaturalCapital(item) 
                            ? "bg-gradient-to-r from-amber-300 via-yellow-500 to-amber-600 text-black"
                            : "bg-black/60 text-white/90"
                        )}>
                          {isNaturalCapital(item) ? 'natural capital' : 'account'}
                        </div>
                      </div>
                      <div className={cn(
                        "text-center line-clamp-2",
                        variant === 'home' ? "text-sm font-medium text-white/90 mt-1" : "text-lg font-semibold text-white"
                      )}>
                        {item.full_account_name}
                      </div>
                      {variant === 'default' && (
                        <button className="w-full flex justify-center items-center py-2">
                          <PlusCircle className="w-7 h-7 stroke-[1.5] stroke-green-500 hover:stroke-green-400 transition-colors" />
                        </button>
                      )}
                    </div>
                  </CardContent>
                </Card>
              </Link>
            )
          } else if (item.type === 'group') {
            return (
              <Link 
                key={item.contract_address} 
                href={`${urlPrefix}/groups/${item.group_name.replace(/^\./, '')}/all`}
                className="block"
              >
                <Card className={cn(
                  "bg-primary-dark border-gray-800 hover:border-gray-700 transition-colors",
                  variant === 'home' && "hover:scale-105"
                )}>
                  <CardContent className={cn(
                    "p-4",
                    variant === 'home' && "p-2"
                  )}>
                    <div className="flex flex-col gap-4">
                      <div className="relative w-full aspect-square rounded-lg overflow-hidden bg-black/20">
                        <Image
                          src={`/groups/orbs/${item.group_name.replace(/^\./, '')}-orb.png`}
                          alt={`${item.group_name} orb`}
                          fill
                          sizes="(max-width: 640px) 100vw, (max-width: 768px) 50vw, (max-width: 1024px) 33vw, 25vw"
                          className="object-cover"
                          onError={(e: any) => {
                            e.target.src = FALLBACK_IMAGE
                          }}
                        />
                        <div className={cn(
                          "absolute top-2 right-2 backdrop-blur-sm px-2.5 py-1 rounded-full text-xs font-medium tracking-wide",
                          isNaturalCapital(item) 
                            ? "bg-gradient-to-r from-amber-300 via-yellow-500 to-amber-600 text-black"
                            : "bg-black/60 text-white/90"
                        )}>
                          {isNaturalCapital(item) ? 'natural capital' : 'group'}
                        </div>
                      </div>
                      <div className={cn(
                        "text-center line-clamp-2",
                        variant === 'home' ? "text-sm font-medium text-white/90 mt-1" : "text-lg font-semibold text-white"
                      )}>
                        {item.group_name}
                      </div>
                      {variant === 'default' && (
                        <button className="w-full flex justify-center items-center py-2">
                          <PlusCircle className="w-7 h-7 stroke-[1.5] stroke-green-500 hover:stroke-green-400 transition-colors" />
                        </button>
                      )}
                    </div>
                  </CardContent>
                </Card>
              </Link>
            )
          } else {
            return (
              <Link 
                key={item.name} 
                href={`${urlPrefix}/syndicates/${item.name.toLowerCase().replace(/\s+/g, '-')}`}
                className="block"
              >
                <Card className={cn(
                  "bg-primary-dark border-gray-800 hover:border-gray-700 transition-colors",
                  variant === 'home' && "hover:scale-105"
                )}>
                  <CardContent className={cn(
                    "p-4",
                    variant === 'home' && "p-2"
                  )}>
                    <div className="flex flex-col gap-4">
                      <div className="relative w-full aspect-square rounded-lg overflow-hidden bg-black/20">
                        <Image
                          src={item.media?.banner || item.image_url || FALLBACK_IMAGE}
                          alt={item.name}
                          fill
                          sizes="(max-width: 640px) 100vw, (max-width: 768px) 50vw, (max-width: 1024px) 33vw, 25vw"
                          className="object-cover"
                          onError={(e: any) => {
                            e.target.src = FALLBACK_IMAGE
                          }}
                        />
                        <div className={cn(
                          "absolute top-2 right-2 backdrop-blur-sm px-2.5 py-1 rounded-full text-xs font-medium tracking-wide",
                          isNaturalCapital(item) 
                            ? "bg-gradient-to-r from-amber-300 via-yellow-500 to-amber-600 text-black"
                            : "bg-black/60 text-white/90"
                        )}>
                          {isNaturalCapital(item) ? 'natural capital' : 'syndicate'}
                        </div>
                      </div>
                      <div className={cn(
                        "text-center line-clamp-2",
                        variant === 'home' ? "text-sm font-medium text-white/90 mt-1" : "text-lg font-semibold text-white"
                      )}>
                        {item.name}
                      </div>
                      {variant === 'default' && (
                        <button className="w-full flex justify-center items-center py-2">
                          <PlusCircle className="w-7 h-7 stroke-[1.5] stroke-green-500 hover:stroke-green-400 transition-colors" />
                        </button>
                      )}
                    </div>
                  </CardContent>
                </Card>
              </Link>
            )
          }
        })}
      </div>
      {variant === 'default' && displayedItems.length < sortedItems.length && (
        <div className="flex justify-center py-4">
          <Button 
            onClick={loadMore}
            variant="outline"
            className="bg-black/20 hover:bg-black/30"
          >
            Load More
          </Button>
        </div>
      )}
    </div>
  )
}
````

## File: src/modules/ensure/EnsureMagnet.tsx
````typescript
'use client'

import { useState, useEffect, useRef, forwardRef, useMemo } from 'react'
import { motion, AnimatePresence } from 'framer-motion'
import { cn } from '@/lib/utils'
import AccountImage from '@/modules/accounts/AccountImage'
import { MagnetSearch } from './MagnetSearch'
import { EnsureTooltip } from './EnsureTooltip'
import { CONTRACTS } from '@/modules/specific/config'
import { useRouter } from 'next/navigation'

const FALLBACK_IMAGE = '/assets/no-image-found.png'

// Maximum number of search results to display
const MAX_SEARCH_RESULTS = 48

// Types for the API response
interface GeneralCertificate {
  contract_address: string
  name: string
  description?: string
  image_url?: string
  type: 'general'
}

interface SpecificCertificate {
  tokenURI: string
  type: 'specific'
}

interface Account {
  full_account_name: string
  token_id: number
  group_name: string
  is_agent: boolean
  description?: string
  type: 'account'
}

interface Group {
  group_name: string
  name_front: string | null
  tagline: string | null
  description?: string
  type: 'group'
}

interface Syndicate {
  name: string
  description?: string
  media?: {
    banner?: string
  }
  image_url?: string
  type: 'syndicate'
}

type Certificate = GeneralCertificate | SpecificCertificate | Account | Group | Syndicate

interface SwarmOrb {
  id: string
  item: Certificate
  x: number
  y: number
  targetX: number
  targetY: number
  vx: number
  vy: number
  opacity: number
  scale: number
  entryPhase: 'waiting' | 'entering' | 'positioning' | 'settled'
  entryDelay: number
  avoidanceRadius: number
}

// Helper function to score search relevance
function scoreSearchResult(item: Certificate, searchLower: string, tokenMetadata: any): number {
  let score = 0;
  
  if (item.type === 'general') {
    // Exact name match gets highest score
    if (item.name?.toLowerCase() === searchLower) score += 100;
    // Name contains search gets high score
    if (item.name?.toLowerCase().includes(searchLower)) score += 50;
    // Description contains search gets medium score
    if (item.description?.toLowerCase().includes(searchLower)) {
      score += 40;
      // Bonus for description match at start of words
      const words = item.description.toLowerCase().split(/\s+/);
      if (words.some(word => word.startsWith(searchLower))) {
        score += 10;
      }
    }
  } 
  else if (item.type === 'specific') {
    const meta = tokenMetadata[item.tokenURI];
    if (!meta || meta.error) return 0;
    if (meta.name?.toLowerCase() === searchLower) score += 100;
    if (meta.name?.toLowerCase().includes(searchLower)) score += 50;
    if (meta.description?.toLowerCase().includes(searchLower)) score += 25;
  }
  else if (item.type === 'account') {
    if (item.full_account_name?.toLowerCase() === searchLower) score += 100;
    if (item.full_account_name?.toLowerCase().includes(searchLower)) score += 50;
    if (item.description?.toLowerCase().includes(searchLower)) score += 25;
  }
  else if (item.type === 'group') {
    if (item.group_name.toLowerCase() === searchLower) score += 100;
    if (item.group_name.toLowerCase().includes(searchLower)) score += 50;
    if (item.name_front?.toLowerCase().includes(searchLower)) score += 40;
    if (item.tagline?.toLowerCase().includes(searchLower)) score += 30;
    if (item.description?.toLowerCase().includes(searchLower)) score += 25;
  }
  else if (item.type === 'syndicate') {
    if (item.name?.toLowerCase() === searchLower) score += 100;
    if (item.name?.toLowerCase().includes(searchLower)) score += 50;
    if (item.description?.toLowerCase().includes(searchLower)) score += 25;
  }

  // Boost natural capital items
  if (isNaturalCapital(item)) score += 20;

  return score;
}

// Calculate entry point from closest viewport edge to target
function calculateEntryPoint(targetX: number, targetY: number, viewport: { width: number, height: number }) {
  const buffer = 100
  const edges = [
    { x: targetX, y: -buffer, distance: targetY + buffer }, // top
    { x: viewport.width + buffer, y: targetY, distance: viewport.width + buffer - targetX }, // right
    { x: targetX, y: viewport.height + buffer, distance: viewport.height + buffer - targetY }, // bottom
    { x: -buffer, y: targetY, distance: targetX + buffer } // left
  ]
  
  // Find closest edge
  const closestEdge = edges.reduce((min, edge) => 
    edge.distance < min.distance ? edge : min
  )
  
  return { x: closestEdge.x, y: closestEdge.y }
}

// Generate coordinated target positions around search phrase
function generateSwarmPositions(count: number, centerX: number, centerY: number) {
  const positions = []
  const baseRadius = 200 // Increased for larger orbs
  
  for (let i = 0; i < count; i++) {
    // Calculate which layer this item belongs to
    let layer = 0
    let itemsInPreviousLayers = 0
    let itemsInCurrentLayer = 8
    
    while (itemsInPreviousLayers + itemsInCurrentLayer <= i) {
      itemsInPreviousLayers += itemsInCurrentLayer
      layer++
      itemsInCurrentLayer = 6 + layer * 3 // Each layer has more items
    }
    
    const indexInLayer = i - itemsInPreviousLayers
    const angleStep = (2 * Math.PI) / itemsInCurrentLayer
    
    const radius = baseRadius + (layer * 80) // More spacing between layers
    const angle = angleStep * indexInLayer + (layer * 0.3) // Offset each layer slightly
    
    // Add natural variation
    const variation = 25 // Slightly more variation for larger orbs
    const x = centerX + Math.cos(angle) * radius + (Math.random() - 0.5) * variation
    const y = centerY + Math.sin(angle) * radius + (Math.random() - 0.5) * variation
    
    positions.push({ x, y })
  }
  
  return positions
}

// Import or copy convertIpfsUrl
const convertIpfsUrl = (url: string) => {
  if (!url) return undefined
  if (url.startsWith('ipfs://')) {
    return url.replace('ipfs://', 'https://magic.decentralized-content.com/ipfs/')
  }
  return url
}

// Helper: get image for any item
function getItemImage(item: any, tokenMetadata: any) {
  if (item.type === 'general') return convertIpfsUrl(item.image_url)
  if (item.type === 'specific') {
    const meta = tokenMetadata[item.tokenURI]
    return meta && !meta.error && meta.image ? convertIpfsUrl(meta.image) : undefined
  }
  if (item.type === 'syndicate') return convertIpfsUrl(item.media?.banner || item.image_url)
  if (item.type === 'group') return `/groups/orbs/${item.group_name.replace(/^\./, '')}-orb.png`
  if (item.type === 'account') return undefined
  return undefined
}

// Helper function to check if item is natural capital
const isNaturalCapital = (item: any) => {
  if (item.type === 'account') {
    return item.group_name === '.ensurance'
  }
  if (item.type === 'group') {
    return item.group_name === '.ensurance'
  }
  return false
}

// MagnetImage handles fallback
const MagnetImage = forwardRef<HTMLImageElement, any>(({ src, alt, style, item, ...props }, ref) => {
  const [hasError, setHasError] = useState(false)
  const isNatural = isNaturalCapital(item)
  
  if (!src && !hasError) {
    return (
      <div 
        className="hover:scale-110 hover:brightness-110 transition-all duration-300 ease-out"
        style={{ 
          width: 80, 
          height: 80, 
          borderRadius: '50%', 
          background: '#222',
          boxShadow: isNatural 
            ? '0 0 20px rgba(255, 215, 0, 0.7), 0 0 40px rgba(255, 215, 0, 0.4), 0 4px 20px rgba(0, 0, 0, 0.3)'
            : '0 4px 20px rgba(0, 0, 0, 0.4), 0 2px 8px rgba(0, 0, 0, 0.2)',
          border: isNatural ? '2px solid rgba(255, 215, 0, 0.9)' : '1px solid rgba(255, 255, 255, 0.1)',
          transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
          ...style 
        }} 
      />
    )
  }
  return (
    <img
      ref={ref}
      src={hasError || !src ? FALLBACK_IMAGE : src}
      alt={alt}
      className="hover:scale-110 hover:brightness-110 transition-all duration-300 ease-out"
      style={{ 
        width: 80, 
        height: 80, 
        borderRadius: '50%', 
        objectFit: 'cover', 
        background: '#222',
        boxShadow: isNatural 
          ? '0 0 20px rgba(255, 215, 0, 0.7), 0 0 40px rgba(255, 215, 0, 0.4), 0 4px 20px rgba(0, 0, 0, 0.3)'
          : '0 4px 20px rgba(0, 0, 0, 0.4), 0 2px 8px rgba(0, 0, 0, 0.2)',
        border: isNatural ? '2px solid rgba(255, 215, 0, 0.9)' : '1px solid rgba(255, 255, 255, 0.1)',
        transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
        ...style 
      }}
      onError={() => setHasError(true)}
      {...props}
    />
  )
})

MagnetImage.displayName = 'MagnetImage'

// Helper: random offscreen position
function randomOffscreen(width: number, height: number) {
  const edge = Math.floor(Math.random() * 4)
  const buffer = 50
  switch (edge) {
    case 0: // top
      return { x: Math.random() * width, y: -buffer }
    case 1: // right
      return { x: width + buffer, y: Math.random() * height }
    case 2: // bottom
      return { x: Math.random() * width, y: height + buffer }
    case 3: // left
      return { x: -buffer, y: Math.random() * height }
    default:
      return { x: 0, y: 0 }
  }
}

// Helper: get a unique id for any item
function getItemId(item: Certificate) {
  switch (item.type) {
    case 'general':
      return 'general-' + item.contract_address
    case 'specific':
      return 'specific-' + item.tokenURI
    case 'syndicate':
      return 'syndicate-' + (item as any).name
    case 'group':
      return 'group-' + item.group_name
    case 'account':
      return 'account-' + (item as Account).full_account_name
    default:
      return 'unknown-' + Math.random().toString(36).slice(2)
  }
}

export function EnsureMagnet() {
  const router = useRouter()
  const [items, setItems] = useState<Certificate[]>([])
  const [tokenMetadata, setTokenMetadata] = useState<Record<string, any>>({})
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [searchQuery, setSearchQuery] = useState('')
  const [showTypewriter, setShowTypewriter] = useState(true)
  const [swarmOrbs, setSwarmOrbs] = useState<SwarmOrb[]>([])
  const [headingVisible, setHeadingVisible] = useState(true)
  const containerRef = useRef<HTMLDivElement>(null)

  // Track viewport size
  const [viewport, setViewport] = useState({ width: 1200, height: 800 })
  useEffect(() => {
    function update() {
      const newWidth = window.innerWidth
      const newHeight = window.innerHeight
      setViewport(prev => {
        if (prev.width !== newWidth || prev.height !== newHeight) {
          return { width: newWidth, height: newHeight }
        }
        return prev
      })
    }
    update()
    window.addEventListener('resize', update)
    return () => window.removeEventListener('resize', update)
  }, [])

  // Magnet zone: center on viewport
  const [magnetZone, setMagnetZone] = useState({ x: 0, y: 0 })
  const searchInputRef = useRef<HTMLInputElement>(null)

  useEffect(() => {
    function update() {
      const centerX = window.innerWidth / 2
      const centerY = window.innerHeight / 2
      setMagnetZone(prev => {
        if (prev.x !== centerX || prev.y !== centerY) {
          return { x: centerX, y: centerY }
        }
        return prev
      })
    }
    update()
    window.addEventListener('resize', update)
    return () => window.removeEventListener('resize', update)
  }, [])

  // Load basic data first for immediate search, then metadata progressively
  useEffect(() => {
    let mounted = true

    const fetchData = async () => {
      try {
        setLoading(true)
        setError(null)

        // First, fetch basic items without metadata for immediate search
        const basicResponse = await fetch('/api/ensure?metadata=false')
        if (!basicResponse.ok) {
          throw new Error(`HTTP ${basicResponse.status}: ${basicResponse.statusText}`)
        }

        const basicData = await basicResponse.json()
        if (basicData.error) {
          throw new Error(basicData.error)
        }

        if (mounted) {
          setItems(basicData.items || [])
          setLoading(false) // Items are ready, search can work now
        }

        // Then fetch metadata in background for richer search
        try {
          const metadataResponse = await fetch('/api/ensure?metadata=true')
          if (metadataResponse.ok) {
            const metadataData = await metadataResponse.json()
            if (!metadataData.error && mounted) {
              setTokenMetadata(metadataData.tokenMetadata || {})
            }
          }
        } catch (metadataErr) {
          console.warn('Failed to load metadata, search will work with basic data only:', metadataErr)
        }

      } catch (err) {
        console.error('Error fetching ensure data:', err)
        if (mounted) {
          setError(err instanceof Error ? err.message : 'Failed to load data')
          setLoading(false)
        }
      }
    }

    fetchData()
    return () => { mounted = false }
  }, [])

  // Filter items by search - memoized to prevent infinite re-renders
  const filtered = useMemo(() => {
    if (!searchQuery) return []
    
    const searchLower = searchQuery.toLowerCase();
    return items.filter(item => {
      if (item.type === 'general') {
        const nameMatch = item.name?.toLowerCase().includes(searchLower) || false;
        const descMatch = item.description?.toLowerCase().includes(searchLower) || false;
        const searchWords = searchLower.split(/\s+/);
        const descWords = item.description?.toLowerCase().split(/\s+/) || [];
        const partialWordMatch = searchWords.some(word => 
          descWords.some((descWord: string) => descWord.includes(word))
        );
        return nameMatch || descMatch || partialWordMatch;
      } else if (item.type === 'specific') {
        const meta = tokenMetadata[item.tokenURI];
        if (!meta || meta.error) return false;
        const nameMatch = meta.name?.toLowerCase().includes(searchLower) || false;
        const descMatch = meta.description?.toLowerCase().includes(searchLower) || false;
        const searchWords = searchLower.split(/\s+/);
        const descWords = meta.description?.toLowerCase().split(/\s+/) || [];
        const partialWordMatch = searchWords.some(word => 
          descWords.some((descWord: string) => descWord.includes(word))
        );
        return nameMatch || descMatch || partialWordMatch;
      } else if (item.type === 'account') {
        return (
          item.full_account_name?.toLowerCase().includes(searchLower) ||
          item.description?.toLowerCase().includes(searchLower)
        )
      } else if (item.type === 'group') {
        return (
          item.group_name.toLowerCase().includes(searchLower) ||
          (item.name_front?.toLowerCase().includes(searchLower)) ||
          (item.tagline?.toLowerCase().includes(searchLower)) ||
          (item.description?.toLowerCase().includes(searchLower))
        )
      } else if (item.type === 'syndicate') {
        return (
          item.name?.toLowerCase().includes(searchLower) ||
          item.description?.toLowerCase().includes(searchLower)
        )
      } else {
        return false
      }
    })
  }, [searchQuery, items, tokenMetadata])

  // Create swarm when search changes
  useEffect(() => {
    if (!searchQuery) {
      // Clear swarm and reset UI
      setSwarmOrbs([])
      setHeadingVisible(true)
      return
    }
    
    setHeadingVisible(false)

    // Get scored and sorted results
    const searchLower = searchQuery.toLowerCase()
    const scoredResults = filtered
      .map(item => ({
        item,
        score: scoreSearchResult(item, searchLower, tokenMetadata)
      }))
      .filter(result => result.score > 0)
      .sort((a, b) => b.score - a.score)
      .slice(0, MAX_SEARCH_RESULTS)
      .map(result => result.item)

    // Generate coordinated target positions
    const targetPositions = generateSwarmPositions(
      scoredResults.length, 
      magnetZone.x, 
      magnetZone.y
    )

         // Create swarm orbs ready to animate immediately
     const newSwarmOrbs = scoredResults.map((item, index) => {
       const targetPos = targetPositions[index]
       const entryPoint = calculateEntryPoint(targetPos.x, targetPos.y, viewport)
       
       return {
         id: getItemId(item),
         item,
         x: entryPoint.x,
         y: entryPoint.y,
         targetX: targetPos.x,
         targetY: targetPos.y,
         vx: 0,
         vy: 0,
         opacity: 1,
         scale: 1,
         entryPhase: 'entering' as const, // Ready to animate immediately
         entryDelay: index * 50,
         avoidanceRadius: 50
       }
     })

    setSwarmOrbs(newSwarmOrbs)
  }, [searchQuery, filtered, magnetZone.x, magnetZone.y])

    // No additional useEffects - handle everything at creation time

  // Clear swarm when search is cleared
  useEffect(() => {
    if (searchQuery) return
    if (!swarmOrbs.length) return
    
    // Animate out
    setSwarmOrbs(prev => prev.map(orb => ({ ...orb, opacity: 0, scale: 0 })))
    const timeout = setTimeout(() => setSwarmOrbs([]), 300)
    return () => clearTimeout(timeout)
  }, [searchQuery])

  return (
    <section className="relative w-full min-h-screen flex items-center justify-center bg-black overflow-hidden ensure-magnet">
      <div className="absolute inset-0 flex flex-col items-center justify-center overflow-hidden" ref={containerRef}>
        {/* Heading */}
        <AnimatePresence>
          {headingVisible && (
            <motion.h2
              className="absolute left-1/2 -translate-x-1/2 z-10 text-white text-center max-w-screen-lg px-4 font-bold select-none
                whitespace-normal md:whitespace-nowrap"
              style={{
                bottom: 'calc(50% + 56px)',
                fontSize: 'clamp(2.5rem, 6vw, 4.5rem)',
                lineHeight: 1.1,
                fontWeight: 700
              }}
              initial={{ opacity: 1 }}
              animate={{ opacity: 1 }}
              exit={{ opacity: 0 }}
              transition={{ duration: 0.5 }}
            >
              what do you want to ensure?
            </motion.h2>
          )}
        </AnimatePresence>

        {/* Search box */}
        <div
          className="relative w-full max-w-2xl mx-auto mb-0 flex flex-col items-center justify-center"
          style={{ zIndex: 20 }}
        >
          <MagnetSearch
            ref={searchInputRef}
            searchQuery={searchQuery}
            setSearchQuery={setSearchQuery}
            showTypewriter={showTypewriter}
            onReset={() => {
              setShowTypewriter(true)
              setHeadingVisible(true)
              setSwarmOrbs([])
            }}
            onStartTyping={() => {
              setShowTypewriter(false)
            }}
            className={cn(
              "text-4xl md:text-5xl !max-w-none",
              showTypewriter && "caret-transparent"
            )}
          />
        </div>

        {/* Loading state - only show if items haven't loaded yet */}
        {searchQuery && swarmOrbs.length === 0 && loading && items.length === 0 && (
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            className="absolute left-1/2 text-white/40 text-center"
            style={{ 
              zIndex: 30,
              top: 'calc(50% + 80px)',
              transform: 'translateX(-50%)'
            }}
          >
            <div className="w-6 h-6 border-2 border-white/20 border-t-white/60 rounded-full animate-spin mx-auto mb-4"></div>
            <p className="text-sm">Loading...</p>
          </motion.div>
        )}

        {/* No results - only show if we have items loaded but no matches */}
        {swarmOrbs.length === 0 && searchQuery && !loading && items.length > 0 && (
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            className="absolute left-1/2 text-white/60 text-center"
            style={{ 
              zIndex: 30,
              top: 'calc(50% + 80px)',
              transform: 'translateX(-50%)'
            }}
          >
            <p className="text-xl">No matches found for "{searchQuery}"</p>
            <p className="text-sm mt-2">Try different keywords or browse all items</p>
          </motion.div>
        )}

        {/* Swarm orbs */}
        {swarmOrbs.map((orb, index) => (
          <EnsureTooltip
            key={orb.id}
            content={{
              name: (() => {
                const item = orb.item as Certificate
                switch (item.type) {
                  case 'general':
                    return (item as GeneralCertificate).name
                  case 'specific':
                    return tokenMetadata[(item as SpecificCertificate).tokenURI]?.name
                  case 'group':
                    return (item as Group).group_name
                  case 'account':
                    return (item as Account).full_account_name
                  case 'syndicate':
                    return (item as Syndicate).name
                  default:
                    return ''
                }
              })(),
              label: (() => {
                const item = orb.item as Certificate
                switch (item.type) {
                  case 'general':
                    return 'currency'
                  case 'specific':
                    return 'asset'
                  case 'group':
                    return 'group'
                  case 'account':
                    return 'account'
                  case 'syndicate':
                    return 'syndicate'
                  default:
                    return ''
                }
              })()
            }}
          >
            <div
              className="swarm-orb"
              style={{
                '--entry-x': `${orb.x - orb.targetX}px`,
                '--entry-y': `${orb.y - orb.targetY}px`,
                '--delay': `${index * 50}ms`,
                position: 'absolute',
                left: orb.targetX - 50,
                top: orb.targetY - 50,
                zIndex: 30,
                width: 100,
                height: 100,
                cursor: 'pointer'
              } as React.CSSProperties}
              onClick={(e) => {
                e.preventDefault();
                e.stopPropagation();
                const href = orb.item.type === 'general' ? `/general/${orb.item.contract_address}` :
                            orb.item.type === 'specific' ? `/specific/${CONTRACTS.specific}/${orb.item.tokenURI.split('/').pop()}` :
                            orb.item.type === 'group' ? `/groups/${orb.item.group_name.replace(/^\./, '')}/all` :
                            orb.item.type === 'account' ? `/${(orb.item as Account).full_account_name}` :
                            `/syndicates/${(orb.item as any).name.toLowerCase().replace(/\s+/g, '-')}`;
                router.push(href);
              }}
            >
              {orb.item.type === 'account' ? (
                <div
                  className="w-full h-full hover:scale-110 hover:brightness-110 transition-all duration-300 ease-out"
                  style={{
                    borderRadius: '50%',
                    background: '#222',
                    boxShadow: isNaturalCapital(orb.item) 
                      ? '0 0 20px rgba(255, 215, 0, 0.7), 0 0 40px rgba(255, 215, 0, 0.4), 0 4px 20px rgba(0, 0, 0, 0.3)'
                      : '0 4px 20px rgba(0, 0, 0, 0.4), 0 2px 8px rgba(0, 0, 0, 0.2)',
                    border: isNaturalCapital(orb.item) ? '2px solid rgba(255, 215, 0, 0.9)' : '1px solid rgba(255, 255, 255, 0.1)',
                    overflow: 'hidden'
                  }}
                >
                  <AccountImage
                    tokenId={orb.item.token_id}
                    groupName={orb.item.group_name?.replace('.', '')}
                    className="w-full h-full object-cover"
                  />
                </div>
              ) : (
                <MagnetImage
                  src={getItemImage(orb.item, tokenMetadata)}
                  alt="swarm-orb"
                  item={orb.item}
                  style={{
                    width: '100%',
                    height: '100%'
                  }}
                />
              )}
            </div>
          </EnsureTooltip>
        ))}
      </div>
    </section>
  )
}
````

## File: src/modules/ensure/ensurePhrases.ts
````typescript
export interface TypewriterWord {
  text: string
  typingSpeed?: number
  deletingSpeed?: number
  pauseTime?: number
}

export const ensurePhrases: TypewriterWord[] = [
  { text: "clean water...", typingSpeed: 60, deletingSpeed: 30, pauseTime: 600 },
  { text: "natural capital...", typingSpeed: 70, deletingSpeed: 35, pauseTime: 800 },
  { text: "climate stability", typingSpeed: 75, deletingSpeed: 37, pauseTime: 700 },
  { text: "clean air...", typingSpeed: 60, deletingSpeed: 30, pauseTime: 600 },
  { text: "biodiversity...", typingSpeed: 65, deletingSpeed: 32, pauseTime: 700 },
  { text: "healthy soil...", typingSpeed: 65, deletingSpeed: 32, pauseTime: 600 },
  { text: "wildfire protection", typingSpeed: 75, deletingSpeed: 37, pauseTime: 700 },
  { text: "ecosystem services", typingSpeed: 75, deletingSpeed: 37, pauseTime: 800 },
  { text: "resilience...", typingSpeed: 60, deletingSpeed: 30, pauseTime: 600 },
  { text: "well-being...", typingSpeed: 65, deletingSpeed: 32, pauseTime: 600 },
  { text: "coastal protection", typingSpeed: 75, deletingSpeed: 37, pauseTime: 700 },
  { text: "health...", typingSpeed: 55, deletingSpeed: 28, pauseTime: 500 },
  { text: "impact...", typingSpeed: 55, deletingSpeed: 28, pauseTime: 500 },
  { text: "colorado river...", typingSpeed: 70, deletingSpeed: 35, pauseTime: 600 },
  { text: "my legacy...", typingSpeed: 60, deletingSpeed: 30, pauseTime: 600 },
  { text: "the amazon river", typingSpeed: 65, deletingSpeed: 32, pauseTime: 600 },
  { text: "risk reduction...", typingSpeed: 70, deletingSpeed: 35, pauseTime: 700 },
  { text: "victoria falls...", typingSpeed: 75, deletingSpeed: 37, pauseTime: 700 },
  { text: "cenotes...", typingSpeed: 55, deletingSpeed: 28, pauseTime: 500 },
  { text: "water abundance", typingSpeed: 70, deletingSpeed: 35, pauseTime: 600 },
  { text: "flood control...", typingSpeed: 65, deletingSpeed: 32, pauseTime: 600 },
  { text: "coral reefs...", typingSpeed: 60, deletingSpeed: 30, pauseTime: 600 },
  { text: "sea turtles...", typingSpeed: 65, deletingSpeed: 32, pauseTime: 600 },
  { text: "humpback whales...", typingSpeed: 70, deletingSpeed: 35, pauseTime: 700 },
  { text: "vaquita porpoise...", typingSpeed: 75, deletingSpeed: 37, pauseTime: 700 },
  { text: "monarch butterflies", typingSpeed: 70, deletingSpeed: 35, pauseTime: 700 },
  { text: "koala bear...", typingSpeed: 65, deletingSpeed: 32, pauseTime: 600 },
  { text: "spirit bear...", typingSpeed: 60, deletingSpeed: 30, pauseTime: 600 },
  { text: "elk...", typingSpeed: 55, deletingSpeed: 28, pauseTime: 500 },
  { text: "salmon...", typingSpeed: 60, deletingSpeed: 30, pauseTime: 600 },
  { text: "amur leopard...", typingSpeed: 70, deletingSpeed: 35, pauseTime: 700 },
  { text: "carbon sequestration...", typingSpeed: 75, deletingSpeed: 37, pauseTime: 700 },
  { text: "sumatran tiger...", typingSpeed: 75, deletingSpeed: 37, pauseTime: 700 },
  { text: "iberian lynx...", typingSpeed: 70, deletingSpeed: 35, pauseTime: 700 },
  { text: "habitat...", typingSpeed: 60, deletingSpeed: 30, pauseTime: 600 },
  { text: "wetlands...", typingSpeed: 65, deletingSpeed: 32, pauseTime: 600 },
  { text: "grasslands...", typingSpeed: 70, deletingSpeed: 35, pauseTime: 700 },
  { text: "erosion control...", typingSpeed: 70, deletingSpeed: 35, pauseTime: 700 },
  { text: "fungi...", typingSpeed: 55, deletingSpeed: 28, pauseTime: 500 },
  { text: "mycelium...", typingSpeed: 65, deletingSpeed: 32, pauseTime: 600 },
  { text: "heat reduction...", typingSpeed: 70, deletingSpeed: 35, pauseTime: 700 },
  { text: "climate adaptation", typingSpeed: 70, deletingSpeed: 35, pauseTime: 700 },
  { text: "adaptive capacity", typingSpeed: 65, deletingSpeed: 32, pauseTime: 600 },
  { text: "mount thielsen", typingSpeed: 70, deletingSpeed: 35, pauseTime: 700 },
  { text: "cascadia bioregion", typingSpeed: 75, deletingSpeed: 37, pauseTime: 700 },
  { text: "open space...", typingSpeed: 60, deletingSpeed: 30, pauseTime: 600 },
  { text: "place...", typingSpeed: 55, deletingSpeed: 28, pauseTime: 500 },
  { text: "my town...", typingSpeed: 60, deletingSpeed: 30, pauseTime: 600 },
  { text: "flint mi...", typingSpeed: 65, deletingSpeed: 32, pauseTime: 600 },
  { text: "mumbai...", typingSpeed: 60, deletingSpeed: 30, pauseTime: 600 },
  { text: "sydney...", typingSpeed: 55, deletingSpeed: 28, pauseTime: 500 },
  { text: "cape town...", typingSpeed: 60, deletingSpeed: 30, pauseTime: 600 },
  { text: "buenos aires...", typingSpeed: 65, deletingSpeed: 32, pauseTime: 600 },
  { text: "los angeles...", typingSpeed: 70, deletingSpeed: 35, pauseTime: 700 },
  { text: "congo river basin", typingSpeed: 75, deletingSpeed: 37, pauseTime: 700 },
  { text: "lake creek...", typingSpeed: 65, deletingSpeed: 32, pauseTime: 600 },
  { text: "natural assets...", typingSpeed: 65, deletingSpeed: 32, pauseTime: 600 },
  { text: "green infra...", typingSpeed: 60, deletingSpeed: 30, pauseTime: 600 },
  { text: "pollination...", typingSpeed: 65, deletingSpeed: 32, pauseTime: 600 },
  { text: "my business...", typingSpeed: 65, deletingSpeed: 32, pauseTime: 600 },
  { text: "lake winnipausake", typingSpeed: 80, deletingSpeed: 40, pauseTime: 700 },
  { text: "my portfolio...", typingSpeed: 70, deletingSpeed: 35, pauseTime: 700 },
  { text: "my investments...", typingSpeed: 75, deletingSpeed: 37, pauseTime: 700 },
  { text: "my health...", typingSpeed: 60, deletingSpeed: 30, pauseTime: 600 },
  { text: "happiness...", typingSpeed: 60, deletingSpeed: 30, pauseTime: 600 },
  { text: "ubi...", typingSpeed: 50, deletingSpeed: 25, pauseTime: 500 },
  { text: "living wages...", typingSpeed: 65, deletingSpeed: 32, pauseTime: 600 },
  { text: "my family...", typingSpeed: 60, deletingSpeed: 30, pauseTime: 600 },
  { text: "my groups work...", typingSpeed: 70, deletingSpeed: 35, pauseTime: 700 },
  { text: "my organization...", typingSpeed: 75, deletingSpeed: 37, pauseTime: 700 },
  { text: "my company...", typingSpeed: 65, deletingSpeed: 32, pauseTime: 600 },
  { text: "beauty...", typingSpeed: 55, deletingSpeed: 28, pauseTime: 500 },
  { text: "the earth...", typingSpeed: 65, deletingSpeed: 32, pauseTime: 600 }
]
````

## File: src/modules/ensure/EnsureTooltip.tsx
````typescript
'use client'

import * as React from "react"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { cn } from "@/lib/utils"

interface EnsureTooltipProps {
  children: React.ReactNode
  content: string | { name: string; label: string }
  className?: string
}

export function EnsureTooltip({ children, content, className }: EnsureTooltipProps) {
  return (
    <TooltipProvider>
      <Tooltip>
        <TooltipTrigger asChild>
          {children}
        </TooltipTrigger>
        <TooltipContent 
          className={cn(
            "bg-black/90 backdrop-blur-sm border border-white/10",
            "text-white/90 text-sm font-medium",
            "px-3 py-2",
            "z-50",
            "animate-in fade-in-0 zoom-in-95 duration-75",
            className
          )}
        >
          {typeof content === 'string' ? content : (
            <div className="text-center">
              <div>{content.name}</div>
              <div className="text-xs text-gray-400 mt-1">{content.label}</div>
            </div>
          )}
        </TooltipContent>
      </Tooltip>
    </TooltipProvider>
  )
}
````

## File: src/modules/ensure/MagnetSearch.tsx
````typescript
'use client'

import { forwardRef, useState, useEffect } from 'react'
import { cn } from '@/lib/utils'
import { TypewriterInput } from '@/components/ui/typewriter-input'
import { ensurePhrases } from './ensurePhrases'
import { motion } from 'framer-motion'

interface MagnetSearchProps {
  searchQuery: string
  setSearchQuery: (query: string) => void
  showTypewriter: boolean
  className?: string
  onReset?: () => void
  onStartTyping?: () => void
}

export const MagnetSearch = forwardRef<HTMLInputElement, MagnetSearchProps>(
  function MagnetSearch({ searchQuery, setSearchQuery, showTypewriter, className, onReset, onStartTyping }, ref) {
    // Focus on mount
    useEffect(() => {
      if (ref && 'current' in ref && ref.current) {
        ref.current.focus()
      }
    }, [ref])

    // Handle click outside
    useEffect(() => {
      function handleClick(e: MouseEvent) {
        const target = e.target as HTMLElement
        
        // Only handle clicks within EnsureMagnet
        const ensureMagnet = target.closest('.ensure-magnet')
        if (!ensureMagnet) return
        
        // Don't reset if clicking on:
        // 1. Search input or its container
        // 2. Tooltips or their triggers
        // 3. Orbs (which have cursor: pointer)
        if (
          (ref && 'current' in ref && ref.current?.contains(target)) ||
          target.closest('[data-radix-popper-content-wrapper]') ||
          target.closest('[data-radix-tooltip-trigger]') ||
          target.closest('[style*="cursor: pointer"]')
        ) {
          return
        }
        
        // Reset if clicking the background
        setSearchQuery('')
        if (onReset) onReset()
        // Refocus after reset
        setTimeout(() => {
          if (ref && 'current' in ref && ref.current) {
            ref.current.focus()
          }
        }, 0)
      }
      document.addEventListener('mousedown', handleClick)
      return () => document.removeEventListener('mousedown', handleClick)
    }, [ref, setSearchQuery, onReset])

    // Handle ESC key
    useEffect(() => {
      function handleKeyDown(e: KeyboardEvent) {
        if (e.key === 'Escape') {
          setSearchQuery('')
          if (onReset) onReset()
          // Refocus after reset
          setTimeout(() => {
            if (ref && 'current' in ref && ref.current) {
              ref.current.focus()
            }
          }, 0)
        }
      }
      document.addEventListener('keydown', handleKeyDown)
      return () => document.removeEventListener('keydown', handleKeyDown)
    }, [ref, setSearchQuery, onReset])

    return (
      <div className="relative w-full max-w-2xl mx-auto mb-0 flex flex-col items-center justify-center">
        <div className="relative w-full">
          <input
            ref={ref}
            type="text"
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            onClick={() => {
              if (ref && 'current' in ref && ref.current) {
                ref.current.focus()
              }
              if (onStartTyping) {
                onStartTyping()
              }
            }}
            className={cn(
              "w-full bg-transparent text-white text-4xl md:text-5xl outline-none text-center caret-transparent",
              !searchQuery && "border-2 border-white/20 rounded-lg px-4 py-2",
              searchQuery && "text-transparent",
              className
            )}
            placeholder=""
          />
          {searchQuery && (
            <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
              <motion.span
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                className="text-white/80 text-4xl md:text-5xl"
              >
                {searchQuery}
                <span className="inline-block w-[2px] h-[1.2em] bg-white/80 animate-blink align-middle ml-[2px]"></span>
              </motion.span>
            </div>
          )}
        </div>
        {showTypewriter && !searchQuery && (
          <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
            <TypewriterInput words={ensurePhrases} />
          </div>
        )}
        {!showTypewriter && !searchQuery && (
          <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
            <span className="text-white/80 text-4xl md:text-5xl">
              <span className="inline-block w-[2px] h-[1.2em] bg-white/80 animate-blink align-middle"></span>
            </span>
          </div>
        )}
      </div>
    )
  }
)
````

## File: src/modules/exposure/assetMapping.ts
````typescript
import { CONTRACTS } from '../specific/config'

// Map of node names to specific asset token IDs
export const NODE_TO_ASSET_MAP: Record<string, number | null> = {
  // Stocks (layer 2)
  'Rivers & Lakes': null,
  'Tropical Forest': null,
  'Temperate Forest': null,
  'Boreal Forest': null,
  'Coastal Systems': null,
  'Inland Wetlands': null,
  'Cultivated & Developed': null,
  'Urban Open Space': null,
  'Rural Open Space': null,
  'Marine Systems': null,
  'Grasslands': null,
  'Shrublands': null,
  'Polar & Alpine': null,
  'Desert': null,
  'Subterranean': null,

  // Flows (layer 1)
  'Raw Materials': null,
  'Food': null,
  'Energy': null,
  'Water Abundance': null,
  'Healthy Soils': null,
  'Medicinal & Genetic': null,
  'Climate Stability': null,
  'Clean Air': null,
  'Clean Water': null,
  'Risk Resilience': null,
  'Pollination': null,
  'Erosion Control': null,
  'Pest & Disease Control': null,
  'Habitat': null,
  'Recreation & Experiences': null,
  'Research & Learning': null,
  'Aesthetic & Sensory': null,
  'Art & Inspiration': null,
  'Existence & Legacy': null,

  // Sectors (layer 0)
  'Food & Agriculture': null,
  'Energy & Power': 13,  // Only this one has an asset ID
  'Manufacturing & Materials': null,
  'Infrastructure & Construction': null,
  'Finance & Insurance': null,
  'Retail': null,
  'Transportation & Logistics': null
}

// Helper function to get asset ID for a node
export function getAssetIdForNode(nodeName: string): number | null {
  return NODE_TO_ASSET_MAP[nodeName] ?? null
}

// Helper function to check if a node has an associated asset
export function hasAsset(nodeName: string): boolean {
  return NODE_TO_ASSET_MAP[nodeName] !== null
}
````

## File: src/modules/exposure/data.tsx
````typescript
export interface ExposureData {
  source: string;
  target: string;
  value: number;
}

export const exposureData: ExposureData[] = [
  { source: 'Food & Agriculture', target: 'Raw Materials', value: 3 },
  { source: 'Food & Agriculture', target: 'Food', value: 3 },
  { source: 'Food & Agriculture', target: 'Energy', value: 2 },
  { source: 'Food & Agriculture', target: 'Water Abundance', value: 3 },
  { source: 'Food & Agriculture', target: 'Healthy Soils', value: 3 },
  { source: 'Food & Agriculture', target: 'Medicinal & Genetic', value: 3 },
  { source: 'Food & Agriculture', target: 'Climate Stability', value: 3 },
  { source: 'Food & Agriculture', target: 'Clean Air', value: 2 },
  { source: 'Food & Agriculture', target: 'Clean Water', value: 3 },
  { source: 'Food & Agriculture', target: 'Risk Resilience', value: 3 },
  { source: 'Food & Agriculture', target: 'Pollination', value: 3 },
  { source: 'Food & Agriculture', target: 'Erosion Control', value: 3 },
  { source: 'Food & Agriculture', target: 'Pest & Disease Control', value: 3 },
  { source: 'Food & Agriculture', target: 'Habitat', value: 2 },
  { source: 'Food & Agriculture', target: 'Recreation & Experiences', value: 3 },
  { source: 'Food & Agriculture', target: 'Research & Learning', value: 3 },
  { source: 'Food & Agriculture', target: 'Aesthetic & Sensory', value: 3 },
  { source: 'Food & Agriculture', target: 'Art & Inspiration', value: 3 },
  { source: 'Food & Agriculture', target: 'Existence & Legacy', value: 3 },
  { source: 'Manufacturing & Materials', target: 'Raw Materials', value: 3 },
  { source: 'Manufacturing & Materials', target: 'Food', value: 1 },
  { source: 'Manufacturing & Materials', target: 'Energy', value: 3 },
  { source: 'Manufacturing & Materials', target: 'Water Abundance', value: 2 },
  { source: 'Manufacturing & Materials', target: 'Healthy Soils', value: 1 },
  { source: 'Manufacturing & Materials', target: 'Medicinal & Genetic', value: 3 },
  { source: 'Manufacturing & Materials', target: 'Climate Stability', value: 1 },
  { source: 'Manufacturing & Materials', target: 'Clean Air', value: 1 },
  { source: 'Manufacturing & Materials', target: 'Clean Water', value: 3 },
  { source: 'Manufacturing & Materials', target: 'Risk Resilience', value: 2 },
  { source: 'Manufacturing & Materials', target: 'Pollination', value: 1 },
  { source: 'Manufacturing & Materials', target: 'Erosion Control', value: 2 },
  { source: 'Manufacturing & Materials', target: 'Pest & Disease Control', value: 1 },
  { source: 'Manufacturing & Materials', target: 'Habitat', value: 2 },
  { source: 'Manufacturing & Materials', target: 'Recreation & Experiences', value: 1 },
  { source: 'Manufacturing & Materials', target: 'Research & Learning', value: 3 },
  { source: 'Manufacturing & Materials', target: 'Aesthetic & Sensory', value: 1 },
  { source: 'Manufacturing & Materials', target: 'Art & Inspiration', value: 3 },
  { source: 'Manufacturing & Materials', target: 'Existence & Legacy', value: 2 },
  { source: 'Raw Materials', target: 'Rivers & Lakes', value: 2 },
  { source: 'Food', target: 'Rivers & Lakes', value: 3 },
  { source: 'Energy', target: 'Rivers & Lakes', value: 2 },
  { source: 'Water Abundance', target: 'Rivers & Lakes', value: 3 },
  { source: 'Healthy Soils', target: 'Rivers & Lakes', value: 2 },
  { source: 'Medicinal & Genetic', target: 'Rivers & Lakes', value: 2 },
  { source: 'Climate Stability', target: 'Rivers & Lakes', value: 2 },
  { source: 'Clean Air', target: 'Rivers & Lakes', value: 1 },
  { source: 'Clean Water', target: 'Rivers & Lakes', value: 3 },
  { source: 'Risk Resilience', target: 'Rivers & Lakes', value: 3 },
  { source: 'Pollination', target: 'Rivers & Lakes', value: 1 },
  { source: 'Erosion Control', target: 'Rivers & Lakes', value: 2 },
  { source: 'Pest & Disease Control', target: 'Rivers & Lakes', value: 2 },
  { source: 'Habitat', target: 'Rivers & Lakes', value: 3 },
  { source: 'Recreation & Experiences', target: 'Rivers & Lakes', value: 3 },
  { source: 'Research & Learning', target: 'Rivers & Lakes', value: 3 },
  { source: 'Aesthetic & Sensory', target: 'Rivers & Lakes', value: 3 },
  { source: 'Art & Inspiration', target: 'Rivers & Lakes', value: 3 },
  { source: 'Existence & Legacy', target: 'Rivers & Lakes', value: 3 },
  { source: 'Raw Materials', target: 'Tropical Forest', value: 3 },
  { source: 'Food', target: 'Tropical Forest', value: 3 },
  { source: 'Energy', target: 'Tropical Forest', value: 3 },
  { source: 'Water Abundance', target: 'Tropical Forest', value: 3 },
  { source: 'Healthy Soils', target: 'Tropical Forest', value: 3 },
  { source: 'Medicinal & Genetic', target: 'Tropical Forest', value: 3 },
  { source: 'Climate Stability', target: 'Tropical Forest', value: 3 },
  { source: 'Clean Air', target: 'Tropical Forest', value: 3 },
  { source: 'Clean Water', target: 'Tropical Forest', value: 3 },
  { source: 'Risk Resilience', target: 'Tropical Forest', value: 3 },
  { source: 'Pollination', target: 'Tropical Forest', value: 3 },
  { source: 'Erosion Control', target: 'Tropical Forest', value: 3 },
  { source: 'Pest & Disease Control', target: 'Tropical Forest', value: 3 },
  { source: 'Habitat', target: 'Tropical Forest', value: 3 },
  { source: 'Recreation & Experiences', target: 'Tropical Forest', value: 3 },
  { source: 'Research & Learning', target: 'Tropical Forest', value: 3 },
  { source: 'Aesthetic & Sensory', target: 'Tropical Forest', value: 3 },
  { source: 'Art & Inspiration', target: 'Tropical Forest', value: 3 },
  { source: 'Existence & Legacy', target: 'Tropical Forest', value: 3 },
  { source: 'Raw Materials', target: 'Temperate Forest', value: 3 },
  { source: 'Food', target: 'Temperate Forest', value: 2 },
  { source: 'Energy', target: 'Temperate Forest', value: 2 },
  { source: 'Water Abundance', target: 'Temperate Forest', value: 3 },
  { source: 'Healthy Soils', target: 'Temperate Forest', value: 3 },
  { source: 'Medicinal & Genetic', target: 'Temperate Forest', value: 3 },
  { source: 'Climate Stability', target: 'Temperate Forest', value: 3 },
  { source: 'Clean Air', target: 'Temperate Forest', value: 3 },
  { source: 'Clean Water', target: 'Temperate Forest', value: 3 },
  { source: 'Risk Resilience', target: 'Temperate Forest', value: 3 },
  { source: 'Pollination', target: 'Temperate Forest', value: 3 },
  { source: 'Erosion Control', target: 'Temperate Forest', value: 3 },
  { source: 'Pest & Disease Control', target: 'Temperate Forest', value: 2 },
  { source: 'Habitat', target: 'Temperate Forest', value: 3 },
  { source: 'Recreation & Experiences', target: 'Temperate Forest', value: 3 },
  { source: 'Research & Learning', target: 'Temperate Forest', value: 3 },
  { source: 'Aesthetic & Sensory', target: 'Temperate Forest', value: 3 },
  { source: 'Art & Inspiration', target: 'Temperate Forest', value: 3 },
  { source: 'Existence & Legacy', target: 'Temperate Forest', value: 3 },
  { source: 'Energy & Power', target: 'Raw Materials', value: 2 },
  { source: 'Energy & Power', target: 'Food', value: 1 },
  { source: 'Energy & Power', target: 'Energy', value: 3 },
  { source: 'Energy & Power', target: 'Water Abundance', value: 3 },
  { source: 'Energy & Power', target: 'Healthy Soils', value: 2 },
  { source: 'Energy & Power', target: 'Medicinal & Genetic', value: 1 },
  { source: 'Energy & Power', target: 'Climate Stability', value: 3 },
  { source: 'Energy & Power', target: 'Clean Air', value: 1 },
  { source: 'Energy & Power', target: 'Clean Water', value: 3 },
  { source: 'Energy & Power', target: 'Risk Resilience', value: 3 },
  { source: 'Energy & Power', target: 'Pollination', value: 1 },
  { source: 'Energy & Power', target: 'Erosion Control', value: 3 },
  { source: 'Energy & Power', target: 'Pest & Disease Control', value: 1 },
  { source: 'Energy & Power', target: 'Habitat', value: 2 },
  { source: 'Energy & Power', target: 'Recreation & Experiences', value: 2 },
  { source: 'Energy & Power', target: 'Research & Learning', value: 3 },
  { source: 'Energy & Power', target: 'Aesthetic & Sensory', value: 1 },
  { source: 'Energy & Power', target: 'Art & Inspiration', value: 1 },
  { source: 'Energy & Power', target: 'Existence & Legacy', value: 3 },
  { source: 'Infrastructure & Construction', target: 'Raw Materials', value: 1 },
  { source: 'Infrastructure & Construction', target: 'Food', value: 1 },
  { source: 'Infrastructure & Construction', target: 'Energy', value: 3 },
  { source: 'Infrastructure & Construction', target: 'Water Abundance', value: 2 },
  { source: 'Infrastructure & Construction', target: 'Healthy Soils', value: 2 },
  { source: 'Infrastructure & Construction', target: 'Medicinal & Genetic', value: 1 },
  { source: 'Infrastructure & Construction', target: 'Climate Stability', value: 2 },
  { source: 'Infrastructure & Construction', target: 'Clean Air', value: 2 },
  { source: 'Infrastructure & Construction', target: 'Clean Water', value: 2 },
  { source: 'Infrastructure & Construction', target: 'Risk Resilience', value: 2 },
  { source: 'Infrastructure & Construction', target: 'Pollination', value: 1 },
  { source: 'Infrastructure & Construction', target: 'Erosion Control', value: 3 },
  { source: 'Infrastructure & Construction', target: 'Pest & Disease Control', value: 1 },
  { source: 'Infrastructure & Construction', target: 'Habitat', value: 2 },
  { source: 'Infrastructure & Construction', target: 'Recreation & Experiences', value: 2 },
  { source: 'Infrastructure & Construction', target: 'Research & Learning', value: 2 },
  { source: 'Infrastructure & Construction', target: 'Aesthetic & Sensory', value: 2 },
  { source: 'Infrastructure & Construction', target: 'Art & Inspiration', value: 1 },
  { source: 'Infrastructure & Construction', target: 'Existence & Legacy', value: 3 },
  { source: 'Retail', target: 'Raw Materials', value: 3 },
  { source: 'Retail', target: 'Food', value: 3 },
  { source: 'Retail', target: 'Energy', value: 2 },
  { source: 'Retail', target: 'Water Abundance', value: 2 },
  { source: 'Retail', target: 'Healthy Soils', value: 2 },
  { source: 'Retail', target: 'Medicinal & Genetic', value: 2 },
  { source: 'Retail', target: 'Climate Stability', value: 1 },
  { source: 'Retail', target: 'Clean Air', value: 1 },
  { source: 'Retail', target: 'Clean Water', value: 2 },
  { source: 'Retail', target: 'Risk Resilience', value: 2 },
  { source: 'Retail', target: 'Pollination', value: 2 },
  { source: 'Retail', target: 'Erosion Control', value: 2 },
  { source: 'Retail', target: 'Pest & Disease Control', value: 1 },
  { source: 'Retail', target: 'Habitat', value: 1 },
  { source: 'Retail', target: 'Recreation & Experiences', value: 3 },
  { source: 'Retail', target: 'Research & Learning', value: 2 },
  { source: 'Retail', target: 'Aesthetic & Sensory', value: 3 },
  { source: 'Retail', target: 'Art & Inspiration', value: 2 },
  { source: 'Retail', target: 'Existence & Legacy', value: 3 },
  { source: 'Transportation & Logistics', target: 'Raw Materials', value: 3 },
  { source: 'Transportation & Logistics', target: 'Food', value: 1 },
  { source: 'Transportation & Logistics', target: 'Energy', value: 3 },
  { source: 'Transportation & Logistics', target: 'Water Abundance', value: 1 },
  { source: 'Transportation & Logistics', target: 'Healthy Soils', value: 1 },
  { source: 'Transportation & Logistics', target: 'Medicinal & Genetic', value: 1 },
  { source: 'Transportation & Logistics', target: 'Climate Stability', value: 2 },
  { source: 'Transportation & Logistics', target: 'Clean Air', value: 1 },
  { source: 'Transportation & Logistics', target: 'Clean Water', value: 2 },
  { source: 'Transportation & Logistics', target: 'Risk Resilience', value: 2 },
  { source: 'Transportation & Logistics', target: 'Pollination', value: 1 },
  { source: 'Transportation & Logistics', target: 'Erosion Control', value: 3 },
  { source: 'Transportation & Logistics', target: 'Pest & Disease Control', value: 1 },
  { source: 'Transportation & Logistics', target: 'Habitat', value: 1 },
  { source: 'Transportation & Logistics', target: 'Recreation & Experiences', value: 3 },
  { source: 'Transportation & Logistics', target: 'Research & Learning', value: 2 },
  { source: 'Transportation & Logistics', target: 'Aesthetic & Sensory', value: 3 },
  { source: 'Transportation & Logistics', target: 'Art & Inspiration', value: 1 },
  { source: 'Transportation & Logistics', target: 'Existence & Legacy', value: 2 },
  { source: 'Finance & Insurance', target: 'Raw Materials', value: 2 },
  { source: 'Finance & Insurance', target: 'Food', value: 3 },
  { source: 'Finance & Insurance', target: 'Energy', value: 3 },
  { source: 'Finance & Insurance', target: 'Water Abundance', value: 3 },
  { source: 'Finance & Insurance', target: 'Healthy Soils', value: 2 },
  { source: 'Finance & Insurance', target: 'Medicinal & Genetic', value: 2 },
  { source: 'Finance & Insurance', target: 'Climate Stability', value: 3 },
  { source: 'Finance & Insurance', target: 'Clean Air', value: 3 },
  { source: 'Finance & Insurance', target: 'Clean Water', value: 3 },
  { source: 'Finance & Insurance', target: 'Risk Resilience', value: 3 },
  { source: 'Finance & Insurance', target: 'Pollination', value: 3 },
  { source: 'Finance & Insurance', target: 'Erosion Control', value: 3 },
  { source: 'Finance & Insurance', target: 'Pest & Disease Control', value: 3 },
  { source: 'Finance & Insurance', target: 'Habitat', value: 3 },
  { source: 'Finance & Insurance', target: 'Recreation & Experiences', value: 2 },
  { source: 'Finance & Insurance', target: 'Research & Learning', value: 3 },
  { source: 'Finance & Insurance', target: 'Aesthetic & Sensory', value: 2 },
  { source: 'Finance & Insurance', target: 'Art & Inspiration', value: 1 },
  { source: 'Finance & Insurance', target: 'Existence & Legacy', value: 3 },
  { source: 'Raw Materials', target: 'Boreal Forest', value: 3 },
  { source: 'Food', target: 'Boreal Forest', value: 1 },
  { source: 'Energy', target: 'Boreal Forest', value: 3 },
  { source: 'Water Abundance', target: 'Boreal Forest', value: 3 },
  { source: 'Healthy Soils', target: 'Boreal Forest', value: 2 },
  { source: 'Medicinal & Genetic', target: 'Boreal Forest', value: 2 },
  { source: 'Climate Stability', target: 'Boreal Forest', value: 3 },
  { source: 'Clean Air', target: 'Boreal Forest', value: 3 },
  { source: 'Clean Water', target: 'Boreal Forest', value: 3 },
  { source: 'Risk Resilience', target: 'Boreal Forest', value: 2 },
  { source: 'Pollination', target: 'Boreal Forest', value: 1 },
  { source: 'Erosion Control', target: 'Boreal Forest', value: 2 },
  { source: 'Pest & Disease Control', target: 'Boreal Forest', value: 1 },
  { source: 'Habitat', target: 'Boreal Forest', value: 3 },
  { source: 'Recreation & Experiences', target: 'Boreal Forest', value: 2 },
  { source: 'Research & Learning', target: 'Boreal Forest', value: 3 },
  { source: 'Aesthetic & Sensory', target: 'Boreal Forest', value: 3 },
  { source: 'Art & Inspiration', target: 'Boreal Forest', value: 3 },
  { source: 'Existence & Legacy', target: 'Boreal Forest', value: 3 },
  { source: 'Raw Materials', target: 'Coastal Systems', value: 3 },
  { source: 'Food', target: 'Coastal Systems', value: 3 },
  { source: 'Energy', target: 'Coastal Systems', value: 2 },
  { source: 'Water Abundance', target: 'Coastal Systems', value: 2 },
  { source: 'Healthy Soils', target: 'Coastal Systems', value: 2 },
  { source: 'Medicinal & Genetic', target: 'Coastal Systems', value: 2 },
  { source: 'Climate Stability', target: 'Coastal Systems', value: 3 },
  { source: 'Clean Air', target: 'Coastal Systems', value: 2 },
  { source: 'Clean Water', target: 'Coastal Systems', value: 3 },
  { source: 'Risk Resilience', target: 'Coastal Systems', value: 3 },
  { source: 'Pollination', target: 'Coastal Systems', value: 1 },
  { source: 'Erosion Control', target: 'Coastal Systems', value: 3 },
  { source: 'Pest & Disease Control', target: 'Coastal Systems', value: 2 },
  { source: 'Habitat', target: 'Coastal Systems', value: 3 },
  { source: 'Recreation & Experiences', target: 'Coastal Systems', value: 3 },
  { source: 'Research & Learning', target: 'Coastal Systems', value: 3 },
  { source: 'Aesthetic & Sensory', target: 'Coastal Systems', value: 3 },
  { source: 'Art & Inspiration', target: 'Coastal Systems', value: 3 },
  { source: 'Existence & Legacy', target: 'Coastal Systems', value: 3 },
  { source: 'Raw Materials', target: 'Inland Wetlands', value: 2 },
  { source: 'Food', target: 'Inland Wetlands', value: 2 },
  { source: 'Energy', target: 'Inland Wetlands', value: 2 },
  { source: 'Water Abundance', target: 'Inland Wetlands', value: 3 },
  { source: 'Healthy Soils', target: 'Inland Wetlands', value: 3 },
  { source: 'Medicinal & Genetic', target: 'Inland Wetlands', value: 2 },
  { source: 'Climate Stability', target: 'Inland Wetlands', value: 3 },
  { source: 'Clean Air', target: 'Inland Wetlands', value: 2 },
  { source: 'Clean Water', target: 'Inland Wetlands', value: 3 },
  { source: 'Risk Resilience', target: 'Inland Wetlands', value: 3 },
  { source: 'Pollination', target: 'Inland Wetlands', value: 1 },
  { source: 'Erosion Control', target: 'Inland Wetlands', value: 3 },
  { source: 'Pest & Disease Control', target: 'Inland Wetlands', value: 2 },
  { source: 'Habitat', target: 'Inland Wetlands', value: 3 },
  { source: 'Recreation & Experiences', target: 'Inland Wetlands', value: 3 },
  { source: 'Research & Learning', target: 'Inland Wetlands', value: 3 },
  { source: 'Aesthetic & Sensory', target: 'Inland Wetlands', value: 3 },
  { source: 'Art & Inspiration', target: 'Inland Wetlands', value: 3 },
  { source: 'Existence & Legacy', target: 'Inland Wetlands', value: 3 },
  { source: 'Raw Materials', target: 'Cultivated & Developed', value: 3 },
  { source: 'Food', target: 'Cultivated & Developed', value: 3 },
  { source: 'Energy', target: 'Cultivated & Developed', value: 2 },
  { source: 'Water Abundance', target: 'Cultivated & Developed', value: 1 },
  { source: 'Healthy Soils', target: 'Cultivated & Developed', value: 2 },
  { source: 'Medicinal & Genetic', target: 'Cultivated & Developed', value: 2 },
  { source: 'Climate Stability', target: 'Cultivated & Developed', value: 1 },
  { source: 'Clean Air', target: 'Cultivated & Developed', value: 1 },
  { source: 'Clean Water', target: 'Cultivated & Developed', value: 1 },
  { source: 'Risk Resilience', target: 'Cultivated & Developed', value: 1 },
  { source: 'Pollination', target: 'Cultivated & Developed', value: 2 },
  { source: 'Erosion Control', target: 'Cultivated & Developed', value: 1 },
  { source: 'Pest & Disease Control', target: 'Cultivated & Developed', value: 2 },
  { source: 'Habitat', target: 'Cultivated & Developed', value: 1 },
  { source: 'Recreation & Experiences', target: 'Cultivated & Developed', value: 3 },
  { source: 'Research & Learning', target: 'Cultivated & Developed', value: 3 },
  { source: 'Aesthetic & Sensory', target: 'Cultivated & Developed', value: 3 },
  { source: 'Art & Inspiration', target: 'Cultivated & Developed', value: 3 },
  { source: 'Existence & Legacy', target: 'Cultivated & Developed', value: 3 },
  { source: 'Raw Materials', target: 'Urban Open Space', value: 1 },
  { source: 'Food', target: 'Urban Open Space', value: 1 },
  { source: 'Energy', target: 'Urban Open Space', value: 1 },
  { source: 'Water Abundance', target: 'Urban Open Space', value: 1 },
  { source: 'Healthy Soils', target: 'Urban Open Space', value: 1 },
  { source: 'Medicinal & Genetic', target: 'Urban Open Space', value: 1 },
  { source: 'Climate Stability', target: 'Urban Open Space', value: 2 },
  { source: 'Clean Air', target: 'Urban Open Space', value: 3 },
  { source: 'Clean Water', target: 'Urban Open Space', value: 2 },
  { source: 'Risk Resilience', target: 'Urban Open Space', value: 2 },
  { source: 'Pollination', target: 'Urban Open Space', value: 2 },
  { source: 'Erosion Control', target: 'Urban Open Space', value: 1 },
  { source: 'Pest & Disease Control', target: 'Urban Open Space', value: 2 },
  { source: 'Habitat', target: 'Urban Open Space', value: 2 },
  { source: 'Recreation & Experiences', target: 'Urban Open Space', value: 3 },
  { source: 'Research & Learning', target: 'Urban Open Space', value: 3 },
  { source: 'Aesthetic & Sensory', target: 'Urban Open Space', value: 3 },
  { source: 'Art & Inspiration', target: 'Urban Open Space', value: 3 },
  { source: 'Existence & Legacy', target: 'Urban Open Space', value: 3 },
  { source: 'Raw Materials', target: 'Rural Open Space', value: 2 },
  { source: 'Food', target: 'Rural Open Space', value: 2 },
  { source: 'Energy', target: 'Rural Open Space', value: 2 },
  { source: 'Water Abundance', target: 'Rural Open Space', value: 2 },
  { source: 'Healthy Soils', target: 'Rural Open Space', value: 3 },
  { source: 'Medicinal & Genetic', target: 'Rural Open Space', value: 2 },
  { source: 'Climate Stability', target: 'Rural Open Space', value: 2 },
  { source: 'Clean Air', target: 'Rural Open Space', value: 2 },
  { source: 'Clean Water', target: 'Rural Open Space', value: 3 },
  { source: 'Risk Resilience', target: 'Rural Open Space', value: 3 },
  { source: 'Pollination', target: 'Rural Open Space', value: 3 },
  { source: 'Erosion Control', target: 'Rural Open Space', value: 3 },
  { source: 'Pest & Disease Control', target: 'Rural Open Space', value: 2 },
  { source: 'Habitat', target: 'Rural Open Space', value: 3 },
  { source: 'Recreation & Experiences', target: 'Rural Open Space', value: 3 },
  { source: 'Research & Learning', target: 'Rural Open Space', value: 3 },
  { source: 'Aesthetic & Sensory', target: 'Rural Open Space', value: 3 },
  { source: 'Art & Inspiration', target: 'Rural Open Space', value: 3 },
  { source: 'Existence & Legacy', target: 'Rural Open Space', value: 3 },
  { source: 'Raw Materials', target: 'Marine Systems', value: 3 },
  { source: 'Food', target: 'Marine Systems', value: 3 },
  { source: 'Energy', target: 'Marine Systems', value: 3 },
  { source: 'Water Abundance', target: 'Marine Systems', value: 3 },
  { source: 'Healthy Soils', target: 'Marine Systems', value: 1 },
  { source: 'Medicinal & Genetic', target: 'Marine Systems', value: 3 },
  { source: 'Climate Stability', target: 'Marine Systems', value: 3 },
  { source: 'Clean Air', target: 'Marine Systems', value: 2 },
  { source: 'Clean Water', target: 'Marine Systems', value: 3 },
  { source: 'Risk Resilience', target: 'Marine Systems', value: 3 },
  { source: 'Pollination', target: 'Marine Systems', value: 1 },
  { source: 'Erosion Control', target: 'Marine Systems', value: 2 },
  { source: 'Pest & Disease Control', target: 'Marine Systems', value: 2 },
  { source: 'Habitat', target: 'Marine Systems', value: 3 },
  { source: 'Recreation & Experiences', target: 'Marine Systems', value: 3 },
  { source: 'Research & Learning', target: 'Marine Systems', value: 3 },
  { source: 'Aesthetic & Sensory', target: 'Marine Systems', value: 3 },
  { source: 'Art & Inspiration', target: 'Marine Systems', value: 3 },
  { source: 'Existence & Legacy', target: 'Marine Systems', value: 3 },
  { source: 'Raw Materials', target: 'Grasslands', value: 2 },
  { source: 'Food', target: 'Grasslands', value: 3 },
  { source: 'Energy', target: 'Grasslands', value: 2 },
  { source: 'Water Abundance', target: 'Grasslands', value: 2 },
  { source: 'Healthy Soils', target: 'Grasslands', value: 3 },
  { source: 'Medicinal & Genetic', target: 'Grasslands', value: 2 },
  { source: 'Climate Stability', target: 'Grasslands', value: 3 },
  { source: 'Clean Air', target: 'Grasslands', value: 2 },
  { source: 'Clean Water', target: 'Grasslands', value: 2 },
  { source: 'Risk Resilience', target: 'Grasslands', value: 2 },
  { source: 'Pollination', target: 'Grasslands', value: 3 },
  { source: 'Erosion Control', target: 'Grasslands', value: 3 },
  { source: 'Pest & Disease Control', target: 'Grasslands', value: 2 },
  { source: 'Habitat', target: 'Grasslands', value: 3 },
  { source: 'Recreation & Experiences', target: 'Grasslands', value: 3 },
  { source: 'Research & Learning', target: 'Grasslands', value: 2 },
  { source: 'Aesthetic & Sensory', target: 'Grasslands', value: 3 },
  { source: 'Art & Inspiration', target: 'Grasslands', value: 3 },
  { source: 'Existence & Legacy', target: 'Grasslands', value: 3 },
  { source: 'Raw Materials', target: 'Shrublands', value: 2 },
  { source: 'Food', target: 'Shrublands', value: 1 },
  { source: 'Energy', target: 'Shrublands', value: 1 },
  { source: 'Water Abundance', target: 'Shrublands', value: 1 },
  { source: 'Healthy Soils', target: 'Shrublands', value: 1 },
  { source: 'Medicinal & Genetic', target: 'Shrublands', value: 2 },
  { source: 'Climate Stability', target: 'Shrublands', value: 2 },
  { source: 'Clean Air', target: 'Shrublands', value: 1 },
  { source: 'Clean Water', target: 'Shrublands', value: 1 },
  { source: 'Risk Resilience', target: 'Shrublands', value: 2 },
  { source: 'Pollination', target: 'Shrublands', value: 2 },
  { source: 'Erosion Control', target: 'Shrublands', value: 2 },
  { source: 'Pest & Disease Control', target: 'Shrublands', value: 1 },
  { source: 'Habitat', target: 'Shrublands', value: 3 },
  { source: 'Recreation & Experiences', target: 'Shrublands', value: 2 },
  { source: 'Research & Learning', target: 'Shrublands', value: 2 },
  { source: 'Aesthetic & Sensory', target: 'Shrublands', value: 3 },
  { source: 'Art & Inspiration', target: 'Shrublands', value: 3 },
  { source: 'Existence & Legacy', target: 'Shrublands', value: 3 },
  { source: 'Raw Materials', target: 'Polar & Alpine', value: 1 },
  { source: 'Food', target: 'Polar & Alpine', value: 1 },
  { source: 'Energy', target: 'Polar & Alpine', value: 2 },
  { source: 'Water Abundance', target: 'Polar & Alpine', value: 3 },
  { source: 'Healthy Soils', target: 'Polar & Alpine', value: 1 },
  { source: 'Medicinal & Genetic', target: 'Polar & Alpine', value: 2 },
  { source: 'Climate Stability', target: 'Polar & Alpine', value: 3 },
  { source: 'Clean Air', target: 'Polar & Alpine', value: 3 },
  { source: 'Clean Water', target: 'Polar & Alpine', value: 3 },
  { source: 'Risk Resilience', target: 'Polar & Alpine', value: 2 },
  { source: 'Pollination', target: 'Polar & Alpine', value: 1 },
  { source: 'Erosion Control', target: 'Polar & Alpine', value: 1 },
  { source: 'Pest & Disease Control', target: 'Polar & Alpine', value: 1 },
  { source: 'Habitat', target: 'Polar & Alpine', value: 3 },
  { source: 'Recreation & Experiences', target: 'Polar & Alpine', value: 2 },
  { source: 'Research & Learning', target: 'Polar & Alpine', value: 3 },
  { source: 'Aesthetic & Sensory', target: 'Polar & Alpine', value: 3 },
  { source: 'Art & Inspiration', target: 'Polar & Alpine', value: 3 },
  { source: 'Existence & Legacy', target: 'Polar & Alpine', value: 3 },
  { source: 'Raw Materials', target: 'Desert', value: 2 },
  { source: 'Food', target: 'Desert', value: 1 },
  { source: 'Energy', target: 'Desert', value: 3 },
  { source: 'Water Abundance', target: 'Desert', value: 1 },
  { source: 'Healthy Soils', target: 'Desert', value: 1 },
  { source: 'Medicinal & Genetic', target: 'Desert', value: 2 },
  { source: 'Climate Stability', target: 'Desert', value: 1 },
  { source: 'Clean Air', target: 'Desert', value: 1 },
  { source: 'Clean Water', target: 'Desert', value: 1 },
  { source: 'Risk Resilience', target: 'Desert', value: 1 },
  { source: 'Pollination', target: 'Desert', value: 1 },
  { source: 'Erosion Control', target: 'Desert', value: 1 },
  { source: 'Pest & Disease Control', target: 'Desert', value: 1 },
  { source: 'Habitat', target: 'Desert', value: 2 },
  { source: 'Recreation & Experiences', target: 'Desert', value: 2 },
  { source: 'Research & Learning', target: 'Desert', value: 3 },
  { source: 'Aesthetic & Sensory', target: 'Desert', value: 3 },
  { source: 'Art & Inspiration', target: 'Desert', value: 3 },
  { source: 'Existence & Legacy', target: 'Desert', value: 3 },
  { source: 'Raw Materials', target: 'Subterranean', value: 3 },
  { source: 'Food', target: 'Subterranean', value: 1 },
  { source: 'Energy', target: 'Subterranean', value: 3 },
  { source: 'Water Abundance', target: 'Subterranean', value: 3 },
  { source: 'Healthy Soils', target: 'Subterranean', value: 1 },
  { source: 'Medicinal & Genetic', target: 'Subterranean', value: 2 },
  { source: 'Climate Stability', target: 'Subterranean', value: 2 },
  { source: 'Clean Air', target: 'Subterranean', value: 1 },
  { source: 'Clean Water', target: 'Subterranean', value: 3 },
  { source: 'Risk Resilience', target: 'Subterranean', value: 2 },
  { source: 'Erosion Control', target: 'Subterranean', value: 1 },
  { source: 'Pest & Disease Control', target: 'Subterranean', value: 1 },
  { source: 'Habitat', target: 'Subterranean', value: 2 },
  { source: 'Recreation & Experiences', target: 'Subterranean', value: 2 },
  { source: 'Research & Learning', target: 'Subterranean', value: 3 },
  { source: 'Aesthetic & Sensory', target: 'Subterranean', value: 2 },
  { source: 'Art & Inspiration', target: 'Subterranean', value: 2 },
  { source: 'Existence & Legacy', target: 'Subterranean', value: 2 }
];
````

## File: src/modules/exposure/ExposureSankey.tsx
````typescript
import React, { useEffect, useRef, useState } from 'react';
import * as d3 from 'd3';
import { sankey, sankeyLinkHorizontal } from 'd3-sankey';
import { useRouter, useSearchParams } from 'next/navigation';
import { SpecificAsset } from '../specific/SpecificAsset';
import { getAssetIdForNode, hasAsset } from './assetMapping';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';
import { CONTRACTS } from '../specific/config';

interface SankeyData {
  source: string;
  target: string;
  value: number;
}

interface SankeyNode extends d3.SimulationNodeDatum {
  name: string;
  x0?: number;
  x1?: number;
  y0?: number;
  y1?: number;
  layer: number; // 0: sectors, 1: ES, 2: stocks
}

interface SankeyLink extends d3.SimulationLinkDatum<SankeyNode> {
  value: number;
  source: SankeyNode;
  target: SankeyNode;
}

interface ExposureSankeyProps {
  data: SankeyData[];
}

// Helper function to determine node layer
function getNodeLayer(name: string): number {
  if (['Food & Agriculture', 'Energy & Power', 'Manufacturing & Materials', 'Infrastructure & Construction', 'Finance & Insurance', 'Retail', 'Transportation & Logistics'].includes(name)) return 0;
  if (['Rivers & Lakes', 'Tropical Forest', 'Temperate Forest'].includes(name)) return 2;
  return 1; // All other nodes are ES
}

// Custom vertical link path generator
function sankeyLinkVertical() {
  return (d: any) => {
    const sourceX = (d.source.x0 + d.source.x1) / 2;
    const targetX = (d.target.x0 + d.target.x1) / 2;
    const sourceY = d.source.y1;
    const targetY = d.target.y0;
    
    return `M${sourceX},${sourceY}
            C${sourceX},${(sourceY + targetY) / 2}
             ${targetX},${(sourceY + targetY) / 2}
             ${targetX},${targetY}`;
  };
}

// Update link width scaling
const getLinkWidth = (value: number, isActive: boolean = false) => {
  if (isActive) {
    switch (value) {
      case 3: return 16;  // High - even thicker when active
      case 2: return 8;   // Moderate - thicker when active
      case 1: return 2;   // Low - slightly thicker when active
      default: return 2;
    }
  } else {
    switch (value) {
      case 3: return 12;  // High
      case 2: return 4;   // Moderate
      case 1: return 1;   // Low
      default: return 1;
    }
  }
};

// Update node height scaling to use normalized values
const getNodeHeight = (magnitude: number) => {
  const minHeight = 30;  // Smaller minimum for less important nodes
  const maxHeight = 80;  // Cap maximum height for better visual balance
  return minHeight + (magnitude * (maxHeight - minHeight));
};

// Helper function to get node category and type
function getNodeCategory(name: string): { type: string; category: string } {
  if (['Food & Agriculture', 'Energy & Power', 'Manufacturing & Materials', 'Infrastructure & Construction', 'Finance & Insurance', 'Retail', 'Transportation & Logistics'].includes(name)) {
    return { type: 'SECTOR', category: 'economic sector' };
  }
  if (['Rivers & Lakes', 'Tropical Forest', 'Temperate Forest', 'Boreal Forest', 'Coastal Systems', 'Inland Wetlands', 'Cultivated & Developed', 'Urban Open Space', 'Rural Open Space', 'Marine Systems', 'Grasslands', 'Shrublands', 'Polar & Alpine', 'Desert', 'Subterranean'].includes(name)) {
    return { type: 'STOCK', category: 'ecosystem' };
  }
  return { type: 'FLOW', category: 'ecosystem service' };
}

export default function ExposureSankey({ data }: ExposureSankeyProps) {
  const svgRef = useRef<SVGSVGElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const router = useRouter();
  const searchParams = useSearchParams();
  const [hoveredNode, setHoveredNode] = useState<string | null>(null);
  const [selectedNode, setSelectedNode] = useState<string | null>(null);
  const [processedLinks, setProcessedLinks] = useState<SankeyLink[]>([]);
  const [overviewMagnitudes, setOverviewMagnitudes] = useState<Map<string, number>>(new Map());
  
  // Update URL when selection changes
  const updateSelection = (node: string | null) => {
    setSelectedNode(node);
    if (node) {
      const { type } = getNodeCategory(node);
      const param = type.toLowerCase();
      // Replace multiple spaces and special chars with single hyphen
      const cleanName = node.replace(/[^a-zA-Z0-9]+/g, '-').replace(/^-|-$/g, '');
      router.push(`/exposure?${param}=${cleanName}`);
    } else {
      router.push('/exposure');
    }
  };

  // Initialize selected node from URL
  useEffect(() => {
    const sector = searchParams.get('sector');
    const flow = searchParams.get('flow');
    const stock = searchParams.get('stock');
    const selected = sector || flow || stock;
    if (selected) {
      // Find the original node name from the data
      const nodeNames = Array.from(new Set(data.flatMap(d => [d.source, d.target])));
      const originalName = nodeNames.find(name => 
        name.replace(/[^a-zA-Z0-9]+/g, '-').replace(/^-|-$/g, '') === selected
      );
      if (originalName) {
        setSelectedNode(originalName);
      }
    }
  }, [searchParams, data]);

  // Handle click outside to reset selection
  const handleContainerClick = (e: React.MouseEvent) => {
    // Clear selection if click is on container or SVG background
    if (e.target === containerRef.current || e.target === svgRef.current) {
      updateSelection(null);
      setHoveredNode(null);
    }
  };
  
  // Create and update the Sankey diagram
  useEffect(() => {
    if (!data.length) return;
    
    // Force redraw on resize
    const redrawChart = () => {
      if (!containerRef.current || !svgRef.current) return;
      
      // Clear any existing content
      const svg = d3.select(svgRef.current);
      svg.selectAll("*").remove();
      
      // Get the actual dimensions of the container
      const containerRect = containerRef.current.getBoundingClientRect();
      const width = containerRect.width;
      const height = containerRect.height;
      
      if (width === 0 || height === 0) return;
      
      // Debug dimensions
      console.log(`Container dimensions: ${width}x${height}`);
      
      // Set SVG dimensions
      svg
        .attr("width", width)
        .attr("height", height);
      
      // Use larger margins to avoid edges
      const margin = { top: 100, right: 100, bottom: 50, left: 50 };  // Increased right margin
      const innerWidth = width - margin.left - margin.right;
      const innerHeight = height - margin.top - margin.bottom;
      
      // Create nodes array with layer information
      const nodeNames = Array.from(new Set(data.flatMap(d => [d.source, d.target])));
      const nodes: SankeyNode[] = nodeNames.map(name => ({ 
        name,
        layer: getNodeLayer(name)
      }));
      
      // Calculate magnitudes for overview mode (all connections)
      const magnitudes = new Map<string, number>();
      const rowMagnitudes = new Map<number, { min: number, max: number }>();
      
      // First pass: calculate raw magnitudes and find min/max for each row
      nodes.forEach(node => {
        const incomingSum = data
          .filter(d => d.target === node.name)
          .reduce((sum, d) => sum + d.value, 0);
        const outgoingSum = data
          .filter(d => d.source === node.name)
          .reduce((sum, d) => sum + d.value, 0);
        let magnitude;
        if (node.layer === 0) {
          // For industry nodes, use outgoing sum
          magnitude = outgoingSum;
        } else if (node.layer === 1) {
          // For ES nodes, use both
          magnitude = incomingSum + outgoingSum;
        } else {
          // For stock nodes, use incoming sum
          magnitude = incomingSum;
        }
        magnitudes.set(node.name, magnitude);
        // Update row min/max
        const row = rowMagnitudes.get(node.layer) || { min: Infinity, max: -Infinity };
        row.min = Math.min(row.min, magnitude);
        row.max = Math.max(row.max, magnitude);
        rowMagnitudes.set(node.layer, row);
      });

      // Normalize overview magnitudes with a minimum width for sectors
      nodes.forEach(node => {
        const row = rowMagnitudes.get(node.layer)!;
        const rawMagnitude = magnitudes.get(node.name)!;
        let normalizedMagnitude = (rawMagnitude - row.min) / (row.max - row.min);
        
        // Ensure minimum width for sectors
        if (node.layer === 0) {
          normalizedMagnitude = Math.max(normalizedMagnitude, 0.1); // Minimum 10% width for sectors
        }
        
        magnitudes.set(node.name, normalizedMagnitude);
      });

      // Store overview magnitudes for later use
      setOverviewMagnitudes(magnitudes);

      // Function to calculate hover state magnitudes
      const getHoverMagnitudes = (activeNode: string | null) => {
        if (!activeNode) return magnitudes;
        
        const hoverMagnitudes = new Map<string, number>();
        const activeLinks = processedLinks.filter(
          l => l.source.name === activeNode || l.target.name === activeNode
        );
        
        // Calculate magnitudes based on active connections
        nodes.forEach(node => {
          const incomingSum = activeLinks
            .filter(l => l.target.name === node.name)
            .reduce((sum, l) => sum + l.value, 0);
          
          let magnitude;
          if (node.layer === 1) {
            // For ecosystem services, consider both incoming and outgoing
            const outgoingSum = activeLinks
              .filter(l => l.source.name === node.name)
              .reduce((sum, l) => sum + l.value, 0);
            magnitude = Math.max(incomingSum, outgoingSum); // Use max instead of sum
          } else {
            magnitude = incomingSum;
          }
          
          // Ensure minimum magnitude to prevent nodes from disappearing
          hoverMagnitudes.set(node.name, Math.max(magnitude, 0.1));
        });

        // Normalize hover magnitudes within each row
        const rowHoverMagnitudes = new Map<number, { min: number, max: number }>();
        
        // First pass: find min/max for each row
        nodes.forEach(node => {
          const magnitude = hoverMagnitudes.get(node.name)!;
          const row = rowHoverMagnitudes.get(node.layer) || { min: Infinity, max: -Infinity };
          row.min = Math.min(row.min, magnitude);
          row.max = Math.max(row.max, magnitude);
          rowHoverMagnitudes.set(node.layer, row);
        });

        // Second pass: normalize within each row
        nodes.forEach(node => {
          const row = rowHoverMagnitudes.get(node.layer)!;
          const rawMagnitude = hoverMagnitudes.get(node.name)!;
          const normalizedMagnitude = (rawMagnitude - row.min) / (row.max - row.min);
          hoverMagnitudes.set(node.name, normalizedMagnitude);
        });

        return hoverMagnitudes;
      };

      // Create links array
      const links: SankeyLink[] = data.map(d => ({
        source: nodes.find(n => n.name === d.source)!,
        target: nodes.find(n => n.name === d.target)!,
        value: d.value
      }));
      
      // Create Sankey generator
      const sankeyGenerator = sankey<SankeyNode, SankeyLink>()
        .nodeWidth(20)  // Increased node width
        .nodePadding(15) // Increased padding
        .extent([[margin.left, margin.top], [width - margin.right, height - margin.bottom]]);
      
      // Process data
      const { nodes: processedNodes, links: processedLinks } = sankeyGenerator({
        nodes,
        links
      });
      
      // Store processed links for the side panel
      setProcessedLinks(processedLinks);
      
      // --- TRUE BAR LAYOUT LOGIC ---
      // 1. Calculate total magnitude for each layer
      const layerTotals = [0, 1, 2].map(layer =>
        nodes.filter(n => n.layer === layer).reduce((sum, n) => sum + (magnitudes.get(n.name) || 0), 0)
      );

      // 2. Assign segment widths and positions for each node in each layer
      const layerYPositions = [
        margin.top + innerHeight * 0.1,   // Top row
        margin.top + innerHeight * 0.4,   // Middle row
        margin.top + innerHeight * 0.7    // Bottom row
      ];
      const barHeight = 40;
      const barGap = 30;
      const barAreaWidth = innerWidth;

      // For each layer, calculate segment positions
      const nodePositions = new Map<string, { x0: number, x1: number, y0: number, y1: number }>();
      [0, 1, 2].forEach(layer => {
        const layerNodes = nodes.filter(n => n.layer === layer);
        // Sort for visual consistency
        layerNodes.sort((a, b) => a.name.localeCompare(b.name));
        let currentX = margin.left;
        layerNodes.forEach(n => {
          const mag = magnitudes.get(n.name) || 0;
          const width = layerTotals[layer] > 0 ? (mag / layerTotals[layer]) * barAreaWidth : 0;
          nodePositions.set(n.name, {
            x0: currentX,
            x1: currentX + width,
            y0: layerYPositions[layer],
            y1: layerYPositions[layer] + barHeight
          });
          currentX += width;
        });
      });

      // Helper: get set of connected node names for a given node
      function getConnectedNodes(nodeName: string) {
        const connected = new Set<string>();
        links.forEach(l => {
          if (l.source.name === nodeName) connected.add(l.target.name);
          if (l.target.name === nodeName) connected.add(l.source.name);
        });
        return connected;
      }
      const activeNode = selectedNode || hoveredNode;
      const connectedNodes = activeNode ? getConnectedNodes(activeNode) : new Set();

      // 3. Draw bars (segments) with isolation effect
      const mainGroup = svg.append('g');
      
      // Create a separate group for labels that will be rendered on top
      const labelGroup = svg.append('g').style('z-index', '10');

      // Add row labels
      const rowLabels = ['SECTORS', 'FLOWS', 'STOCKS'];
      const rowAssetIds = [null, 5, 4]; // Asset IDs for each row
      [0, 1, 2].forEach(layer => {
        const yPos = layerYPositions[layer] + (barHeight / 2) - 25;
        const labelGroup = mainGroup.append('g')
          .attr('transform', `translate(${margin.left - 10}, ${yPos})`);

        // Add the row label
        const textElement = labelGroup.append('text')
          .attr('text-anchor', 'end')
          .attr('transform', `rotate(-90, 0, 0)`)
          .text(rowLabels[layer])
          .style('font-size', '14px')
          .style('font-family', 'Inter, system-ui, sans-serif')
          .style('font-weight', '700')
          .style('fill', '#aaa')
          .style('text-transform', 'uppercase')
          .style('letter-spacing', '0.05em')
          .style('z-index', '10');

        // Add + button if there's an asset ID
        if (rowAssetIds[layer] !== null) {
          // Aggressively move the + button left and tightly inline with the end of the label
          const buttonGroup = labelGroup.append('g')
            .attr('transform', `translate(-4, -12) rotate(-90)`)
            .style('cursor', 'pointer')
            .on('click', (e) => {
              e.stopPropagation();
              window.location.href = `/specific/${CONTRACTS.specific}/${rowAssetIds[layer]}`;
            });

          // Add button background
          buttonGroup.append('circle')
            .attr('r', 8)
            .style('fill', 'rgba(0,0,0,0.4)');

          // Add plus icon (white by default)
          const plusPath = buttonGroup.append('path')
            .attr('d', 'M-4,0 L4,0 M0,-4 L0,4')
            .style('stroke', '#fff')
            .style('stroke-width', '1.5')
            .style('stroke-linecap', 'round');

          // Add tooltip
          const tooltip = buttonGroup.append('text')
            .attr('y', -12)
            .attr('text-anchor', 'middle')
            .style('font-size', '10px')
            .style('fill', '#fff')
            .style('opacity', 0)
            .style('pointer-events', 'none')
            .text(`Purchase ${rowLabels[layer].toLowerCase()} Natural Capital Ensurance`);

          // Show tooltip and change plus color on hover
          buttonGroup
            .on('mouseover', () => {
              tooltip.style('opacity', 1);
              plusPath.style('stroke', '#22c55e');
            })
            .on('mouseout', () => {
              tooltip.style('opacity', 0);
              plusPath.style('stroke', '#fff');
            });
        }
      });

      // Color scale
      const colorScale = d3.scaleOrdinal<string>()
        .domain(nodeNames)
        .range([
          // Sectors (layer 0) - Business/Anthropogenic colors
          '#2C3E50', // Deep blue-gray (Finance)
          '#E74C3C', // Red (Energy)
          '#F39C12', // Orange (Manufacturing)
          '#27AE60', // Green (Agriculture)
          '#8E44AD', // Purple (Infrastructure)
          '#16A085', // Teal (Retail)
          '#D35400', // Dark orange (Transportation)
          
          // Flows (layer 1) - Dynamic/Fluid colors
          '#00BCD4', // Cyan (Water)
          '#4CAF50', // Green (Air)
          '#9C27B0', // Purple (Nutrients)
          '#FF9800', // Orange (Carbon)
          '#2196F3', // Blue (Energy)
          '#FFEB3B', // Yellow (Food)
          '#795548', // Brown (Materials)
          
          // Stocks (layer 2) - Earth/Grounded tones
          '#1B5E20', // Dark green (Forests)
          '#0D47A1', // Deep blue (Water)
          '#33691E', // Dark olive (Grasslands)
          '#004D40', // Dark teal (Wetlands)
          '#3E2723', // Dark brown (Soil)
          '#263238', // Dark blue-gray (Urban)
          '#827717'  // Dark lime (Desert)
        ]);

      // Adjust link colors to be more subtle
      const getLinkColor = (source: string): string => {
        const color = d3.color(colorScale(source));
        return color ? color.copy({ opacity: 0.25 }).toString() : '#ccc';
      };

      [0, 1, 2].forEach(layer => {
        const layerNodes = nodes.filter(n => n.layer === layer);
        const group = mainGroup.append('g').attr('class', `bar-layer-${layer}`);
        layerNodes.forEach(n => {
          const pos = nodePositions.get(n.name)!;
          // Determine opacity
          let opacity = 1;
          if (activeNode) {
            const activeNodeType = getNodeCategory(activeNode).type;
            if (activeNodeType === 'SECTOR') {
              // For sectors, show the sector, its connected flows, and all stocks
              if (n.name === activeNode || 
                  connectedNodes.has(n.name) || 
                  getNodeCategory(n.name).type === 'STOCK') {
                opacity = 1;
              } else {
                opacity = 0.1;
              }
            } else {
              // For other nodes, show only direct connections
              if (n.name === activeNode || connectedNodes.has(n.name)) {
                opacity = 1;
              } else {
                opacity = 0.1;
              }
            }
          } else {
            // Default state: calm but readable
            opacity = 0.85;
          }
          group.append('rect')
            .attr('x', pos.x0)
            .attr('y', pos.y0)
            .attr('width', pos.x1 - pos.x0)
            .attr('height', barHeight)
            .attr('fill', colorScale(n.name) as string)
            .attr('stroke', '#000')
            .attr('rx', 6)
            .attr('ry', 6)
            .style('cursor', 'pointer')
            .style('opacity', opacity)
            .on('mouseover', () => setHoveredNode(n.name))
            .on('mouseout', () => { if (!selectedNode) setHoveredNode(null); })
            .on('click', () => updateSelection(n.name));
          // Add label
          const label = labelGroup.append('text')
            .attr('x', (pos.x0 + pos.x1) / 2)
            .attr('y', pos.y0 - 36)  // Increased spacing slightly more
            .attr('text-anchor', 'middle')
            .attr('transform', `rotate(-45, ${(pos.x0 + pos.x1) / 2}, ${pos.y0 - 36})`)
            .text(n.name)
            .style('font-size', '11px')
            .style('font-family', 'Inter, system-ui, sans-serif')
            .style('font-weight', '500')
            .style('fill', '#fff')
            .style('pointer-events', 'none')
            .style('text-shadow', '0 1px 2px rgba(0,0,0,0.8)')
            .style('white-space', 'nowrap')
            .style('opacity', 0.85 * opacity);

          // Add background for better readability
          const bbox = label.node()?.getBBox();
          if (bbox) {
            labelGroup.insert('rect', 'text')
              .attr('x', bbox.x - 4)
              .attr('y', bbox.y - 2)
              .attr('width', bbox.width + 8)
              .attr('height', bbox.height + 4)
              .attr('rx', 4)
              .attr('ry', 4)
              .style('fill', 'rgba(0,0,0,0.4)')
              .style('opacity', 0.85 * opacity)
              .style('transform', `translateY(-${bbox.height/2}px)`); // Shift background up to avoid node overlap
          }

          // Add SpecificAsset button if node is active and has an asset
          if (n.name === activeNode && hasAsset(n.name) && bbox) {
            // Place the + button at the end of the diagonal label, with more space
            const padding = 12;
            const angle = -45 * (Math.PI / 180); // radians
            const dx = (bbox.width / 2 + padding) * Math.cos(angle);
            const dy = (bbox.width / 2 + padding) * Math.sin(angle);
            const buttonGroup = labelGroup.append('g')
              .attr('transform', `translate(${(pos.x0 + pos.x1) / 2 + dx}, ${pos.y0 - 36 + dy})`)
              .style('cursor', 'pointer')
              .on('click', (e) => {
                e.stopPropagation(); // Prevent node selection
                window.location.href = `/specific/${CONTRACTS.specific}/${getAssetIdForNode(n.name)}`;
              });

            // Add button background
            buttonGroup.append('circle')
              .attr('r', 8)
              .style('fill', 'rgba(0,0,0,0.4)')
              .style('opacity', 0.85 * opacity);

            // Add plus icon (white by default)
            const plusPath = buttonGroup.append('path')
              .attr('d', 'M-4,0 L4,0 M0,-4 L0,4')
              .style('stroke', '#fff')
              .style('stroke-width', '1.5')
              .style('stroke-linecap', 'round');

            // Add tooltip
            const tooltip = buttonGroup.append('text')
              .attr('y', -12)
              .attr('text-anchor', 'middle')
              .style('font-size', '10px')
              .style('fill', '#fff')
              .style('opacity', 0)
              .style('pointer-events', 'none')
              .text(getNodeCategory(n.name).type === 'SECTOR' 
                ? `Purchase ${n.name} Industry Ensurance`
                : `Purchase ${n.name} Natural Capital Ensurance`);

            // Show tooltip and change plus color on hover
            buttonGroup
              .on('mouseover', () => {
                tooltip.style('opacity', 1);
                plusPath.style('stroke', '#22c55e');
              })
              .on('mouseout', () => {
                tooltip.style('opacity', 0);
                plusPath.style('stroke', '#fff');
              });
          }
        });
      });

      // 4. Draw links using new positions, with isolation effect
      mainGroup.append('g')
        .selectAll('path')
        .data(links)
        .join('path')
        .attr('d', d => {
          const source = nodePositions.get(d.source.name)!;
          const target = nodePositions.get(d.target.name)!;
          const sourceX = (source.x0 + source.x1) / 2;
          const sourceY = source.y1;
          const targetX = (target.x0 + target.x1) / 2;
          const targetY = target.y0;
          return `M${sourceX},${sourceY} C${sourceX},${(sourceY + targetY) / 2} ${targetX},${(sourceY + targetY) / 2} ${targetX},${targetY}`;
        })
        .attr('fill', 'none')
        .attr('stroke', d => getLinkColor(d.source.name))
        .attr('stroke-width', d => {
          const isActive = d.source.name === activeNode || d.target.name === activeNode;
          return getLinkWidth(d.value, isActive);
        })
        .style('transition', 'opacity 0.3s, stroke-width 0.3s')
        .style('opacity', d => {
          if (!activeNode) return 0.25;
          const activeNodeType = getNodeCategory(activeNode).type;
          
          if (activeNodeType === 'SECTOR') {
            // For sectors, show both direct connections and flow-to-stock connections
            return (d.source.name === activeNode || 
                   (getNodeCategory(d.source.name).type === 'FLOW' && 
                    getNodeCategory(d.target.name).type === 'STOCK')) ? 1 : 0.1;
          }
          
          // For other nodes, show only direct connections
          return (d.source.name === activeNode || d.target.name === activeNode) ? 1 : 0.1;
        });
    };
    
    // Initial render
    redrawChart();
    
    // Add resize listener
    window.addEventListener('resize', redrawChart);
    
    // Cleanup
    return () => {
      window.removeEventListener('resize', redrawChart);
    };
  }, [data, selectedNode, hoveredNode]);
  
  return (
    <div className="flex w-full h-full">
      <div 
        ref={containerRef} 
        className="w-3/4 h-full" 
        style={{
          position: 'relative'
        }}
        onClick={handleContainerClick}
      >
        <svg 
          ref={svgRef} 
          style={{
            display: 'block',
            width: '100%',
            height: '100%'
          }} 
        />
      </div>
      
      <div 
        className="w-1/4 h-full bg-black/5 border-l border-gray-800/60 p-4 overflow-y-auto"
        style={{
          backdropFilter: 'blur(4px)',
          position: 'relative',
          height: 'auto',
        }}
      >
        {(hoveredNode || selectedNode) ? (
          <div className="space-y-4">
            {selectedNode && (
              <button
                onClick={() => {
                  updateSelection(null);
                  setHoveredNode(null);
                }}
                className="absolute top-4 right-4 w-6 h-6 flex items-center justify-center text-gray-500 hover:text-gray-700 hover:bg-gray-100 rounded-full transition-colors"
                aria-label="Clear selection"
              >
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                  <line x1="18" y1="6" x2="6" y2="18"></line>
                  <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
              </button>
            )}
            <div className="border-b border-gray-200 pb-4">
              <div className="flex items-center gap-2 mb-1">
                <h3 className="font-bold text-xl">{selectedNode || hoveredNode}</h3>
                {(() => {
                  const nodeName = selectedNode || hoveredNode;
                  if (!nodeName) return null;
                  return hasAsset(nodeName) && (
                    <TooltipProvider>
                      <Tooltip>
                        <TooltipTrigger>
                          <SpecificAsset tokenId={getAssetIdForNode(nodeName)!} />
                        </TooltipTrigger>
                        <TooltipContent>
                          {getNodeCategory(nodeName).type === 'SECTOR' 
                            ? `Purchase ${nodeName} Industry Ensurance`
                            : `Purchase ${nodeName} Natural Capital Ensurance`
                          }
                        </TooltipContent>
                      </Tooltip>
                    </TooltipProvider>
                  );
                })()}
              </div>
              {(() => {
                const nodeName = selectedNode || hoveredNode;
                if (!nodeName) return null;
                const { type, category } = getNodeCategory(nodeName);
                return (
                  <div className="flex items-center gap-2 text-sm text-gray-600">
                    <span className="font-medium">{type}</span>
                    <span className="text-gray-400">|</span>
                    <span>{category}</span>
                  </div>
                );
              })()}
            </div>
            
            <div className="space-y-2">
              {/* Custom connection logic by node type */}
              {(() => {
                const nodeName = selectedNode || hoveredNode;
                if (!nodeName) return null;
                const { type } = getNodeCategory(nodeName);
                // Helper to convert value to label and color
                const valueLabel = (v: number) => v === 1 ? 'low' : v === 2 ? 'moderate' : v === 3 ? 'high' : v;
                // Use yellow for moderate for better aesthetics
                const valueColor = (v: number) => v === 1 ? 'text-green-700' : v === 2 ? 'text-yellow-500' : v === 3 ? 'text-red-600' : 'text-gray-600';
                if (type === 'SECTOR') {
                  const flows = processedLinks
                    .filter(l => l.source.name === nodeName)
                    .map(l => ({ name: l.target.name, value: l.value }));
                  return (
                    <>
                      <h4 className="font-grotesk font-medium text-xs text-gray-700 mb-1 uppercase tracking-wide">Flows</h4>
                      <div className="space-y-1">
                        {flows.map((f, i) => (
                          <div key={i} className="text-sm flex items-center font-grotesk">
                            <span>{f.name}</span>
                            <span className={`ml-2 font-mono font-medium ${valueColor(f.value)}`}>{valueLabel(f.value)}</span>
                          </div>
                        ))}
                      </div>
                    </>
                  );
                } else if (type === 'FLOW') {
                  const sectors = processedLinks
                    .filter(l => l.target.name === nodeName && getNodeCategory(l.source.name).type === 'SECTOR')
                    .map(l => ({ name: l.source.name, value: l.value }));
                  const stocks = processedLinks
                    .filter(l => l.source.name === nodeName && getNodeCategory(l.target.name).type === 'STOCK')
                    .map(l => ({ name: l.target.name, value: l.value }));
                  return (
                    <>
                      <h4 className="font-grotesk font-medium text-xs text-gray-700 mb-1 uppercase tracking-wide">Sectors</h4>
                      <div className="space-y-1 mb-2">
                        {sectors.map((s, i) => (
                          <div key={i} className="text-sm flex items-center font-grotesk">
                            <span>{s.name}</span>
                            <span className={`ml-2 font-mono font-medium ${valueColor(s.value)}`}>{valueLabel(s.value)}</span>
                          </div>
                        ))}
                      </div>
                      <h4 className="font-grotesk font-medium text-xs text-gray-700 mb-1 uppercase tracking-wide">Stocks</h4>
                      <div className="space-y-1">
                        {stocks.map((s, i) => (
                          <div key={i} className="text-sm flex items-center font-grotesk">
                            <span>{s.name}</span>
                            <span className={`ml-2 font-mono font-medium ${valueColor(s.value)}`}>{valueLabel(s.value)}</span>
                          </div>
                        ))}
                      </div>
                    </>
                  );
                } else if (type === 'STOCK') {
                  const flows = processedLinks
                    .filter(l => l.target.name === nodeName && getNodeCategory(l.source.name).type === 'FLOW')
                    .map(l => ({ name: l.source.name, value: l.value }));
                  return (
                    <>
                      <h4 className="font-grotesk font-medium text-xs text-gray-700 mb-1 uppercase tracking-wide">Flows</h4>
              <div className="space-y-1">
                        {flows.map((f, i) => (
                          <div key={i} className="text-sm flex items-center font-grotesk">
                            <span>{f.name}</span>
                            <span className={`ml-2 font-mono font-medium ${valueColor(f.value)}`}>{valueLabel(f.value)}</span>
                    </div>
                  ))}
              </div>
                    </>
                  );
                }
                return null;
              })()}
            </div>

            <div className="space-y-2">
              <h4 className="font-grotesk font-medium text-xs text-gray-700 mb-1 uppercase tracking-wide">Magnitude</h4>
              <div className="text-sm font-mono font-medium text-white">
                {(() => {
                  const nodeName = selectedNode || hoveredNode;
                  if (!nodeName) return null;
                  // Sum all in and out values for this node
                  const total = processedLinks
                    .filter((l: SankeyLink) => l.source.name === nodeName || l.target.name === nodeName)
                    .reduce((sum: number, l: SankeyLink) => sum + l.value, 0);
                  return total;
                })()}
              </div>
            </div>
          </div>
        ) : (
          <div className="text-gray-500 text-sm">
            Hover or click to explore nature risk exposure
          </div>
        )}
      </div>
    </div>
  );
}
````

## File: src/modules/general/service/hooks.ts
````typescript
import { usePrivy } from '@privy-io/react-auth'
import { useCallback, useState, useEffect } from 'react'
import { GeneralService } from '.'
import type { CoinDetails, TradingInfo } from './types'

export function useGeneralService() {
  const { user, authenticated } = usePrivy()

  const getCoinDetails = useCallback(async (contractAddress: string): Promise<CoinDetails | null> => {
    return GeneralService.getCoinDetails(contractAddress)
  }, [])

  const getTradingInfo = useCallback(async (contractAddress: string): Promise<TradingInfo | null> => {
    return GeneralService.getTradingInfo(contractAddress)
  }, [])

  const getBuyConfig = useCallback((contractAddress: `0x${string}`, amount: bigint) => {
    if (!authenticated || !user?.wallet?.address) return null
    return GeneralService.getBuyConfig(contractAddress, amount, user.wallet.address as `0x${string}`)
  }, [authenticated, user?.wallet?.address])

  const getSellConfig = useCallback((contractAddress: `0x${string}`, amount: bigint) => {
    if (!authenticated || !user?.wallet?.address) return null
    return GeneralService.getSellConfig(contractAddress, amount, user.wallet.address as `0x${string}`)
  }, [authenticated, user?.wallet?.address])

  return {
    getCoinDetails,
    getTradingInfo,
    getBuyConfig,
    getSellConfig,
    isAuthenticated: authenticated,
    userAddress: user?.wallet?.address as `0x${string}` | undefined
  }
}

export function useTokenPrice(symbol: string = 'ETH') {
  const [price, setPrice] = useState<number>(0)
  const [isLoading, setIsLoading] = useState(true)
  const [lastUpdated, setLastUpdated] = useState<string>('')

  useEffect(() => {
    const fetchPrice = async () => {
      try {
        const response = await fetch('/api/eth-price')
        if (!response.ok) throw new Error('Failed to fetch token price')
        const data = await response.json()
        setPrice(data.price)
        setLastUpdated(data.lastUpdated)
      } catch (error) {
        console.error('Error fetching token price:', error)
        // Don't set a fallback price, just log the error
      } finally {
        setIsLoading(false)
      }
    }

    fetchPrice()
    // Refresh price every 5 minutes
    const interval = setInterval(fetchPrice, 5 * 60 * 1000)
    return () => clearInterval(interval)
  }, [])

  return { price, isLoading, lastUpdated }
}

// Keep the old hook name for backward compatibility
export const useEthPrice = () => useTokenPrice('ETH')
````

## File: src/modules/general/service/index.ts
````typescript
import { createPublicClient, http } from 'viem'
import { base } from 'viem/chains'
import { getCoin, tradeCoin } from '@zoralabs/coins-sdk'
import type { CoinDetails, TradingInfo, TradeConfig, ZoraTradeConfig } from './types'
import ZORA_COIN_ABI from '@/abi/ZoraCoin.json'

// Initialize viem client for Base network
const publicClient = createPublicClient({
  chain: base,
  transport: http('https://mainnet.base.org')
})

export const TRADE_REFERRER = '0x7EdDce062a290c59feb95E2Bd7611eeE24610A6b' as `0x${string}`

export const GeneralService = {
  /**
   * Get ETH balance for an address
   */
  async getEthBalance(address: `0x${string}`): Promise<bigint> {
    try {
      return await publicClient.getBalance({ address })
    } catch (error) {
      console.error('Failed to fetch ETH balance:', error)
      return BigInt(0)
    }
  },

  /**
   * Get token balance for an address
   */
  async getTokenBalance(tokenAddress: `0x${string}`, address: `0x${string}`): Promise<bigint> {
    try {
      return await publicClient.readContract({
        address: tokenAddress,
        abi: ZORA_COIN_ABI,
        functionName: 'balanceOf',
        args: [address]
      }) as bigint
    } catch (error) {
      console.error('Failed to fetch token balance:', error)
      return BigInt(0)
    }
  },

  /**
   * Get coin details from Zora API
   */
  async getCoinDetails(contractAddress: string): Promise<CoinDetails | null> {
    try {
      const response = await getCoin({
        address: contractAddress,
        chain: 8453 // Base chain ID
      })
      
      const coin = response.data?.zora20Token
      if (!coin) return null

      return {
        name: coin.name || '',
        symbol: coin.symbol || '',
        totalSupply: coin.totalSupply || '0',
        totalVolume: coin.totalVolume || '0',
        volume24h: coin.volume24h || '0',
        createdAt: coin.createdAt || '',
        creatorAddress: coin.creatorAddress as `0x${string}` || '0x0000000000000000000000000000000000000000',
        description: coin.description || '',
        marketCap: coin.marketCap || '0',
        uniqueHolders: coin.uniqueHolders || 0
      }
    } catch (error) {
      console.error('Failed to fetch coin details:', error)
      return null
    }
  },

  /**
   * Get trading info for a coin
   */
  async getTradingInfo(contractAddress: string): Promise<TradingInfo | null> {
    try {
      const response = await getCoin({
        address: contractAddress,
        chain: 8453 // Base chain ID
      })
      
      const coin = response.data?.zora20Token
      if (!coin) return null

      return {
        totalVolume: coin.totalVolume || '0',
        volume24h: coin.volume24h || '0',
        price: coin.marketCap && coin.totalSupply ? 
          (Number(coin.marketCap) / Number(coin.totalSupply)).toString() : 
          '0',
        marketCap: coin.marketCap || '0'
      }
    } catch (error) {
      console.error('Failed to fetch trading info:', error)
      return null
    }
  },

  /**
   * Get transaction config for buying coins
   */
  getBuyConfig(contractAddress: `0x${string}`, amount: bigint, recipient: `0x${string}`): ZoraTradeConfig {
    return {
      direction: 'buy',
      target: contractAddress,
      args: {
        recipient,
        orderSize: amount, // For buys, this is ETH amount
        tradeReferrer: TRADE_REFERRER
      }
    }
  },

  /**
   * Get transaction config for selling coins
   */
  getSellConfig(contractAddress: `0x${string}`, amount: bigint, recipient: `0x${string}`): ZoraTradeConfig {
    return {
      direction: 'sell',
      target: contractAddress,
      args: {
        recipient,
        orderSize: amount, // For sells, this is token amount
        tradeReferrer: TRADE_REFERRER
      }
    }
  }
}
````

## File: src/modules/general/service/types.ts
````typescript
export interface CoinDetails {
  name: string
  symbol: string
  totalSupply: string
  totalVolume: string
  volume24h: string
  createdAt: string
  creatorAddress: `0x${string}`
  description?: string
  price?: string
  marketCap?: string
  uniqueHolders?: number
}

export interface TradingInfo {
  totalVolume: string
  volume24h: string
  price: string
  marketCap: string
}

// Zora SDK Types
export interface ZoraTradeArgs {
  recipient: `0x${string}`
  orderSize: bigint
  minAmountOut?: bigint
  sqrtPriceLimitX96?: bigint
  tradeReferrer?: `0x${string}`
}

export interface ZoraTradeConfig {
  direction: 'buy' | 'sell'
  target: `0x${string}`
  args: ZoraTradeArgs
}

// Service Types
export interface TradeConfig {
  address: `0x${string}`
  abi: any
  functionName: string
  args: unknown[]
  value?: bigint
  chain: {
    id: number
    name: string
  }
}
````

## File: src/modules/general/Details.tsx
````typescript
// TODO: Consider moving this component to the page level for consistency with specific/[contract]/[tokenId]/page.tsx
// Current separation provides better code organization but creates inconsistency in the codebase
// Need to evaluate if the benefits of separation outweigh the inconsistency
'use client'

import { useEffect, useState } from 'react'
import Image from 'next/image'
import { Button } from '@/components/ui/button'
import { Card, CardContent } from '@/components/ui/card'
import { ChevronDown, ChevronUp } from 'lucide-react'
import { EnsureButtons } from '@/modules/ensure/buttons'
import { Proceeds } from '@/modules/proceeds/components/Proceeds'
import { createPublicClient, http } from 'viem'
import { base } from 'viem/chains'
import ZORA_COIN_ABI from '@/abi/ZoraCoin.json'
import { formatEther } from 'viem'

const FALLBACK_IMAGE = '/assets/no-image-found.png'

// Convert IPFS URL to use a gateway
const convertIpfsUrl = (url: string) => {
  if (url?.startsWith('ipfs://')) {
    return url.replace('ipfs://', 'https://magic.decentralized-content.com/ipfs/')
  }
  return url
}

interface CertificateData {
  name: string
  symbol: string
  total_volume: string
  market_cap: string
  token_uri: string
  contract_address: string
  unique_holders: string
  total_supply: string
}

interface DetailsProps {
  contractAddress: `0x${string}`
  name?: string
  tokenUri?: string
  payout_recipient?: string
  provenance?: string
  initial_supply?: string
}

// Format number to human readable format (k, M)
const formatToHumanReadable = (num: number): string => {
  if (num === 0) return '0'
  if (num < 1000) return num.toString()
  
  if (num < 1000000) {
    // Format as k
    const value = num / 1000
    return value < 10 ? value.toFixed(1) + 'k' : Math.floor(value) + 'k'
  } else {
    // Format as M
    const value = num / 1000000
    return value < 10 ? value.toFixed(1) + 'M' : Math.floor(value) + 'M'
  }
}

// Convert string number with decimals to regular number
const parseTokenAmount = (amount: string): number => {
  try {
    // Handle scientific notation and convert to regular number
    const normalizedNum = Number(amount).toString()
    
    // If the number has a decimal point, remove 18 decimal places
    if (normalizedNum.includes('.')) {
      const [whole, decimal] = normalizedNum.split('.')
      const paddedDecimal = decimal.padEnd(18, '0')
      return Number(whole + paddedDecimal.slice(0, 18)) / Math.pow(10, 18)
    }
    
    // If it's a whole number, divide by 10^18
    return Number(amount) / Math.pow(10, 18)
  } catch (error) {
    console.error('Error parsing token amount:', error)
    return 0
  }
}

export default function Details({ 
  contractAddress,
  name = '',
  tokenUri,
  payout_recipient,
  provenance,
  initial_supply
}: DetailsProps) {
  const [metadata, setMetadata] = useState<any>(null)
  const [certificateData, setCertificateData] = useState<CertificateData | null>(null)
  const [isDescriptionExpanded, setIsDescriptionExpanded] = useState(false)
  const [maxSupply, setMaxSupply] = useState<bigint>(BigInt(0))
  const [currentSupply, setCurrentSupply] = useState<bigint>(BigInt(0))
  const [isLoadingSupply, setIsLoadingSupply] = useState(false)

  // Helper function to delay execution
  const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms))

  // Fetch data from DB and contract
  useEffect(() => {
    const fetchData = async () => {
      try {
        // Fetch from DB
        const response = await fetch('/api/general')
        if (!response.ok) throw new Error('Failed to fetch data')
        const data = await response.json()
        const certificate = data.find((cert: CertificateData) => cert.contract_address === contractAddress)
        if (certificate) {
          setCertificateData(certificate)
        }

        // Fetch from contract
        setIsLoadingSupply(true)
        const publicClient = createPublicClient({
          chain: base,
          transport: http('https://base.blockpi.network/v1/rpc/public')
        })

        // Get max supply and current supply
        try {
          const [max, current] = await Promise.all([
            publicClient.readContract({
              address: contractAddress,
              abi: ZORA_COIN_ABI,
              functionName: 'MAX_TOTAL_SUPPLY'
            }).catch(() => {
              // If MAX_TOTAL_SUPPLY fails, it's likely a V4 contract
              // Use 1 billion as fallback
              return BigInt(1_000_000_000)
            }),
            publicClient.readContract({
              address: contractAddress,
              abi: ZORA_COIN_ABI,
              functionName: 'totalSupply'
            })
          ])

          setMaxSupply(max as bigint)
          setCurrentSupply(current as bigint)
        } catch (error) {
          console.error('Error fetching supply data:', error)
          // Set fallback values
          setMaxSupply(BigInt(1_000_000_000))
          setCurrentSupply(BigInt(0))
        }
      } catch (error) {
        console.error('Error fetching data:', error)
      } finally {
        setIsLoadingSupply(false)
      }
    }
    fetchData()
  }, [contractAddress])

  // Fetch metadata
  useEffect(() => {
    const fetchMetadata = async () => {
      try {
        const response = await fetch(convertIpfsUrl(tokenUri ?? ''))
        if (response.ok) {
          const data = await response.json()
          setMetadata(data)
        }
      } catch (error) {
        console.error('Failed to fetch metadata:', error)
      }
    }
    fetchMetadata()
  }, [tokenUri])

  const imageUrl = convertIpfsUrl((metadata && typeof metadata.image === 'string' ? metadata.image : '')) || FALLBACK_IMAGE
  const videoUrl = metadata?.animation_url ? convertIpfsUrl((metadata && typeof metadata.animation_url === 'string' ? metadata.animation_url : '')) : null

  const renderDescription = (description: string) => {
    if (!description) return null;
    
    const maxLength = 150;
    const shouldTruncate = description.length > maxLength;
    
    if (!shouldTruncate) {
      return <span className="whitespace-pre-wrap">{description}</span>;
    }

    const displayText = isDescriptionExpanded 
      ? description 
      : `${description.slice(0, maxLength)}...`;

    return (
      <div className="space-y-2">
        <span className="whitespace-pre-wrap">{displayText}</span>
        <button
          onClick={() => setIsDescriptionExpanded(!isDescriptionExpanded)}
          className="text-sm text-primary hover:text-primary/80 flex items-center gap-1"
        >
          {isDescriptionExpanded ? (
            <>
              show less <ChevronUp className="w-4 h-4" />
            </>
          ) : (
            <>
              show more <ChevronDown className="w-4 h-4" />
            </>
          )}
        </button>
      </div>
    );
  };

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
      {/* Media Display */}
      <Card className="bg-primary-dark border-0">
        <CardContent className="p-4">
          <div className="relative w-full aspect-square rounded-lg overflow-hidden bg-black/20">
            {videoUrl ? (
              <video
                src={videoUrl}
                poster={imageUrl}
                loop
                controls
                playsInline
                className="absolute inset-0 w-full h-full object-cover"
              />
            ) : (
              <Image
                src={imageUrl}
                alt={name || ''}
                fill
                sizes="(max-width: 768px) 100vw, 50vw"
                priority
                className="object-cover"
                unoptimized={imageUrl?.toLowerCase?.()?.endsWith('.gif') || false}
                onError={(e: any) => {
                  e.target.src = FALLBACK_IMAGE
                }}
              />
            )}
          </div>
        </CardContent>
      </Card>

      {/* Details */}
      <div className="space-y-6">
        {/* Header */}
        <h1 className="text-3xl font-bold">{name}</h1>
        
        {/* Description */}
        {metadata?.description && (
          <div className="prose dark:prose-invert max-w-none">
            <div className="text-base leading-relaxed text-gray-200">
              {renderDescription(metadata.description ?? '')}
            </div>
          </div>
        )}

        {certificateData && (
          <>
            {/* Metrics Card */}
            <Card className="bg-primary-dark/50 border-gray-800">
              <CardContent className="p-6">
                <div className="grid grid-cols-4 gap-6">
                  <div>
                    <h3 className="text-sm text-gray-400 mb-1">market cap</h3>
                    <p className="text-xl font-semibold">${Number(certificateData.market_cap || '0').toLocaleString(undefined, { 
                      minimumFractionDigits: Number(certificateData.market_cap || '0') < 10 ? 2 : 0,
                      maximumFractionDigits: Number(certificateData.market_cap || '0') < 10 ? 2 : 0
                    })}</p>
                  </div>
                  <div>
                    <h3 className="text-sm text-gray-400 mb-1">volume</h3>
                    <p className="text-xl font-semibold">${Number(certificateData.total_volume || '0').toLocaleString(undefined, { 
                      minimumFractionDigits: Number(certificateData.total_volume || '0') < 10 ? 2 : 0,
                      maximumFractionDigits: Number(certificateData.total_volume || '0') < 10 ? 2 : 0
                    })}</p>
                  </div>
                  <div>
                    <h3 className="text-sm text-gray-400 mb-1">ensurers</h3>
                    <p className="text-xl font-semibold">{Number(certificateData.unique_holders || '0').toLocaleString()}</p>
                  </div>
                  <div>
                    <h3 className="text-sm text-gray-400 mb-1">burned</h3>
                    <p className="text-xl font-semibold">
                      {isLoadingSupply ? (
                        <span className="text-gray-400">loading...</span>
                      ) : (
                        (() => {
                          const burned = maxSupply - currentSupply
                          return formatToHumanReadable(Number(formatEther(burned)))
                        })()
                      )}
                    </p>
                  </div>
                </div>
              </CardContent>
            </Card>

            {/* Ensure Buttons */}
            <div className="flex flex-col items-center gap-6 pt-2">
              <div className="w-full flex justify-center">
                <EnsureButtons
                  contractAddress={contractAddress}
                  tokenSymbol={certificateData?.symbol || 'TOKEN'}
                  tokenName={certificateData?.name}
                  imageUrl={String(convertIpfsUrl(metadata?.image ?? '') || FALLBACK_IMAGE)}
                  context="general"
                />
              </div>
            </div>

            {/* Proceeds Section */}
            {(payout_recipient || provenance || initial_supply) && (
              <div className="pt-6">
                <Proceeds 
                  payout_recipient={payout_recipient ?? ''}
                  provenance={provenance}
                  initial_supply={initial_supply}
                />
              </div>
            )}
          </>
        )}
      </div>
    </div>
  )
}
````

## File: src/modules/general/GeneralGrid.tsx
````typescript
'use client'

import React, { useState, useEffect, useCallback, useMemo } from 'react'
import { Card, CardContent } from "@/components/ui/card"
import { Skeleton } from "@/components/ui/skeleton"
import Link from 'next/link'
import Image from 'next/image'

import { Grid, List, ArrowUpDown } from 'lucide-react'
import GeneralList from './GeneralList'
import { CONTRACTS } from '@/modules/specific/config'
import { cn } from '@/lib/utils'
import { EnsureButtonsLite } from '@/modules/ensure/buttons'

interface CreatorEarning {
  amountUsd: string
  // Add other fields if needed
}

export interface GeneralCertificate {
  contract_address: string
  name: string
  token_uri: string
  image_url?: string
  video_url?: string
  total_volume?: string
  market_cap?: string
  creator_earnings?: CreatorEarning[]
  description?: string
  specific_asset_id?: number
  is_specific?: boolean
}

interface GeneralGridProps {
  searchQuery?: string
  urlPrefix?: string
  onDataChange?: (data: GeneralCertificate[]) => void
  isMiniApp?: boolean
  isOverview?: boolean
  hideMarketData?: boolean
  accountContext?: {
    name: string
    specific_asset_id?: number
  }
}

type ViewMode = 'grid' | 'list'
type SortField = 'name' | 'market_cap' | 'total_volume'
type SortDirection = 'asc' | 'desc'

interface SortConfig {
  field: SortField
  direction: SortDirection
}

const SORT_CYCLES: SortField[] = ['name', 'market_cap', 'total_volume']

const FALLBACK_IMAGE = '/assets/no-image-found.png'

// Default certificates to always show in tend view
const DEFAULT_CERTIFICATES = [
  '0xd741057abca8fd4c0b99d2cd4c7a38c138ec4b47',
  '0xa538934778220c6f4ba55990892a8100b6817a31',
  '0x472957d852d4360f85fa1e43e0013729f1ade670',
  '0xb81929101e23af9a5e4c9f91f0dd0eedfad2baec',
  '0xe6a72264e567dcc38e30258d0c58f3dfb8a15b37',
  '0x6bc75fcb31207936643d939466ab9b97f6095aee',
  '0x530f3d8200953e2181fa4cae7317cdd78b0fdd73',
  '0x267b4b8e8b70522e0dd7ba3805d9068d5a4c5aa7'
]

// Convert IPFS URL to use a gateway
const convertIpfsUrl = (url: string) => {
  if (!url) return undefined
  if (url.startsWith('ipfs://')) {
    return url.replace('ipfs://', 'https://magic.decentralized-content.com/ipfs/')
  }
  return url
}

// Format number with appropriate decimals
const formatNumber = (value: string | undefined) => {
  const num = Number(value || '0')
  return num.toLocaleString(undefined, {
    minimumFractionDigits: num < 10 ? 2 : 0,
    maximumFractionDigits: num < 10 ? 2 : 0
  })
}

// Helper function to normalize text for matching
const normalizeText = (text: string): string[] => {
  // Convert to lowercase and split by common separators
  const words = text.toLowerCase()
    .replace(/[_-]/g, ' ') // Replace hyphens and underscores with spaces
    .split(/\s+/) // Split by whitespace
    .filter(word => word.length > 0) // Remove empty strings
  
  // Add the original text as a single term
  return [...new Set([...words, text.toLowerCase()])]
}

// Helper function to check if arrays have any common elements
const hasCommonElements = (arr1: string[], arr2: string[]): boolean => {
  return arr1.some(item => arr2.includes(item))
}

// Add this helper function near the top with other helpers
const isSpecificAsset = (cert: GeneralCertificate) => cert.is_specific

export default function GeneralGrid({ 
  searchQuery = '',
  urlPrefix = '',
  onDataChange,
  isMiniApp = false,
  isOverview = false,
  hideMarketData = false,
  accountContext
}: GeneralGridProps) {
  const [certificates, setCertificates] = useState<GeneralCertificate[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [prices, setPrices] = useState<Record<string, number>>({})
  const [lastPriceUpdate, setLastPriceUpdate] = useState<number>(0)
  const [viewMode, setViewMode] = useState<ViewMode>('grid')
  const [sort, setSort] = useState<SortConfig>({ field: 'total_volume', direction: 'desc' })
  const PRICE_UPDATE_INTERVAL = 60000 // 1 minute in milliseconds
  const [specificMetadata, setSpecificMetadata] = useState<Record<string, any>>({})

  // Fetch certificates
  useEffect(() => {
    const fetchCertificates = async () => {
      try {
        setLoading(true)
        const response = await fetch('/api/general')
        if (!response.ok) {
          throw new Error('Failed to fetch certificates')
        }
        const data = await response.json()
        
        // Filter out any certificates that failed to fetch market data
        const validCertificates = (data || []).filter((cert: GeneralCertificate) => cert && cert.contract_address)
        
        // Fetch metadata for each valid certificate
        const certificatesWithMetadata = await Promise.all(
          validCertificates.map(fetchMetadata)
        )
        
        setCertificates(certificatesWithMetadata)
        if (onDataChange) {
          onDataChange(certificatesWithMetadata)
        }
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to fetch certificates')
      } finally {
        setLoading(false)
      }
    }

    fetchCertificates()
  }, [onDataChange])

  // Fetch prices with caching
  useEffect(() => {
    const fetchPrices = async () => {
      const now = Date.now()
      if (now - lastPriceUpdate < PRICE_UPDATE_INTERVAL) {
        return // Skip if last update was less than 1 minute ago
      }

      try {
        // Fetch ETH price once since all tokens are ETH-based
        const response = await fetch('/api/eth-price')
        if (!response.ok) {
          console.warn('Failed to fetch ETH price')
          return
        }
        const data = await response.json()
        if (data.price) {
          // Store the same ETH price for all contract addresses
          const newPrices: Record<string, number> = {}
          certificates.forEach(cert => {
            if (cert.contract_address) {
              newPrices[cert.contract_address] = data.price
            }
          })
          setPrices(newPrices)
          setLastPriceUpdate(now)
        }
      } catch (err) {
        console.error('Error updating prices:', err)
      }
    }

    if (certificates.length > 0) {
      fetchPrices()
    }
  }, [certificates, lastPriceUpdate])

  // Fetch metadata from token URI
  const fetchMetadata = async (cert: GeneralCertificate) => {
    try {
      // Convert token_uri to use IPFS gateway if needed
      const fetchUrl = convertIpfsUrl(cert.token_uri)
      if (!fetchUrl) {
        return {
          ...cert,
          image_url: FALLBACK_IMAGE,
          video_url: null,
          description: ''
        }
      }
      const response = await fetch(fetchUrl)
      if (!response.ok) throw new Error('Failed to fetch metadata')
      const data = await response.json()
      
      // Get image and video URLs from metadata
      let imageUrl = data.image || data.content?.uri || FALLBACK_IMAGE
      let videoUrl = data.animation_url || null
      
      // Convert media URLs to use IPFS gateway
      imageUrl = convertIpfsUrl(imageUrl)
      if (videoUrl) {
        videoUrl = convertIpfsUrl(videoUrl)
      }
      
      return {
        ...cert,
        image_url: imageUrl,
        video_url: videoUrl,
        description: data.description || ''
      }
    } catch (error) {
      console.error('Error fetching metadata:', error)
      return {
        ...cert,
        image_url: FALLBACK_IMAGE,
        video_url: null,
        description: ''
      }
    }
  }

  // Add this useEffect to fetch metadata when specific_asset_id changes
  useEffect(() => {
    const fetchMetadata = async () => {
      if (!accountContext?.specific_asset_id) return

      const tokenURI: string = `/api/metadata/${CONTRACTS.specific}/${accountContext.specific_asset_id}`
      try {
        const response = await fetch(tokenURI)
        const metadata = await response.json()
        setSpecificMetadata({ [tokenURI]: metadata })
      } catch (err) {
        console.error('Error fetching specific asset metadata:', err)
        setSpecificMetadata({})
      }
    }

    fetchMetadata()
  }, [accountContext?.specific_asset_id])

  const handleSortClick = () => {
    const fields = SORT_CYCLES
    const currentIndex = fields.indexOf(sort.field)
    
    // Move to next field, or back to first if at end
    const nextField = fields[(currentIndex + 1) % fields.length]
    
    // Set direction based on field type
    setSort({
      field: nextField,
      direction: nextField === 'name' ? 'asc' : 'desc'
    })
  }

  const getSortLabel = () => {
    const labels = {
      name: 'Sort by name (A-Z)',
      market_cap: 'Sort by market cap (High-Low)',
      total_volume: 'Sort by volume (High-Low)'
    }
    return labels[sort.field]
  }

  // Filter and sort certificates
  const filteredAndSortedCertificates = useMemo(() => {
    // First get matched certificates
    const matchedCertificates = certificates
      .filter(cert => {
        // First apply account context filter if present
        if (accountContext) {
          const accountTerms = normalizeText(accountContext.name)
          const certNameTerms = normalizeText(cert.name || '')
          const certDescTerms = normalizeText(cert.description || '')
          
          // Check for exact matches first
          if (certNameTerms.some(term => accountTerms.includes(term)) ||
              certDescTerms.some(term => accountTerms.includes(term))) {
            return true
          }
          
          // Check for partial matches in both name and description
          if (hasCommonElements(accountTerms, certNameTerms) ||
              hasCommonElements(accountTerms, certDescTerms)) {
            return true
          }
          
          // Check for reversed matches in both name and description
          const reversedAccountTerms = accountTerms.reverse()
          if (hasCommonElements(reversedAccountTerms, certNameTerms) ||
              hasCommonElements(reversedAccountTerms, certDescTerms)) {
            return true
          }
          
          return false
        }
        
        // Then apply regular search query filter
        const searchLower = (searchQuery || '').toLowerCase()
        return !searchQuery || 
          cert.name?.toLowerCase().includes(searchLower) ||
          cert.description?.toLowerCase().includes(searchLower)
      })

    // Add specific asset if it exists
    if (accountContext?.specific_asset_id) {
      const tokenURI = `/api/metadata/${CONTRACTS.specific}/${accountContext.specific_asset_id}`
      const metadata = specificMetadata[tokenURI]
      const specificAsset = {
        contract_address: CONTRACTS.specific,
        name: metadata?.name || `Specific Asset #${accountContext.specific_asset_id}`,
        token_uri: tokenURI,
        image_url: metadata?.image ? convertIpfsUrl(metadata.image) + `?t=${Date.now()}` : `https://2rhcowhl4b5wwjk8.public.blob.vercel-storage.com/specific-ensurance/${accountContext.specific_asset_id}.png?t=${Date.now()}`,
        is_specific: true,
        description: metadata?.description
      }
      matchedCertificates.unshift(specificAsset)
    }

    // Then get default certificates that aren't already in matched certificates
    const defaultCertificates = certificates
      .filter(cert => 
        DEFAULT_CERTIFICATES.includes(cert.contract_address.toLowerCase()) &&
        !matchedCertificates.some(matched => matched.contract_address === cert.contract_address)
      )

    // Sort matched certificates
    const sortedMatched = matchedCertificates.sort((a, b) => {
      // Always put specific assets first
      if (isSpecificAsset(a) && !isSpecificAsset(b)) return -1
      if (!isSpecificAsset(a) && isSpecificAsset(b)) return 1

      switch (sort.field) {
        case 'name':
          const aName = (a.name || '').toLowerCase()
          const bName = (b.name || '').toLowerCase()
          return sort.direction === 'asc' ? aName.localeCompare(bName) : bName.localeCompare(aName)
        
        case 'market_cap':
        case 'total_volume':
          const aValue = Number(a[sort.field] || '0')
          const bValue = Number(b[sort.field] || '0')
          return sort.direction === 'asc' ? aValue - bValue : bValue - aValue
        
        default:
          return 0
      }
    })

    // Sort default certificates
    const sortedDefaults = defaultCertificates.sort((a, b) => {
      switch (sort.field) {
        case 'name':
          const aName = (a.name || '').toLowerCase()
          const bName = (b.name || '').toLowerCase()
          return sort.direction === 'asc' ? aName.localeCompare(bName) : bName.localeCompare(aName)
        
        case 'market_cap':
        case 'total_volume':
          const aValue = Number(a[sort.field] || '0')
          const bValue = Number(b[sort.field] || '0')
          return sort.direction === 'asc' ? aValue - bValue : bValue - aValue
        
        default:
          return 0
      }
    })

    // Combine sorted lists with matched certificates first
    const allCertificates = [...sortedMatched, ...sortedDefaults]
    
    // If in overview mode, show 4 cards: 1 specific asset (if present) + 3 general certificates, or 4 general certificates if not
    if (isOverview) {
      if (accountContext?.specific_asset_id) {
        // Find the specific asset (should be first, but just in case)
        const specific = allCertificates.find(cert => cert.is_specific)
        // Filter out the specific asset from the rest
        const general = allCertificates.filter(cert => !cert.is_specific)
        // Overview: specific asset (if exists) + up to 3 general certificates
        return specific ? [specific, ...general.slice(0, 3)] : general.slice(0, 4)
      } else {
        return allCertificates.slice(0, 4)
      }
    }
    
    return allCertificates
  }, [certificates, searchQuery, sort, accountContext, isOverview, specificMetadata])

  if (loading) {
    return (
      <div className="space-y-4">
        {!isOverview && (
          <div className="flex items-center justify-end gap-2">
            <div className="bg-gray-900/30 rounded-lg p-1 flex gap-1">
              <button className="p-1.5 rounded-md bg-gray-800 text-white">
                <Grid className="w-5 h-5" />
              </button>
              <button className="p-1.5 rounded-md text-gray-400">
                <List className="w-5 h-5" />
              </button>
            </div>
            <button className="bg-gray-900/30 p-1.5 rounded-lg text-gray-400">
              <ArrowUpDown className="w-5 h-5" />
            </button>
          </div>
        )}
        <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6 mt-6">
          {[...Array(isOverview ? 4 : 8)].map((_, index) => (
            <Card key={`skeleton-${index}`} className="bg-primary-dark border-gray-800">
              <CardContent className="p-4">
                <Skeleton className="h-48 w-full mb-4 bg-gray-800" />
                <Skeleton className="h-4 w-3/4 mb-2 bg-gray-800" />
              </CardContent>
            </Card>
          ))}
        </div>
      </div>
    )
  }

  return (
    <div className="space-y-4">
      {/* Controls Bar - Only show if not in overview mode */}
      {!isOverview && (
        <div className="flex items-center justify-end gap-2">
          <div className="bg-gray-900/30 rounded-lg p-1 flex gap-1">
            <button
              onClick={() => setViewMode('grid')}
              className={`p-1.5 rounded-md transition-colors ${
                viewMode === 'grid'
                  ? 'bg-gray-800 text-white'
                  : 'text-gray-400 hover:text-white'
              }`}
              aria-label="Grid view"
            >
              <Grid className="w-5 h-5" />
            </button>
            <button
              onClick={() => setViewMode('list')}
              className={`p-1.5 rounded-md transition-colors ${
                viewMode === 'list'
                  ? 'bg-gray-800 text-white'
                  : 'text-gray-400 hover:text-white'
              }`}
              aria-label="List view"
            >
              <List className="w-5 h-5" />
            </button>
          </div>

          <button
            onClick={handleSortClick}
            className="bg-gray-900/30 p-1.5 rounded-lg text-gray-400 hover:text-white transition-colors"
            title={getSortLabel()}
          >
            <ArrowUpDown 
              className={`w-5 h-5 transition-transform ${sort.direction === 'desc' ? 'rotate-180' : ''}`}
            />
          </button>
        </div>
      )}

      {/* Content */}
      {viewMode === 'grid' ? (
        <div className={`grid grid-cols-1 sm:grid-cols-2 ${isOverview ? 'md:grid-cols-2' : 'md:grid-cols-3 lg:grid-cols-4'} gap-6`}>
          {filteredAndSortedCertificates.map((cert) => (
            <Link 
              key={cert.contract_address}
              href={cert.is_specific 
                ? `/specific/${CONTRACTS.specific}/${cert.token_uri.split('/').pop()}`
                : `${urlPrefix}${isMiniApp ? '/mini-app' : ''}/general/${cert.contract_address}`
              }
            >
              <Card 
                className={cn(
                  "bg-primary-dark border-gray-800 hover:border-gray-700 transition-colors group",
                  cert.is_specific && "relative after:content-[''] after:absolute after:inset-0 after:rounded-lg after:shadow-[0_0_15px_rgba(255,215,0,0.6),0_0_30px_rgba(255,215,0,0.3)] after:border-2 after:border-[rgba(255,215,0,0.8)]"
                )}
              >
                <CardContent className="p-4">
                  <div className="flex flex-col gap-4">
                    <div className="relative w-full aspect-square rounded-lg overflow-hidden bg-black/20">
                      {cert.video_url ? (
                        <video
                          src={cert.video_url}
                          autoPlay
                          loop
                          muted
                          playsInline
                          className="absolute inset-0 w-full h-full object-cover"
                        />
                      ) : (
                        <Image
                          src={cert.image_url || FALLBACK_IMAGE}
                          alt={cert.name || 'Certificate'}
                          fill
                          sizes="(max-width: 640px) 100vw, (max-width: 768px) 50vw, (max-width: 1024px) 33vw, 25vw"
                          priority={false}
                          loading="lazy"
                          className="object-cover"
                          unoptimized={cert.image_url?.toLowerCase?.()?.endsWith('.gif') || false}
                          onError={(e) => {
                            const img = e.target as HTMLImageElement;
                            img.src = FALLBACK_IMAGE;
                          }}
                        />
                      )}
                    </div>
                    <div className="flex flex-col gap-4">
                      <div className="text-lg font-semibold text-white text-center truncate">
                        {cert.name?.split('|')[0].trim() || 'Unnamed Certificate'}
                      </div>
                      {cert.name?.includes('|') && (
                        <div className="text-sm text-gray-400 text-center px-2">
                          {cert.name.split('|')[1].trim()}
                        </div>
                      )}
                    </div>
                    {!cert.is_specific && !hideMarketData && (
                      <div className="flex items-center justify-center text-sm text-gray-400 px-2">
                        <div className="flex gap-4 items-center">
                          <div>MC: ${Number(cert.market_cap || '0').toLocaleString(undefined, { 
                            minimumFractionDigits: Number(cert.market_cap || '0') < 10 ? 2 : 0,
                            maximumFractionDigits: Number(cert.market_cap || '0') < 10 ? 2 : 0
                          })}</div>
                          <div className="flex items-center gap-2">
                            <span>Vol: ${Number(cert.total_volume || '0').toLocaleString(undefined, { 
                              minimumFractionDigits: Number(cert.total_volume || '0') < 10 ? 2 : 0,
                              maximumFractionDigits: Number(cert.total_volume || '0') < 10 ? 2 : 0
                            })}</span>
                            {/* Buy button - only show on hover */}
                            <div className="opacity-0 group-hover:opacity-100 transition-opacity duration-200">
                              <EnsureButtonsLite
                                tokenSymbol={cert.name?.split('|')[0].trim() || 'Certificate'}
                                tokenName={cert.name}
                                imageUrl={cert.image_url}
                                contractAddress={cert.contract_address}
                                tokenId={cert.is_specific ? cert.token_uri.split('/').pop() : undefined}
                                tokenType={cert.is_specific ? 'erc1155' : 'erc20'}
                                context={cert.is_specific ? 'specific' : 'general'}
                                variant="grid"
                                showBuy={true}
                                showSwap={false}
                                showSend={false}
                                showBurn={false}
                              />
                            </div>
                          </div>
                        </div>
                      </div>
                    )}
                  </div>
                </CardContent>
              </Card>
            </Link>
          ))}
        </div>
      ) : (
        <GeneralList 
          certificates={filteredAndSortedCertificates}
          urlPrefix={urlPrefix}
          isMiniApp={isMiniApp}
        />
      )}
    </div>
  )
}
````

## File: src/modules/general/GeneralList.tsx
````typescript
import { GeneralCertificate } from './GeneralGrid';

import Image from 'next/image';
import Link from 'next/link';
import { CONTRACTS } from '@/modules/specific/config';
import { cn } from '@/lib/utils';
import { Card, CardContent } from '@/components/ui/card';
import { SpecificAsset } from '@/modules/specific/SpecificAsset';
import { EnsureButtonsLite } from '@/modules/ensure/buttons';

interface GeneralListProps {
  certificates: GeneralCertificate[];
  urlPrefix?: string;
  isMiniApp?: boolean;
}

const FALLBACK_IMAGE = '/assets/no-image-found.png';

const isSpecificAsset = (cert: GeneralCertificate) => cert.is_specific

export default function GeneralList({ certificates, urlPrefix = '', isMiniApp = false }: GeneralListProps) {
  if (!certificates.length) {
    return (
      <div className="text-center py-8">
        <p className="text-gray-500">No certificates found</p>
      </div>
    );
  }

  return (
    <div className="overflow-x-auto">
      <table className="w-full">
        <thead>
          <tr className="text-left text-sm text-gray-400">
            <th className="pb-4 font-medium w-[40%]">certificate</th>
            <th className="pb-4 font-medium w-[20%]">market cap</th>
            <th className="pb-4 font-medium text-right w-[20%]">volume</th>
            <th className="pb-4 font-medium text-right w-[20%]">actions</th>
          </tr>
        </thead>
        <tbody className="divide-y divide-gray-800">
          {certificates.map((cert) => (
            <tr key={cert.contract_address} className="group hover:bg-gray-900/30 transition-colors">
              <td className="py-4">
                <Link href={cert.is_specific 
                  ? `/specific/${CONTRACTS.specific}/${cert.token_uri.split('/').pop()}`
                  : `${urlPrefix}${isMiniApp ? '/mini-app' : ''}/general/${cert.contract_address}`
                }>
                  <div className="flex items-center gap-3">
                    <div className={cn(
                      "w-12 h-12 bg-gray-800 rounded-lg overflow-hidden flex items-center justify-center",
                      cert.is_specific && "relative after:content-[''] after:absolute after:inset-0 after:rounded-lg after:shadow-[0_0_15px_rgba(255,215,0,0.6),0_0_30px_rgba(255,215,0,0.3)] after:border-2 after:border-[rgba(255,215,0,0.8)]"
                    )}>
                      {cert.video_url ? (
                        <video
                          src={cert.video_url}
                          autoPlay
                          loop
                          muted
                          playsInline
                          className="w-full h-full object-cover"
                        />
                      ) : (
                        <Image
                          src={cert.image_url || FALLBACK_IMAGE}
                          alt={cert.name || 'Certificate'}
                          width={48}
                          height={48}
                          className="object-cover"
                          unoptimized={cert.image_url?.toLowerCase?.()?.endsWith('.gif') || false}
                          onError={(e) => {
                            const img = e.target as HTMLImageElement;
                            img.src = FALLBACK_IMAGE;
                          }}
                        />
                      )}
                    </div>
                    <div className="font-medium text-white">
                      {cert.name || 'Unnamed Certificate'}
                    </div>
                  </div>
                </Link>
              </td>
              {!cert.is_specific ? (
                <>
                  <td className="py-4">
                    <div className="font-medium text-white">
                      ${Number(cert.market_cap || '0').toLocaleString(undefined, { 
                        minimumFractionDigits: Number(cert.market_cap || '0') < 10 ? 2 : 0,
                        maximumFractionDigits: Number(cert.market_cap || '0') < 10 ? 2 : 0
                      })}
                    </div>
                  </td>
                  <td className="py-4 text-right">
                    <div className="font-medium text-white">
                      ${Number(cert.total_volume || '0').toLocaleString(undefined, { 
                        minimumFractionDigits: Number(cert.total_volume || '0') < 10 ? 2 : 0,
                        maximumFractionDigits: Number(cert.total_volume || '0') < 10 ? 2 : 0
                      })}
                    </div>
                  </td>
                  <td className="py-4 text-right">
                    <div className="opacity-0 group-hover:opacity-100 transition-opacity duration-200">
                      <EnsureButtonsLite
                        tokenSymbol={cert.name?.split('|')[0].trim() || 'Certificate'}
                        tokenName={cert.name}
                        imageUrl={cert.image_url}
                        contractAddress={cert.contract_address}
                        tokenType="erc20"
                        context="general"
                        variant="list"
                        showBuy={true}
                        showSwap={false}
                        showSend={false}
                        showBurn={false}
                      />
                    </div>
                  </td>
                </>
              ) : (
                <>
                  <td className="py-4 text-gray-400 font-medium" colSpan={2}>
                    specific ensurance provides direct funding
                  </td>
                  <td className="py-4 text-right">
                    <div className="flex justify-end">
                      <SpecificAsset tokenId={Number(cert.token_uri.split('/').pop())} />
                    </div>
                  </td>
                </>
              )}
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}
````

## File: src/modules/general/GeneralMarketSummary.tsx
````typescript
import React from 'react'
import { Card, CardContent } from "@/components/ui/card"
import { cn } from "@/lib/utils"
import { usePrivy } from '@privy-io/react-auth'
import { isAppAdmin } from '@/config/admin'

interface CreatorEarning {
  amountUsd: string
  // Add other fields if needed
}

interface MarketData {
  total_volume?: string
  market_cap?: string
  creator_earnings?: CreatorEarning[]
}

interface MarketSummaryProps {
  title?: string
  data: MarketData[]
  className?: string
  variant?: 'default' | 'subtle'
}

// Format number with appropriate decimals
const formatNumber = (value: string | undefined) => {
  const num = Number(value || '0')
  return num.toLocaleString(undefined, {
    minimumFractionDigits: num < 10 ? 2 : 0,
    maximumFractionDigits: num < 10 ? 2 : 0
  })
}

export default function MarketSummary({ 
  title = "Market Summary",
  data,
  className = "",
  variant = 'default'
}: MarketSummaryProps) {
  const { user } = usePrivy()
  const isAdmin = isAppAdmin(user?.wallet?.address)

  // Calculate totals
  const totalVolume = data.reduce((sum, item) => sum + Number(item.total_volume || '0'), 0)
  const totalMarketCap = data.reduce((sum, item) => sum + Number(item.market_cap || '0'), 0)
  const totalProceeds = data.reduce((sum, item) => 
    sum + (item.creator_earnings || []).reduce((s, e) => s + Number(e.amountUsd || '0'), 0), 
    0
  )
  const policiesIssued = data.length

  if (variant === 'subtle') {
    return (
      <div className={cn("text-right", className)}>
        <div className="flex flex-col gap-1">
          <div className="flex justify-end gap-6">
            <div>
              <div className="text-sm text-gray-400">policies issued</div>
              <div className="text-xl font-semibold text-white">{policiesIssued}</div>
            </div>
            <div>
              <div className="text-sm text-gray-400">market cap</div>
              <div className="text-xl font-semibold text-white">${formatNumber(totalMarketCap.toString())}</div>
            </div>
            <div>
              <div className="text-sm text-gray-400">volume</div>
              <div className="text-xl font-semibold text-white">${formatNumber(totalVolume.toString())}</div>
            </div>
          </div>
          {isAdmin && (
            <div>
              <div className="text-sm text-gray-400">proceeds</div>
              <div className="text-xl font-semibold text-white">${formatNumber(totalProceeds.toString())}</div>
            </div>
          )}
        </div>
      </div>
    )
  }

  return (
    <div className={className}>
      <Card className="bg-primary-dark border-gray-800">
        <CardContent className="p-6">
          <h2 className="text-xl font-semibold text-white mb-4">{title}</h2>
          <div className="flex flex-col gap-4">
            <div className="grid grid-cols-3 gap-4">
              <div>
                <div className="text-sm text-gray-400">policies issued</div>
                <div className="text-2xl font-bold text-white">{policiesIssued}</div>
              </div>
              <div>
                <div className="text-sm text-gray-400">market cap</div>
                <div className="text-2xl font-bold text-white">${formatNumber(totalMarketCap.toString())}</div>
              </div>
              <div>
                <div className="text-sm text-gray-400">volume</div>
                <div className="text-2xl font-bold text-white">${formatNumber(totalVolume.toString())}</div>
              </div>
            </div>
            {isAdmin && (
              <div>
                <div className="text-sm text-gray-400">proceeds</div>
                <div className="text-2xl font-bold text-white">${formatNumber(totalProceeds.toString())}</div>
              </div>
            )}
          </div>
        </CardContent>
      </Card>
    </div>
  )
}
````

## File: src/modules/groups/GroupGrid.tsx
````typescript
'use client'

import { useState, useEffect } from 'react'
import Link from 'next/link'
import Image from 'next/image'

interface Group {
    group_name: string;
    name_front: string | null;
    tagline: string | null;
    total_supply: number;
    contract_address: string;
    is_active: boolean;
}

interface GroupGridProps {
    searchQuery: string;
}

export default function GroupGrid({ searchQuery }: GroupGridProps) {
    const [groups, setGroups] = useState<Group[]>([])
    const [loading, setLoading] = useState(true)
    const [error, setError] = useState<string | null>(null)

    useEffect(() => {
        async function fetchGroups() {
            try {
                const response = await fetch('/api/groups')
                if (!response.ok) throw new Error('Failed to fetch groups')
                const data = await response.json()
                setGroups(data)
            } catch (err) {
                setError('Failed to load groups')
            } finally {
                setLoading(false)
            }
        }

        fetchGroups()
    }, [])

    const getGroupUrl = (groupName: string) => {
        return `/groups/${groupName.replace(/^\./, '')}/all`
    }

    const filteredGroups = groups.filter(group => 
        group.is_active && (
            group.group_name.toLowerCase().includes(searchQuery.toLowerCase()) ||
            (group.name_front?.toLowerCase().includes(searchQuery.toLowerCase())) ||
            (group.tagline?.toLowerCase().includes(searchQuery.toLowerCase()))
        )
    )

    if (loading) return <div>Loading...</div>
    if (error) return <div className="text-red-500">{error}</div>

    return (
        <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 md:gap-6">
            {filteredGroups.map((group) => (
                <Link
                    key={group.contract_address}
                    href={getGroupUrl(group.group_name)}
                    className="bg-primary dark:bg-primary-dark hover:bg-primary-dark dark:hover:bg-primary text-primary-foreground dark:text-primary-dark-foreground font-bold py-4 px-6 rounded-lg transition duration-300 ease-in-out transform hover:-translate-y-1 hover:scale-105 flex items-center"
                >
                    <div className="w-16 h-16 flex-shrink-0 mr-4">
                        <Image
                            src={`/groups/orbs/${group.group_name.replace(/^\./, '')}-orb.png`}
                            alt={`${group.group_name} orb`}
                            width={64}
                            height={64}
                            className="object-cover rounded-full"
                        />
                    </div>
                    <span className="text-lg font-mono truncate">
                        {group.group_name}
                    </span>
                </Link>
            ))}
        </div>
    )
}
````

## File: src/modules/groups/GroupInfo.tsx
````typescript
'use client'

import { useEffect, useState } from 'react'
import Image from 'next/image'
import { useRouter } from 'next/navigation'

interface GroupData {
    group_name: string;
    name_front: string | null;
    tagline: string | null;
    description: string | null;
    email: string | null;
    website: string | null;
    chat: string | null;
    situs_account: string | null;
    tba_address: string | null;
}

export function GroupInfo({ groupName }: { groupName: string }) {
    const [groupData, setGroupData] = useState<GroupData | null>(null)
    const [error, setError] = useState<string | null>(null)
    const cleanGroupName = groupName.startsWith('.') ? groupName.slice(1) : groupName
    const router = useRouter()

    useEffect(() => {
        async function fetchGroupData() {
            try {
                console.log('Fetching group data for:', groupName)
                const formattedGroupName = groupName.startsWith('.') ? groupName : `.${groupName}`
                const response = await fetch(`/api/groups?group_name=${encodeURIComponent(formattedGroupName)}`)
                if (!response.ok) throw new Error('Failed to fetch group')
                const data = await response.json()
                console.log('Received group data:', data)
                setGroupData(data)
            } catch (err) {
                console.error('Error fetching group:', err)
                setError(err instanceof Error ? err.message : 'Failed to load group data')
            }
        }

        fetchGroupData()
    }, [groupName])

    const handleGroupClick = (e: React.MouseEvent) => {
        // Only navigate if not clicking a link
        if (!(e.target as HTMLElement).closest('a')) {
            router.push(`/groups/${cleanGroupName}`)
        }
    }

    // Show loading state
    if (!groupData && !error) {
        return (
            <div className="border border-gray-800 rounded-xl overflow-hidden w-3/4 mx-auto mb-16">
                <div className="h-24 bg-gray-800 animate-pulse" />
                <div className="p-4">
                    <div className="flex items-start gap-4">
                        <div className="w-12 h-12 flex-shrink-0 bg-gray-800 rounded-full animate-pulse" />
                        <div className="flex-1">
                            <div className="h-5 w-48 bg-gray-800 rounded animate-pulse mb-2" />
                            <div className="h-4 w-64 bg-gray-800 rounded animate-pulse" />
                        </div>
                    </div>
                </div>
            </div>
        )
    }

    // Show error state
    if (error) {
        return (
            <div className="border border-gray-800 rounded-xl p-4 w-3/4 mx-auto mb-16">
                <p className="text-red-400 text-center">Error loading group information</p>
            </div>
        )
    }

    if (!groupData) return null

    return (
        <div 
            onClick={handleGroupClick}
            className="block border border-gray-800 rounded-xl overflow-hidden hover:border-gray-700 transition-colors w-3/4 mx-auto mb-16 cursor-pointer"
        >
            <div className="relative h-24">
                <Image
                    src={`/groups/banners/${cleanGroupName}-banner.jpg`}
                    alt={`${groupData.group_name} Banner`}
                    fill
                    className="object-cover brightness-75"
                />
                <div className="absolute inset-0 bg-gradient-to-t from-black/90 via-black/50 to-transparent" />
            </div>
            <div className="p-4 relative">
                <div className="flex items-start gap-4">
                    <div className="relative w-12 h-12 flex-shrink-0">
                        <Image
                            src={`/groups/orbs/${cleanGroupName}-orb.png`}
                            alt={`${groupData.group_name} orb`}
                            fill
                            className="rounded-full"
                        />
                    </div>
                    <div className="flex-1">
                        <div className="flex items-center mb-2">
                            <h2 className="text-lg font-bold">{groupData.group_name}</h2>
                            <span className="text-sm text-gray-400 flex items-center gap-0.5 ml-2">
                                Details
                                <svg className="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
                                </svg>
                            </span>
                        </div>
                        {groupData.tagline && (
                            <p className="text-gray-300 text-sm mb-3 line-clamp-2">{groupData.tagline}</p>
                        )}
                        <div className="flex flex-col gap-2">
                            {groupData.situs_account && (
                                <div className="text-sm">
                                    <span className="text-gray-400">Situs Account:</span>{' '}
                                    <span className="font-mono">{groupData.situs_account}</span>
                                </div>
                            )}
                            {groupData.tba_address && (
                                <div className="text-sm">
                                    <span className="text-gray-400">Group Account:</span>{' '}
                                    <span className="font-mono text-xs">{groupData.tba_address}</span>
                                </div>
                            )}
                            <div className="flex gap-4 mt-2">
                                {groupData.website && (
                                    <a 
                                        href={groupData.website}
                                        target="_blank"
                                        rel="noopener noreferrer"
                                        className="text-sm text-blue-400 hover:text-blue-300 transition-colors"
                                    >
                                        Website
                                    </a>
                                )}
                                {groupData.chat && (
                                    <a 
                                        href={groupData.chat}
                                        target="_blank"
                                        rel="noopener noreferrer"
                                        className="text-sm text-blue-400 hover:text-blue-300 transition-colors"
                                    >
                                        Chat
                                    </a>
                                )}
                                {groupData.email && (
                                    <a 
                                        href={`mailto:${groupData.email}`}
                                        className="text-sm text-blue-400 hover:text-blue-300 transition-colors"
                                    >
                                        Email
                                    </a>
                                )}
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    )
}
````

## File: src/modules/groups/GroupLinks.tsx
````typescript
'use client'

import { useState, useEffect } from 'react'
import Link from 'next/link'

interface Group {
    group_name: string;
    name_front: string | null;
}

export function GroupLinks() {
    const [groups, setGroups] = useState<Group[]>([])
    const [loading, setLoading] = useState(true)
    const [isOpen, setIsOpen] = useState(false)

    useEffect(() => {
        async function fetchGroups() {
            try {
                const response = await fetch('/api/groups')
                if (!response.ok) throw new Error('Failed to fetch groups')
                const data = await response.json()
                setGroups(data)
            } catch (err) {
                console.error('Error fetching groups:', err)
            } finally {
                setLoading(false)
            }
        }

        fetchGroups()
    }, [])

    if (loading) return null;

    return (
        <div className="max-w-2xl mx-auto">
            <div className="flex justify-center items-center gap-12 mb-2">
                <button 
                    onClick={() => setIsOpen(!isOpen)}
                    className="text-lg text-gray-500 hover:text-gray-300 transition-colors cursor-pointer"
                >
                    groups
                </button>
                <Link href="/all" className="text-lg text-gray-500 hover:text-gray-300 transition-colors">
                    agents
                </Link>
            </div>
            {isOpen && (
                <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-x-4 gap-y-1 text-center">
                    {groups.map((group) => (
                        <Link
                            key={group.group_name}
                            href={`/groups/${group.group_name.replace(/^\./, '')}/all`}
                            className="text-sm text-gray-500 hover:text-gray-300 transition-colors truncate px-2"
                        >
                            {group.group_name}
                        </Link>
                    ))}
                </div>
            )}
        </div>
    )
}
````

## File: src/modules/groups/GroupSelector.tsx
````typescript
'use client'

import React from 'react';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"

interface Group {
  group_name: string;
  contract_address?: string;
}

interface GroupSelectorProps {
  groups: Group[];
  currentGroup?: string;
  onGroupChange: (value: string) => void;
}

export function GroupSelector({ groups, currentGroup, onGroupChange }: GroupSelectorProps) {
  return (
    <Select onValueChange={onGroupChange} value={currentGroup}>
      <SelectTrigger className="bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 text-lg font-semibold text-gray-900 dark:text-white p-2 rounded-md w-full">
        <SelectValue placeholder="Choose Group" />
      </SelectTrigger>
      <SelectContent className="bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded-md shadow-lg">
        {groups.map((group) => (
          <SelectItem 
            key={group.contract_address || group.group_name} 
            value={group.group_name}
            className="text-lg font-semibold text-gray-900 dark:text-white hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors duration-300"
          >
            {group.group_name}
          </SelectItem>
        ))}
      </SelectContent>
    </Select>
  )
}
````

## File: src/modules/groups/GroupStats.tsx
````typescript
interface GroupStatsProps {
    situs_account: string | null;
    tba_address: string | null;
}

export default function GroupStats({ 
    situs_account,
    tba_address 
}: GroupStatsProps) {
    return (
        <div className="grid grid-cols-2 gap-3 mt-3">
            {/* Situs Account */}
            <div className="bg-gray-900/30 rounded-lg p-2">
                <div className="text-xs text-gray-500 uppercase tracking-wide mb-1">Situs Account</div>
                <span className="text-base font-mono bg-clip-text text-transparent bg-gradient-to-r from-amber-300 via-yellow-500 to-amber-600">
                    {situs_account || 'Not set'}
                </span>
            </div>

            {/* TBA Stats */}
            <div className="bg-gray-900/30 rounded-lg p-2">
                <div className="text-xs text-gray-500 uppercase tracking-wide mb-1">TBA</div>
                <div className="flex flex-col">
                    <div className="flex justify-between items-baseline">
                        <span className="text-xs text-gray-500">Address</span>
                        <span className="text-sm font-mono text-gray-300 truncate max-w-[180px]">
                            {tba_address || 'Not deployed'}
                        </span>
                    </div>
                    {tba_address && (
                        <div className="flex justify-end mt-1">
                            <a 
                                href={`https://basescan.org/address/${tba_address}`}
                                target="_blank"
                                rel="noopener noreferrer"
                                className="text-xs text-blue-400 hover:text-blue-300"
                            >
                                View on Basescan
                            </a>
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
}
````

## File: src/modules/home-page/cta/CTA.tsx
````typescript
export function CTA() {
  return (
    <section className="py-20 bg-black">
      <div className="container mx-auto px-6">
        <h2 className="text-4xl font-bold mb-8">CTA</h2>
        <div className="grid gap-8">
          {/* Content will go here */}
        </div>
      </div>
    </section>
  )
}
````

## File: src/modules/home-page/ensure/Ensure.tsx
````typescript
import { AssetSearch } from '@/modules/assets/AssetSearch'
import { useState, useEffect } from 'react'
import { TypewriterInput } from '@/components/ui/typewriter-input'
import { ensurePhrases } from '@/modules/ensure/ensurePhrases'
import { motion, AnimatePresence } from 'framer-motion'
import EnsureGrid from '@/modules/ensure/EnsureGrid'
import { cn } from '@/lib/utils'
import Link from 'next/link'

export function Ensure() {
  const [searchQuery, setSearchQuery] = useState('')
  const [showTypewriter, setShowTypewriter] = useState(true)
  const [showGrid, setShowGrid] = useState(false)
  const [isInitialLoad, setIsInitialLoad] = useState(true)
  const [gridData, setGridData] = useState<any[]>([])

  // Show grid when user starts typing
  useEffect(() => {
    if (searchQuery.length > 0) {
      setShowGrid(true)
      setShowTypewriter(false)
      setIsInitialLoad(false)
    } else {
      setShowGrid(false)
      setShowTypewriter(true)
    }
  }, [searchQuery])

  return (
    <section className={cn(
      "relative w-full min-h-screen flex items-center justify-center bg-black",
      (!isInitialLoad || showGrid) && "items-start pt-8"
    )}>
      <div className="container mx-auto px-6 text-center">
        <h2 className={cn(
          "text-6xl md:text-7xl font-bold mb-8 text-white",
          (!isInitialLoad || showGrid) && "text-4xl md:text-5xl mb-4"
        )}>what do you want to ensure?</h2>
        <div className={cn(
          "w-full max-w-4xl mx-auto",
          showGrid ? "mb-6" : "mb-12"
        )}>
          <div className="relative">
            <AssetSearch 
              searchQuery={searchQuery}
              setSearchQuery={setSearchQuery}
              placeholder=""
              className={cn(
                "text-4xl md:text-5xl !max-w-none",
                showTypewriter && "caret-transparent"
              )}
              autoFocus
            />
            {showTypewriter && (
              <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                <TypewriterInput words={ensurePhrases} />
              </div>
            )}
          </div>
        </div>
        
        <AnimatePresence>
          {showGrid && (
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              exit={{ opacity: 0 }}
              transition={{ duration: 0.2 }}
            >
              <EnsureGrid 
                searchQuery={searchQuery}
                types={['general', 'specific', 'syndicate', 'account', 'group']}
                variant="home"
                onDataChange={setGridData}
              />
              {gridData.length > 0 && (
                <motion.div
                  initial={{ opacity: 0, y: 10 }}
                  animate={{ opacity: 1, y: 0 }}
                  transition={{ delay: 0.2 }}
                  className="mt-8"
                >
                  <Link 
                    href="/ensure"
                    className="text-white/60 hover:text-white text-lg transition-colors duration-200"
                  >
                    see more
                  </Link>
                </motion.div>
              )}
            </motion.div>
          )}
        </AnimatePresence>
      </div>
    </section>
  )
}
````

## File: src/modules/home-page/proof/Proof.tsx
````typescript
export function Proof() {
  return (
    <section className="py-20 bg-black">
      <div className="container mx-auto px-6">
        <h2 className="text-4xl font-bold mb-8">PROOF</h2>
        <div className="grid gap-8">
          {/* Content will go here */}
        </div>
      </div>
    </section>
  )
}
````

## File: src/modules/home-page/risk-to-resilience/RiskToResilience.tsx
````typescript
export function RiskToResilience() {
  return (
    <section className="py-20 bg-black">
      <div className="container mx-auto px-6">
        <h2 className="text-4xl font-bold mb-8">RISK TO RESILIENCE</h2>
        <div className="grid gap-8">
          {/* Content will go here */}
        </div>
      </div>
    </section>
  )
}
````

## File: src/modules/home-page/solution/Solution.tsx
````typescript
export function Solution() {
  return (
    <section className="py-20 bg-black">
      <div className="container mx-auto px-6">
        <h2 className="text-4xl font-bold mb-8">SOLUTION</h2>
        <div className="grid gap-8">
          {/* Content will go here */}
        </div>
      </div>
    </section>
  )
}
````

## File: src/modules/home-page/truth/Truth.tsx
````typescript
export function Truth() {
  return (
    <section className="py-20 bg-black">
      <div className="container mx-auto px-6">
        <h2 className="text-4xl font-bold mb-8">TRUTH</h2>
        <div className="grid gap-8">
          {/* Content will go here */}
        </div>
      </div>
    </section>
  )
}
````

## File: src/modules/media/CustomAudioPlayer.tsx
````typescript
import React, { useState, useRef, useEffect } from 'react';

interface CustomAudioPlayerProps {
  src: string;
}

export default function CustomAudioPlayer({ src }: CustomAudioPlayerProps) {
  const [isPlaying, setIsPlaying] = useState(false);
  const [progress, setProgress] = useState(0);
  const audioRef = useRef<HTMLAudioElement>(null);

  useEffect(() => {
    console.log('CustomAudioPlayer mounted with src:', src);
    const audio = audioRef.current;
    if (!audio) return;

    const updateProgress = () => {
      const value = (audio.currentTime / audio.duration) * 100;
      setProgress(value);
    };

    audio.addEventListener('timeupdate', updateProgress);
    return () => audio.removeEventListener('timeupdate', updateProgress);
  }, [src]);

  const togglePlay = () => {
    if (audioRef.current) {
      if (isPlaying) {
        audioRef.current.pause();
      } else {
        audioRef.current.play();
      }
      setIsPlaying(!isPlaying);
    }
  };

  const handleProgressClick = (e: React.MouseEvent<HTMLDivElement>) => {
    const progressBar = e.currentTarget;
    const rect = progressBar.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const percentage = (x / rect.width) * 100;
    
    if (audioRef.current) {
      audioRef.current.currentTime = (percentage / 100) * audioRef.current.duration;
    }
  };

  if (!src) {
    console.log('CustomAudioPlayer: No src provided');
    return null;
  }

  return (
    <div className="w-full bg-black/50 backdrop-blur-sm rounded-xl p-4 flex flex-col gap-2">
      <audio 
        ref={audioRef} 
        src={src} 
        className="hidden" 
        onError={(e) => console.error('Audio error:', e)}
      />
      
      <div className="flex items-center gap-4">
        <button
          onClick={togglePlay}
          className="w-10 h-10 flex items-center justify-center rounded-full bg-gradient-to-r from-green-400 to-blue-500 hover:from-green-500 hover:to-blue-600 text-white focus:outline-none transition-all duration-200"
        >
          {isPlaying ? '❚❚' : '▶'}
        </button>
        
        <div 
          className="flex-grow h-2 bg-gray-700/50 rounded-full cursor-pointer overflow-hidden"
          onClick={handleProgressClick}
        >
          <div
            className="h-full bg-gradient-to-r from-green-400 to-blue-500 rounded-full transition-all duration-200"
            style={{ width: `${progress}%` }}
          ></div>
        </div>
      </div>
    </div>
  );
}
````

## File: src/modules/metadata/ImageGenerator.ts
````typescript
/** @jsxRuntime automatic */
/** @jsxImportSource react */
import { ImageResponse } from 'next/og';
import { put } from '@vercel/blob';
import React from 'react';
import fs from 'fs/promises';
import path from 'path';

interface GenerateOptions {
    baseImageUrl: string;
    fullAccountName: string;
    groupName: string;
    tokenId: string;
    contract?: string;
}

// Font configuration by group name
const FONT_CONFIG: Record<string, { path: string; family: string }> = {
    // Boulder group
    'boulder': {
        path: './public/fonts/OpenSans-Bold.ttf',
        family: 'Open Sans'
    },
    // Higher group
    'higher': {
        path: './public/fonts/Helvetica-Bold-02.ttf',
        family: 'Helvetica'
    },
    // Default font
    default: {
        path: './public/fonts/SpaceMono-Bold.ttf',
        family: 'Space Mono'
    }
};

export class ImageGenerator {
    static async generate({
        baseImageUrl,
        fullAccountName,
        groupName,
        tokenId
    }: GenerateOptions): Promise<string> {
        try {
            // Get font config for this group or use default
            const fontConfig = FONT_CONFIG[groupName] || FONT_CONFIG.default;
            
            // Load the font
            const fontPath = path.resolve(fontConfig.path);
            let fontData;
            try {
                fontData = await fs.readFile(fontPath);
            } catch (err) {
                console.warn(`Font not found at ${fontPath}, falling back to default font`);
                fontData = await fs.readFile(path.resolve(FONT_CONFIG.default.path));
            }

            // baseImageUrl is already handled by fallback system in metadata.ts
            if (!baseImageUrl) {
                throw new Error('No base image URL provided - check fallback system in metadata.ts');
            }

            const imageResponse = new ImageResponse(
                React.createElement(
                    'div',
                    {
                        style: {
                            width: '1000px',
                            height: '1000px',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            backgroundImage: `url(${baseImageUrl})`,
                            backgroundSize: '100% 100%',
                            backgroundPosition: 'center',
                            color: '#FFFFFF',
                            fontFamily: fontConfig.family,
                            position: 'relative'
                        }
                    },
                    React.createElement(
                        'div',
                        {
                            style: {
                                position: 'absolute',
                                width: '1000px',
                                left: '50%',
                                bottom: '25%',
                                transform: 'translateX(-50%)',
                                display: 'flex',
                                flexDirection: 'column',
                                alignItems: 'center',
                                fontSize: (() => {
                                    if (fullAccountName.length <= 15) return '72px';
                                    if (fullAccountName.length <= 25) return '64px';
                                    if (fullAccountName.length <= 35) return '48px';
                                    return '36px';
                                })(),
                                fontWeight: 700,
                                textAlign: 'center',
                                color: '#FFFFFF',
                                textShadow: '0 2px 12px rgba(0,0,0,0.9), 0 4px 8px rgba(0,0,0,0.8)',
                                padding: '20px',
                                overflow: 'visible'
                            }
                        },
                        fullAccountName
                    )
                ),
                {
                    width: 1000,
                    height: 1000,
                    fonts: [
                        {
                            name: fontConfig.family,
                            data: fontData,
                            weight: 700,
                            style: 'normal'
                        }
                    ]
                }
            );

            // Convert the response to a buffer
            const buffer = await imageResponse.arrayBuffer();

            try {
                // Store in blob storage
                const { url } = await put(
                    `${groupName}/generated/${tokenId}.png`,
                    Buffer.from(buffer),
                    { access: 'public', addRandomSuffix: false }
                );
                console.info(`Generated overlay image for ${fullAccountName}`);
                return url;
            } catch (blobError: unknown) {
                const errorMessage = blobError instanceof Error ? blobError.message : 'Unknown error';
                console.error(`Failed to store overlay image for ${fullAccountName}:`, {
                    error: errorMessage,
                    groupName,
                    tokenId,
                    path: `${groupName}/generated/${tokenId}.png`
                });
                throw new Error(`Failed to store overlay image for ${fullAccountName}`);
            }
        } catch (error: unknown) {
            // Check for cache size limit error
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            if (errorMessage.includes('fetch for over 2MB of data can not be cached')) {
                console.warn(`Cache size limit exceeded for ${fullAccountName} - this is expected for large images and won't affect functionality`, {
                    groupName,
                    tokenId,
                    note: 'This warning can be safely ignored as the image is still generated and stored correctly'
                });
                // Don't throw error for cache limit - it's not a functional issue
                return `${process.env.NEXT_PUBLIC_BLOB_URL}/${groupName}/generated/${tokenId}.png`;
            }

            // Handle other errors
            console.error(`Image generation failed for ${fullAccountName}:`, {
                error: errorMessage,
                groupName,
                tokenId
            });
            throw new Error(`Failed to generate image for ${fullAccountName}`);
        }
    }
}
````

## File: src/modules/natural-capital/NaturalCapitalGrid.tsx
````typescript
'use client'

import { useState, useEffect, forwardRef } from 'react'
import Link from 'next/link'
import { motion, AnimatePresence } from 'framer-motion'
import AccountImage from '@/modules/accounts/AccountImage'
import AccountStats from '@/modules/accounts/AccountStats'
import { cn } from '@/lib/utils'
import { TypewriterEffect } from '@/components/ui/typewriter-effect'
import { useRouter } from 'next/navigation'

interface Account {
    full_account_name: string;
    token_id: number;
    group_name: string;
    is_agent: boolean;
    stock_or_flow: string | null;
    display_name: string | null;
    total_currency_value: number;
    total_assets: number;
    ensured_assets: number;
    stats_last_updated?: string;
}

interface NaturalCapitalItem {
    id: string;
    name: string;
    description?: string;
    image?: string;
    url: string;
    group_name: string;
}

interface NaturalCapitalGridProps {
    groupName?: string;
    searchQuery?: string;
    activeCategory: 'all' | 'stock' | 'flow';
    urlPrefix?: string;
    variant?: 'showcase' | 'detailed' | 'standard';
    showHeader?: boolean;
}

interface CircleItemProps {
    account: Account;
    groupName: string;
    urlPrefix: string;
    variant?: 'showcase' | 'detailed' | 'standard';
}

const CircleItem = forwardRef<HTMLAnchorElement, CircleItemProps>(({ 
    account, 
    groupName, 
    urlPrefix,
    variant = 'showcase'
}, ref) => {
    const displayName = account.display_name || account.full_account_name;
    
    return (
        <Link 
            ref={ref}
            href={`/${account.full_account_name}`}
            className={cn(
                "circle-item group",
                variant === 'detailed' && "detailed"
            )}
            data-type={account.stock_or_flow || 'unknown'}
        >
            <motion.div
                initial={{ opacity: 0, scale: 0.9 }}
                animate={{ opacity: 1, scale: 1 }}
                exit={{ opacity: 0, scale: 0.9 }}
                transition={{ duration: 0.2 }}
                className="circle-content"
            >
                <AccountImage
                    tokenId={account.token_id}
                    groupName={groupName}
                    variant="square"
                    className="circle-image"
                />
                <div className="circle-overlay">
                    <div className="flex flex-col items-center gap-2">
                        <span className="text-sm text-white font-medium px-4 text-center">
                            {displayName}
                        </span>
                        {variant === 'detailed' && (
                            <AccountStats
                                total_currency_value={account.total_currency_value}
                                total_assets={account.total_assets}
                                ensured_assets={account.ensured_assets}
                            />
                        )}
                    </div>
                </div>
            </motion.div>
        </Link>
    );
});

export default function NaturalCapitalGrid({ 
    groupName = 'ensurance', 
    searchQuery = '', 
    activeCategory = 'all',
    urlPrefix = '',
    variant = 'standard',
    showHeader = true
}: NaturalCapitalGridProps) {
    const router = useRouter()
    const [localCategory, setLocalCategory] = useState(activeCategory)
    const [accounts, setAccounts] = useState<Account[]>([])
    const [loading, setLoading] = useState(true)
    const [error, setError] = useState<string | null>(null)

    // Update local category when prop changes
    useEffect(() => {
        setLocalCategory(activeCategory)
    }, [activeCategory])

    const words = [
        { text: "natural capital" },
        { text: "biodiversity" },
        { text: "ecosystems" },
        { text: "nature" },
        { text: "ecosystem services" }
    ]

    useEffect(() => {
        async function fetchAccounts() {
            try {
                const response = await fetch(`/api/accounts?group=${groupName}`)
                if (!response.ok) throw new Error('Failed to fetch accounts')
                const data = await response.json()
                
                // Filter out situs.ensurance if this is the ensurance group
                const filteredAccounts = data.filter((account: Account) => 
                    account.full_account_name !== 'situs.ensurance'
                )
                
                const sortedAccounts = filteredAccounts.sort((a: Account, b: Account) => {
                    const aName = a.display_name || a.full_account_name;
                    const bName = b.display_name || b.full_account_name;
                    return aName.localeCompare(bName);
                });
                
                setAccounts(sortedAccounts)
            } catch (err) {
                console.error('Error fetching accounts:', err)
                setError('Failed to load natural capital data')
            } finally {
                setLoading(false)
            }
        }

        fetchAccounts()
    }, [groupName])

    const filteredAccounts = accounts
        .filter(account => {
            // If there's a search query, only filter by search
            if (searchQuery) {
                const displayName = (account.display_name || account.full_account_name).toLowerCase();
                return displayName.includes(searchQuery.toLowerCase());
            }
            // If no search query, filter by category
            if (localCategory === 'all') return true;
            return account.stock_or_flow === localCategory;
        });

    return (
        <motion.div 
            className={cn(
                "natural-capital-section",
                variant === 'standard' && "py-4",
                variant === 'detailed' && "py-8",
                variant === 'showcase' && "py-16"
            )}
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ duration: 0.3 }}
        >
            {showHeader && variant === 'showcase' && (
                <div className="text-center space-y-8 mb-24">
                    <p className="text-2xl tracking-wider text-white/80">ensuring</p>
                    <Link href="/natural-capital" className="block group space-y-8">
                        <h2 className="text-5xl md:text-6xl lg:text-7xl font-bold bg-clip-text text-transparent bg-gradient-to-b from-white via-white/95 to-white/80 group-hover:opacity-80 transition-opacity">
                            critical infrastructure
                        </h2>
                        <div className="h-16">
                            <TypewriterEffect words={words} className="justify-center group-hover:opacity-80 transition-opacity" />
                        </div>
                    </Link>
                    <div className="flex justify-center gap-16 mt-8 text-lg tracking-widest">
                        <button 
                            onClick={() => setLocalCategory('stock')}
                            className={cn(
                                "transition-colors duration-300 relative uppercase",
                                localCategory === 'stock' ? "text-white" : "text-white/40 hover:text-white/60"
                            )}
                            disabled={loading}
                        >
                            Stocks
                            {localCategory === 'stock' && (
                                <motion.div 
                                    layoutId="underline"
                                    className="absolute -bottom-2 left-0 right-0 h-px bg-white"
                                />
                            )}
                        </button>
                        <button 
                            onClick={() => setLocalCategory('flow')}
                            className={cn(
                                "transition-colors duration-300 relative uppercase",
                                localCategory === 'flow' ? "text-white" : "text-white/40 hover:text-white/60"
                            )}
                            disabled={loading}
                        >
                            Flows
                            {localCategory === 'flow' && (
                                <motion.div 
                                    layoutId="underline"
                                    className="absolute -bottom-2 left-0 right-0 h-px bg-white"
                                />
                            )}
                        </button>
                    </div>
                </div>
            )}

            <div className={cn(
                "max-w-[1200px] mx-auto",
                variant === 'standard' ? "px-4" : "px-[30px]"
            )}>
                {loading ? (
                    <div className="circle-grid">
                        {[...Array(8)].map((_, index) => (
                            <div key={index} className="circle-item">
                                <div className="circle-content animate-pulse bg-gray-800/50">
                                    <div className="absolute inset-0 rounded-full bg-gray-700/30" />
                                </div>
                            </div>
                        ))}
                    </div>
                ) : error ? (
                    <div className="text-red-500 text-center py-12">{error}</div>
                ) : filteredAccounts.length === 0 ? (
                    <div className="text-white text-center py-12">No accounts found for the selected filter</div>
                ) : (
                    <div className="circle-grid">
                        <AnimatePresence mode="popLayout">
                            {filteredAccounts.map((account) => (
                                <CircleItem 
                                    key={account.token_id}
                                    account={account}
                                    groupName={groupName}
                                    urlPrefix={urlPrefix}
                                    variant={variant}
                                />
                            ))}
                        </AnimatePresence>
                    </div>
                )}
            </div>

            <style jsx global>{`
                :root {
                    --item-size: 180px;
                    --grid-gap: 30px;
                }

                .natural-capital-section {
                    position: relative;
                    padding: ${variant === 'showcase' ? '60px 0 120px' : variant === 'detailed' ? '30px 0 60px' : '0'};
                    background: ${variant !== 'standard' ? `
                        linear-gradient(180deg, 
                            rgba(0, 0, 0, 0) 0%,
                            rgba(255, 255, 255, 0.03) 5%,
                            rgba(255, 255, 255, 0.05) 15%,
                            rgba(255, 255, 255, 0.05) 85%,
                            rgba(255, 255, 255, 0.03) 95%,
                            rgba(0, 0, 0, 0) 100%
                        ),
                        linear-gradient(90deg,
                            rgba(0, 0, 0, 0) 0%,
                            rgba(255, 255, 255, 0.02) 25%,
                            rgba(255, 255, 255, 0.02) 75%,
                            rgba(0, 0, 0, 0) 100%
                        )
                    ` : 'none'};
                }

                .natural-capital-section::before {
                    content: '';
                    position: absolute;
                    top: 0;
                    left: 10%;
                    right: 10%;
                    height: 1px;
                    background: linear-gradient(90deg,
                        transparent,
                        rgba(255, 255, 255, 0.15) 20%,
                        rgba(255, 255, 255, 0.15) 80%,
                        transparent
                    );
                    display: ${variant === 'standard' ? 'none' : 'block'};
                }

                .circle-grid {
                    display: grid;
                    grid-template-columns: repeat(auto-fill, minmax(var(--item-size), 1fr));
                    max-width: 1200px;
                    margin: 0 auto;
                    padding: 0 var(--grid-gap);
                    gap: var(--grid-gap);
                }

                .circle-item {
                    aspect-ratio: 1;
                    position: relative;
                }

                .circle-content {
                    width: 100%;
                    height: 100%;
                    position: relative;
                    border-radius: 50%;
                    overflow: hidden;
                    transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
                }

                .circle-image {
                    width: 100%;
                    height: 100%;
                    object-fit: cover;
                    transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
                    filter: saturate(0.95);
                }

                .circle-overlay {
                    position: absolute;
                    inset: 0;
                    background: linear-gradient(
                        to top,
                        rgba(0, 0, 0, 0.75) 0%,
                        rgba(0, 0, 0, 0.3) 40%,
                        rgba(0, 0, 0, 0) 100%
                    );
                    display: flex;
                    align-items: flex-end;
                    justify-content: center;
                    padding: 0 0.75rem 1.25rem;
                    opacity: 0.6;
                    transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
                }

                .circle-overlay span {
                    font-size: 1rem;
                    line-height: 1.4;
                    max-width: 90%;
                    text-align: center;
                    word-wrap: normal;
                    word-break: normal;
                    hyphens: none;
                    font-weight: 500;
                    transition: all 0.3s ease;
                    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
                }

                [data-type="stock"] .circle-content {
                    box-shadow: 
                        inset 0 0 0 1px rgba(255, 255, 255, 0.1),
                        0 4px 20px rgba(0, 0, 0, 0.1);
                }

                [data-type="flow"] .circle-content {
                    box-shadow: 
                        inset 0 0 0 1px rgba(255, 255, 255, 0.15),
                        0 4px 20px rgba(0, 0, 0, 0.15);
                }

                .circle-item:hover .circle-content {
                    transform: scale(1.02);
                    box-shadow: 
                        inset 0 0 0 1px rgba(255, 255, 255, 0.2),
                        0 8px 32px rgba(0, 0, 0, 0.2);
                }

                .circle-item:hover .circle-image {
                    transform: scale(1.05);
                    filter: saturate(1.1) brightness(1.05);
                }

                .circle-item:hover .circle-overlay {
                    opacity: 0.8;
                    background: linear-gradient(
                        to top,
                        rgba(0, 0, 0, 0.8) 0%,
                        rgba(0, 0, 0, 0.4) 50%,
                        rgba(0, 0, 0, 0) 100%
                    );
                }

                .circle-item:hover .circle-overlay span {
                    font-weight: 500;
                    transform: translateY(-4px);
                }

                .circle-item.detailed .circle-overlay {
                    padding-bottom: 2rem;
                }

                .circle-item.detailed:hover .circle-overlay {
                    opacity: 0.9;
                    background: linear-gradient(
                        to top,
                        rgba(0, 0, 0, 0.9) 0%,
                        rgba(0, 0, 0, 0.5) 60%,
                        rgba(0, 0, 0, 0) 100%
                    );
                }

                @media (max-width: 900px) {
                    :root {
                        --item-size: 160px;
                        --grid-gap: 25px;
                    }
                }

                @media (max-width: 600px) {
                    :root {
                        --item-size: 140px;
                        --grid-gap: 20px;
                    }
                }
            `}</style>
        </motion.div>
    )
}
````

## File: src/modules/proceeds/components/viewer/ProceedsBubbles.tsx
````typescript
'use client';

import { useMemo } from 'react';
import { useSplitMetadata } from '@0xsplits/splits-sdk-react';
import { base } from 'viem/chains';

interface ProceedsRecipient {
  percentAllocation: number;
  recipient: {
    address: string;
    ens?: string;
  };
}

interface ProceedsBarProps {
  recipients: ProceedsRecipient[];
  isFlowView?: boolean;
}

function BubbleVisualization({ recipients, colors }: { 
  recipients: ProceedsRecipient[],
  colors: string[] 
}) {
  // Calculate bubble sizes and positions
  const bubbles = useMemo(() => {
    const containerWidth = 200;
    const containerHeight = 160;
    const maxRadius = Math.min(containerHeight / 2.5, containerWidth / 3);
    
    // Sort recipients by percentage for better nesting
    const sortedRecipients = [...recipients].sort((a, b) => b.percentAllocation - a.percentAllocation);
    
    return sortedRecipients.map((recipient, index) => {
      // Calculate radius based on percentage
      const radius = Math.max((recipient.percentAllocation / 100) * maxRadius * 1.5, 12);
      
      // Calculate position
      const angle = (index / recipients.length) * Math.PI * 2;
      const centerX = containerWidth / 2;
      const centerY = containerHeight / 2;
      
      // Position based on percentage
      const orbitRadius = (containerWidth / 4) * (1 - recipient.percentAllocation / 150);
      const x = centerX + Math.cos(angle) * orbitRadius;
      const y = centerY + Math.sin(angle) * orbitRadius;

      return {
        ...recipient,
        radius,
        x,
        y,
        color: colors[index]
      };
    });
  }, [recipients, colors]);

  return (
    <div className="relative w-full h-full">
      <svg width="100%" height="100%" viewBox="0 0 200 160" preserveAspectRatio="xMidYMid meet">
        {/* Draw connecting lines between bubbles */}
        {bubbles.map((bubble, i) => (
          bubbles.slice(i + 1).map((nextBubble, j) => (
            <path
              key={`${bubble.recipient.address}-${nextBubble.recipient.address}`}
              d={`M ${bubble.x} ${bubble.y} L ${nextBubble.x} ${nextBubble.y}`}
              fill="none"
              stroke={bubble.color}
              strokeWidth="0.5"
              strokeOpacity="0.2"
            />
          ))
        ))}
        
        {/* Draw bubbles */}
        {bubbles.map((bubble, i) => (
          <g key={bubble.recipient.address}>
            {/* Main bubble */}
            <circle
              cx={bubble.x}
              cy={bubble.y}
              r={bubble.radius}
              fill={bubble.color}
              fillOpacity={0.6}
              stroke={bubble.color}
              strokeOpacity={0.8}
              strokeWidth={1}
            />
            
            {/* Percentage label */}
            <text
              x={bubble.x}
              y={bubble.y}
              textAnchor="middle"
              dominantBaseline="middle"
              className="fill-white text-xs font-medium pointer-events-none select-none"
              style={{ fontSize: Math.max(10, bubble.radius / 1.8) }}
            >
              {Math.round(bubble.percentAllocation)}%
            </text>
          </g>
        ))}
      </svg>
    </div>
  );
}

export function ProceedsBar({ recipients, isFlowView = false }: ProceedsBarProps) {
  // Get split metadata if the address is a split contract
  const { splitMetadata } = useSplitMetadata(
    base.id, 
    recipients[0]?.recipient.address
  );

  // Use split metadata if available, otherwise use passed recipients
  const displayRecipients = useMemo(() => {
    if (splitMetadata?.recipients) {
      return splitMetadata.recipients;
    }
    return recipients;
  }, [splitMetadata, recipients]);

  // Generate colors for bubbles
  const colors = useMemo(() => {
    return displayRecipients.map((_, index) => {
      const hue = (index * 137.508) % 360;
      return `hsl(${hue}, 70%, 65%)`;
    });
  }, [displayRecipients]);

  return (
    <div className={`flex flex-col gap-2 ${!isFlowView && 'cursor-pointer hover:opacity-90 transition-opacity'}`}>
      {!isFlowView && (
        <h3 className="text-sm font-medium text-gray-400 flex items-center gap-2">
          {displayRecipients.length} {displayRecipients.length === 1 ? 'Beneficiary' : 'Beneficiaries'}
          <span className="text-xs text-gray-500">(click to view)</span>
        </h3>
      )}
      <BubbleVisualization recipients={displayRecipients} colors={colors} />
    </div>
  );
}

interface ProceedsBubblesProps {
  recipients: ProceedsRecipient[];
  isFlowView?: boolean;
}

export function ProceedsBubbles({ recipients, isFlowView = false }: ProceedsBubblesProps) {
  // Generate colors for bubbles
  const colors = useMemo(() => {
    return recipients.map((_, index) => {
      const hue = (index * 137.508) % 360;
      return `hsl(${hue}, 70%, 65%)`;
    });
  }, [recipients]);

  return (
    <div className="relative w-full h-full">
      <BubbleVisualization recipients={recipients} colors={colors} />
    </div>
  );
}
````

## File: src/modules/proceeds/components/viewer/ProceedsNode.tsx
````typescript
'use client';

import { Handle, Position } from 'reactflow';
import 'reactflow/dist/style.css';
import { useRouter } from 'next/navigation';
import { SpecificAsset } from '@/modules/specific/SpecificAsset';

interface FlowNodeProps {
  data: {
    label: string;
    fullAddress: string;
    recipients?: {
      percentAllocation: number;
      recipient: {
        address: string;
        ens?: string;
      };
    }[];
    isSplit: boolean;
    isSource?: boolean;
    isReoccurring?: boolean;
    percentage?: string;
    type?: string;
    sources?: Array<{
      name: string;
      description: string | null;
    }>;
    specific_asset_id?: number;
  };
}

export function FlowNode({ data }: FlowNodeProps) {
  const router = useRouter();
  // Bright, visible colors only
  const colors = [
    '#60A5FA', // blue-400
    '#4ADE80', // green-400
    '#F472B6', // pink-400
    '#FBBF24', // amber-400
    '#A78BFA', // violet-400
    '#FB923C', // orange-400
    '#67E8F9', // cyan-400
    '#FCA5A5', // red-300
    '#C084FC', // purple-400
    '#86EFAC', // green-300
  ];

  // Format address for display
  const shortAddress = data.fullAddress ? `${data.fullAddress.slice(0, 6)}...${data.fullAddress.slice(-4)}` : '';
  const isNamedAddress = data.fullAddress && data.label !== shortAddress;

  console.log('Rendering node:', {
    address: data.fullAddress,
    percentage: data.percentage,
    isSource: data.isSource,
    specific_asset_id: data.specific_asset_id,
    label: data.label
  });

  if (data.type === 'naturalAssets') {
    // Render the custom NATURAL ASSETS node with standard node style, just wider
    return (
      <div
        className={`relative p-6 rounded-xl w-[75vw] flex flex-col items-center bg-gray-800/80 backdrop-blur-sm ring-2 ring-blue-500/20 group`}
        style={{ minHeight: 120 }}
      >
        {/* Heading styled like standard node label */}
        <div className="text-gray-200 font-medium text-lg text-center flex items-center gap-2 mb-2">
          NATURAL ASSETS
        </div>
        {/* Link styled like address link in other nodes, now directly under heading */}
        <a
          href="https://binder.ensurance.app/"
          target="_blank"
          rel="noopener noreferrer"
          className="text-gray-400 font-mono text-xs text-center hover:text-blue-300 transition-colors relative z-50 cursor-pointer px-2 py-1 hover:bg-gray-700/50 rounded"
          onClick={e => e.stopPropagation()}
        >
          binder
        </a>
        {/* Split bar styled like recipients bar */}
        <div className="w-full h-8 rounded-lg overflow-hidden bg-gray-900/50 flex mb-2">
          {[...Array(9)].map((_, i) => (
            <div
              key={i}
              className="h-full transition-all duration-300"
              style={{
                backgroundColor: colors[i % colors.length],
                width: `${100 / 9}%`,
                opacity: 0.9
              }}
            />
          ))}
        </div>
        <div className="absolute inset-0 rounded-xl ring-2 ring-blue-500/20 group-hover:ring-blue-500/30 transition-all duration-300"/>
      </div>
    );
  }

  return (
    <div 
      className={`
        relative p-3
        rounded-xl
        ${data.isSource ? 'w-[360px]' : 'w-[240px]'}
        flex flex-col items-center
        ${data.isSource 
          ? 'ring-2 ring-yellow-500 ring-opacity-50'
          : ''
        }
        ${data.isSplit 
          ? 'bg-gray-800/80 backdrop-blur-sm' 
          : 'bg-gray-700/80 backdrop-blur-sm'
        }
        transition-all duration-300 ease-in-out
        group
      `}>
      {/* Top handle with glow effect - only show for non-source nodes */}
      {!data.isSource && (
        <Handle 
          type="target" 
          position={Position.Top} 
          className="w-3 h-3 !bg-blue-500/80 !border-2 !border-blue-300/30"
          style={{ top: '-6px' }}
        />
      )}
      
      <div className="flex flex-col items-center w-full gap-2">
        {/* Status indicator */}
        {data.isReoccurring && (
          <div className="absolute top-3 left-3 w-2 h-2 rounded-full bg-green-500" />
        )}

        {/* Address and name labels */}
        <div className="flex flex-col items-center gap-1">
          {(isNamedAddress || data.fullAddress.toLowerCase() === '0x4ddedf9e5e101a9d865fbc5401829ebd9fda1370') && (
            <div className="text-gray-200 font-medium text-sm text-center flex items-center gap-2">
              {data.fullAddress.toLowerCase() === '0x4ddedf9e5e101a9d865fbc5401829ebd9fda1370'
                ? <>
                    DISTRIBUTIONS <span className="text-blue-300">(20%)</span>
                  </>
                : <>
                    {data.label}
                    {!data.isSource && data.percentage && (
                      <span className="text-blue-300">({Math.round(parseFloat(data.percentage))}%)</span>
                    )}
                    {data.specific_asset_id && (
                      <SpecificAsset tokenId={data.specific_asset_id} />
                    )}
                  </>
              }
            </div>
          )}
          {data.fullAddress && !data.isSource && (
            <a 
              href={`/proceeds/${data.fullAddress}`}
              target="_blank"
              rel="noopener noreferrer"
              className="text-gray-400 font-mono text-xs text-center hover:text-blue-300 transition-colors relative z-50 cursor-pointer px-2 py-1 hover:bg-gray-700/50 rounded"
              onClick={(e) => e.stopPropagation()}
            >
              {shortAddress}
            </a>
          )}
        </div>
        
        {/* Sources display */}
        {data.isSource && data.sources && (
          <div className="w-full grid grid-cols-2 gap-1">
            {data.sources.map((source, index) => {
              const colorIndex = index % colors.length;
              return (
                <div 
                  key={source.name}
                  className="relative bg-gray-800/50 rounded-lg p-1.5 text-xs hover:bg-gray-800/70 transition-colors group"
                  style={{
                    borderLeft: `3px solid ${colors[colorIndex]}`
                  }}
                >
                  <div className="font-medium text-gray-200 truncate">{source.name}</div>
                  {source.description && (
                    <div className="absolute left-0 right-0 top-full mt-1 p-2 bg-gray-900/95 rounded-lg shadow-lg text-gray-300 text-xs opacity-0 group-hover:opacity-100 transition-opacity z-50 pointer-events-none whitespace-normal w-[400px] break-words">
                      {source.description}
                    </div>
                  )}
                </div>
              );
            })}
          </div>
        )}
        
        {/* Recipients bar */}
        {data.isSplit && data.recipients && data.recipients.length > 0 && (
          <div className="w-full h-8 rounded-lg overflow-hidden bg-gray-900/50 flex">
            {data.recipients.map((recipient, index) => {
              const percentage = Math.max(0, Math.min(100, recipient.percentAllocation || 0));
              const colorIndex = index % colors.length;
              return (
                <div
                  key={recipient.recipient.address}
                  className="h-full transition-all duration-300"
                  style={{
                    backgroundColor: colors[colorIndex],
                    width: `${percentage}%`,
                    opacity: 0.9 // Slightly reduce opacity for better blending
                  }}
                  title={`${recipient.recipient.address} (${percentage}%)`}
                />
              );
            })}
          </div>
        )}

        {/* Show single bar for non-split nodes */}
        {!data.isSplit && !data.isSource && (
          <div className="w-full h-8 rounded-lg overflow-hidden bg-gray-900/50">
            <div className="w-full h-full bg-blue-400/70" />
          </div>
        )}
      </div>

      {/* Bottom handle */}
      <Handle 
        type="source" 
        position={Position.Bottom} 
        className="w-3 h-3 !bg-blue-500/80 !border-2 !border-blue-300/30"
        style={{ bottom: '-6px' }}
      />

      {/* Static ring */}
      <div className="
        absolute inset-0 rounded-xl
        ring-2 ring-blue-500/20
        group-hover:ring-blue-500/30
        transition-all duration-300
      "/>
    </div>
  );
}
````

## File: src/modules/proceeds/components/viewer/ProceedsViewer.tsx
````typescript
'use client';

import { useEffect, useState, useCallback, useMemo } from 'react';
import ReactFlow, { 
  Background, Controls, MiniMap,
  Node, Edge, useNodesState, useEdgesState, MarkerType,
  Panel,
  BaseEdge,
  EdgeProps,
  getSmoothStepPath
} from 'reactflow';
import 'reactflow/dist/style.css';
import { SplitsClient } from '@0xsplits/splits-sdk';
import { FlowNode } from './ProceedsNode';

// Custom edge component for fluid animation
function FluidEdge({
  id,
  sourceX,
  sourceY,
  targetX,
  targetY,
  sourcePosition,
  targetPosition,
  style = {},
  markerEnd,
  data
}: EdgeProps) {
  // Calculate control points for a natural curve
  const midX = (sourceX + targetX) / 2;
  const midY = (sourceY + targetY) / 2;
  
  // Calculate horizontal distance for determining curve intensity
  const horizontalDistance = Math.abs(targetX - sourceX);
  const verticalDistance = Math.abs(targetY - sourceY);
  
  // Determine if this is an upward flow (return flow)
  const isUpwardFlow = targetY < sourceY;
  
  let edgePath;
  
  if (data?.isReturnFlow) {
    // Return flows take a wide path around the outside
    const curveIntensity = Math.max(horizontalDistance, 400); // Minimum curve width
    const sign = targetX > sourceX ? 1 : -1; // Determine which side to curve towards
    
    // Create a wide curve that goes around the outside
    edgePath = `M ${sourceX} ${sourceY}
                C ${sourceX + (sign * curveIntensity)} ${sourceY},
                  ${targetX + (sign * curveIntensity)} ${targetY},
                  ${targetX} ${targetY}`;
  } else {
    // Main flows stay more central with gentle curves
    const variance = Math.min(verticalDistance * 0.2, 100);
    
    edgePath = `M ${sourceX} ${sourceY}
                C ${sourceX} ${midY - variance},
                  ${targetX} ${midY + variance},
                  ${targetX} ${targetY}`;
  }

  return (
    <>
      <BaseEdge
        path={edgePath}
        markerEnd={markerEnd}
        style={{
          ...style,
          strokeWidth: data?.isReturnFlow ? 1.5 : 3, // Thicker main flow lines (3px), return lines stay thin
          opacity: data?.isReturnFlow ? 0.4 : 0.75,   // More opacity difference between return and main flows
          strokeDasharray: data?.isReturnFlow ? '4 4' : '8 4',
          filter: data?.isReturnFlow 
            ? 'drop-shadow(0 0 1px rgba(147, 197, 253, 0.2))' // Lighter shadow for return flows
            : 'drop-shadow(0 0 3px rgba(96, 165, 250, 0.4))'  // Stronger shadow for main flows
        }}
      />
      {data?.label && (
        <text
          x={midX}
          y={midY}
          className={`text-xs ${data?.isReturnFlow ? 'fill-blue-200' : 'fill-gray-300'}`}
          textAnchor="middle"
          dominantBaseline="middle"
          style={{
            pointerEvents: 'none',
            userSelect: 'none',
            filter: 'drop-shadow(0 1px 1px rgb(0 0 0 / 0.3))'
          }}
        >
          {data.label}
        </text>
      )}
    </>
  );
}

interface FlowViewerProps {
  address: string;
  chainId: number;
}

// Styles for the flow container
const flowStyles = {
  backgroundColor: '#111827', // Match your dark theme
};

// Default viewport settings
const defaultViewport = { x: 0, y: 0, zoom: 1 };

// Flow configuration
const MIN_ZOOM = 0.5;
const MAX_ZOOM = 1.5;
const ZOOM_STEP = 0.1;

interface AddressInfo {
  name: string | null;
  type: string;
  description?: string;
  specific_asset_id?: number;
}

export function FlowViewer({ address, chainId }: FlowViewerProps) {
  const [nodes, setNodes, onNodesChange] = useNodesState([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [addressNames, setAddressNames] = useState<Record<string, AddressInfo>>({});

  // Memoize node types and edge types
  const nodeTypes = useMemo(() => ({ flowNode: FlowNode }), []);
  const edgeTypes = useMemo(() => ({ fluid: FluidEdge }), []);

  // Initialize splits client with rate limiting
  const splitsClient = useMemo(() => {
    const client = new SplitsClient({
      chainId,
      includeEnsNames: false,
      apiConfig: {
        apiKey: process.env.NEXT_PUBLIC_SPLITS_API_KEY ?? ''
      }
    }).dataClient!;

    // Add delay between requests to avoid rate limiting
    const originalGetSplitMetadata = client.getSplitMetadata.bind(client);
    client.getSplitMetadata = async (...args) => {
      await new Promise(resolve => setTimeout(resolve, 100)); // 100ms delay
      return originalGetSplitMetadata(...args);
    };

    return client;
  }, [chainId]);

  // Fetch all address names upfront
  useEffect(() => {
    const fetchAddressNames = async () => {
      try {
        const response = await fetch('/api/proceeds');
        if (!response.ok) {
          console.error('Failed to fetch names:', response.status, response.statusText);
          return;
        }
        const names = await response.json();
        console.log('API Response:', {
          status: response.status,
          names,
          exampleKey: Object.keys(names)[0],
          exampleValue: names[Object.keys(names)[0]]
        });
        setAddressNames(names);
      } catch (err) {
        console.error('Failed to fetch address names:', err);
      }
    };

    fetchAddressNames();
  }, []);

  // Calculate node position based on level and index
  const calculatePosition = (level: number, index: number, totalAtLevel: number) => {
    // Base spacing configuration - increased spacing
    const VERTICAL_SPACING = 350;  // Increased from 250
    const HORIZONTAL_SPACING = 400; // Increased from 300
    const HORIZONTAL_OFFSET = 200;  // Increased from 150
    
    // Calculate base position
    const y = level * VERTICAL_SPACING;
    
    // Calculate x position with cascade effect
    let x;
    if (totalAtLevel === 1) {
      // Single node centered with level offset
      x = level * HORIZONTAL_OFFSET;
    } else {
      // Multiple nodes spread out with level offset
      const spread = (totalAtLevel - 1) * HORIZONTAL_SPACING;
      const startX = -(spread / 2) + (level * HORIZONTAL_OFFSET);
      x = startX + (index * HORIZONTAL_SPACING);
    }
    
    // Reduced random variation
    const randomX = x + (Math.random() * 20 - 10); // Reduced from 40
    const randomY = y + (Math.random() * 20 - 10); // Reduced from 40
    
    return {
      x: randomX,
      y: randomY
    };
  };

  // Process a split and its recipients
  const processSplit = useCallback(async (
    splitAddress: string,
    processedAddresses: Set<string> = new Set(),
    knownSplits: Map<string, any> = new Map(),
    level: number = 0,
    index: number = 0,
    totalAtLevel: number = 1,
    childPercentage?: string
  ) => {
    const normalizedAddress = splitAddress.toLowerCase();
    const newNodes: Node[] = [];
    const newEdges: Edge[] = [];
    
    // Skip if we've seen this address before
    if (processedAddresses.has(normalizedAddress)) {
      return { nodes: newNodes, edges: newEdges };
    }

    try {
      // Use cached metadata if available
      let splitMetadata = knownSplits.get(normalizedAddress);
      if (!splitMetadata) {
        const response = await splitsClient.getSplitMetadata({
          chainId,
          splitAddress: normalizedAddress
        });
        splitMetadata = response;
        knownSplits.set(normalizedAddress, splitMetadata);
      }

      // Add this address to processed set immediately
      processedAddresses.add(normalizedAddress);

      // Calculate position
      const position = calculatePosition(level, index, totalAtLevel);

      // Case-insensitive lookup in the address map
      const addressInfo = Object.entries(addressNames).find(
        ([addr]) => addr.toLowerCase() === normalizedAddress
      )?.[1];
      
      console.log('Looking up address:', normalizedAddress, 'Found:', addressInfo); // Debug log

      // Add node
      const nodePercentage = level === 0 ? undefined : childPercentage?.toString();

      console.log('Creating node:', {
        address: normalizedAddress,
        level,
        percentage: nodePercentage,
        addressInfo,
        splitMetadata: splitMetadata?.recipients?.map((r: { recipient: { address: string }, percentAllocation: string }) => ({
          address: r.recipient.address.toLowerCase(),
          percentage: r.percentAllocation
        }))
      });

      // If this is a headwaters node (level 0), add source nodes above it
      if (level === 0) {
        // Get all sources
        const sources = Object.entries(addressNames)
          .filter(([_, info]) => info.type === 'source')
          .map(([address, info]) => ({
            id: parseInt(address.replace('source_', '')),
            name: info.name,
            description: info.description
          }))
          .sort((a, b) => {
            // Define the order of IDs
            const order = [4, 2, 3, 7, 6, 1, 5];
            return order.indexOf(a.id) - order.indexOf(b.id);
          });

        // Create a single source node
        const sourceNode = {
          id: 'sources',
          type: 'flowNode',
          data: {
            label: 'SOURCES',
            fullAddress: 'sources',
            isSource: true,
            type: 'source',
            sources: sources.map(s => ({ name: s.name, description: s.description }))
          },
          position: {
            x: -800, // Position on the left
            y: -400 // Move up higher
          },
          draggable: true
        };

        // Add source node
        newNodes.push(sourceNode);

        // Create edge from sources to headwaters
        newEdges.push({
          id: `sources-${normalizedAddress}`,
          source: 'sources',
          target: normalizedAddress,
          sourceHandle: 'source', // Bottom handle of SOURCES
          targetHandle: 'target', // Top handle of HEADWATERS
          type: 'fluid',
          animated: true,
          markerEnd: {
            type: MarkerType.ArrowClosed,
            width: 20,
            height: 20,
            color: '#60A5FA'
          },
          style: { 
            stroke: '#60A5FA',
            strokeWidth: 2,
            opacity: 0.6
          }
        });
      }

      newNodes.push({
        id: normalizedAddress,
        type: 'flowNode',
        data: {
          label: addressInfo?.name || `${splitAddress.slice(0, 6)}...${splitAddress.slice(-4)}`,
          fullAddress: splitAddress,
          recipients: splitMetadata?.recipients || [],
          isSplit: Boolean(splitMetadata?.recipients?.length),
          isSource: false,
          type: addressInfo?.type || 'account',
          percentage: nodePercentage,
          specific_asset_id: addressInfo?.specific_asset_id
        },
        position,
        draggable: true
      });

      if (splitMetadata?.recipients) {
        // First, check all recipients in parallel to identify which ones are splits
        const recipientChecks = await Promise.all(
          splitMetadata.recipients.map(async (recipient: { recipient: { address: string }, percentAllocation: string }) => {
            const recipientAddress = recipient.recipient.address.toLowerCase();
            
            // Special case for 0x4dDEdf9e5e101A9D865FbC5401829EbD9Fda1370
            if (recipientAddress === '0x4ddedf9e5e101a9d865fbc5401829ebd9fda1370') {
              return {
                address: recipientAddress,
                isSplit: true, // Force it to be treated as a node
                percentage: recipient.percentAllocation
              };
            }
            
            // If we've already processed this address or have it in knownSplits, use cached info
            if (processedAddresses.has(recipientAddress)) {
              return {
                address: recipientAddress,
                isSplit: knownSplits.has(recipientAddress),
                percentage: recipient.percentAllocation
              };
            }

            // If it's in knownSplits but not processed, use that info
            if (knownSplits.has(recipientAddress)) {
              const metadata = knownSplits.get(recipientAddress);
              return {
                address: recipientAddress,
                isSplit: Boolean(metadata?.recipients?.length),
                percentage: recipient.percentAllocation
              };
            }

            // Only check new addresses
            try {
              const metadata = await splitsClient.getSplitMetadata({
                chainId,
                splitAddress: recipientAddress
              });
              knownSplits.set(recipientAddress, metadata);
              return {
                address: recipientAddress,
                isSplit: Boolean(metadata?.recipients?.length),
                percentage: recipient.percentAllocation
              };
            } catch (err) {
              console.warn(`Error checking if ${recipientAddress} is split:`, err);
              return {
                address: recipientAddress,
                isSplit: false,
                percentage: recipient.percentAllocation
              };
            }
          })
        );

        // Filter split recipients and create edges
        const splitRecipients = recipientChecks.filter(r => r.isSplit);
        splitRecipients.forEach(({ address, percentage }) => {
          // Determine if this is a return flow (going to a previously seen node)
          const isReturnFlow = processedAddresses.has(address.toLowerCase());
          
          newEdges.push({
            id: `${normalizedAddress}-${address}`,
            source: normalizedAddress,
            target: address,
            sourceHandle: 'source',
            targetHandle: 'target',
            label: `${Math.round(percentage)}%`,
            type: 'fluid',
            animated: true,
            markerEnd: {
              type: MarkerType.ArrowClosed,
              width: 20,
              height: 20,
              color: isReturnFlow ? '#93C5FD' : '#60A5FA' // Lighter blue for return flows
            },
            style: { 
              stroke: isReturnFlow ? '#93C5FD' : '#60A5FA', // Lighter blue for return flows
              strokeWidth: 2,
              opacity: 0.6
            },
            data: {
              isReturnFlow
            }
          });
        });

        // Process new splits in parallel if not at max depth
        if (level < 3) {
          const childResults = await Promise.all(
            splitRecipients
              .filter(r => !processedAddresses.has(r.address))
              .map((r, idx) => {
                // Get the percentage from the parent's metadata
                const childPercentage = splitMetadata?.recipients?.find(
                  (recipient: { recipient: { address: string }, percentAllocation: string }) => recipient.recipient.address.toLowerCase() === r.address.toLowerCase()
                )?.percentAllocation;

                return processSplit(
                  r.address, 
                  processedAddresses, 
                  knownSplits, 
                  level + 1,
                  idx,
                  splitRecipients.length,
                  childPercentage // Pass the percentage to the child
                )
              })
          );
          
          childResults.forEach(result => {
            newNodes.push(...result.nodes);
            newEdges.push(...result.edges);
          });
        }
      }

      return { nodes: newNodes, edges: newEdges };
    } catch (err) {
      console.warn(`Error processing split ${splitAddress}:`, err);
      if (!processedAddresses.has(normalizedAddress)) {
        const position = calculatePosition(level, index, totalAtLevel);
        newNodes.push({
          id: normalizedAddress,
          type: 'flowNode',
          data: {
            label: `${splitAddress.slice(0, 6)}...${splitAddress.slice(-4)}`,
            fullAddress: splitAddress,
            isSplit: false,
            recipients: []
          },
          position,
          draggable: true
        });
      }
      return { nodes: newNodes, edges: newEdges };
    }
  }, [chainId, splitsClient, addressNames]);

  // Initial load
  useEffect(() => {
    const loadData = async () => {
      try {
        setLoading(true);
        setError(null);
        
        const { nodes: newNodes, edges: newEdges } = await processSplit(
          address, 
          new Set(), 
          new Map()
        );
        
        setNodes(newNodes);
        setEdges(newEdges);

        // Add NATURAL ASSETS node below all others
        if (newNodes.length > 0) {
          // Find the max y position among all nodes
          const maxY = Math.max(...newNodes.map(n => n.position.y));
          // Center horizontally (average x of all nodes)
          const avgX = newNodes.reduce((sum, n) => sum + n.position.x, 0) / newNodes.length;
          newNodes.push({
            id: 'natural-assets',
            type: 'flowNode',
            data: {
              type: 'naturalAssets',
            },
            position: {
              x: avgX - 360, // Center the long node (width 720px)
              y: maxY + 300
            },
            draggable: false
          });
        }
        setNodes(newNodes);
      } catch (err) {
        console.error('Error loading split data:', err);
        setError(err instanceof Error ? err.message : 'Failed to load split data');
      } finally {
        setLoading(false);
      }
    };

    loadData();
  }, [address, processSplit]);

  // Loading state
  if (loading) {
    return (
      <div className="w-full h-[100dvh] flex items-center justify-center bg-gray-900">
        <div className="text-gray-200">loading proceeds data...</div>
      </div>
    );
  }

  // Error state
  if (error) {
    return (
      <div className="w-full h-[100dvh] flex items-center justify-center bg-gray-900">
        <div className="text-red-500">{error}</div>
      </div>
    );
  }

  return (
    <div className="w-full h-[100dvh] pb-16 bg-gray-900">
      <ReactFlow
        nodes={nodes}
        edges={edges}
        onNodesChange={onNodesChange}
        onEdgesChange={onEdgesChange}
        nodeTypes={nodeTypes}
        edgeTypes={edgeTypes}
        defaultEdgeOptions={{
          type: 'fluid'
        }}
        fitView
        fitViewOptions={{ padding: 0.2 }}
        minZoom={0.1}
        maxZoom={1.5}
        nodesDraggable={true}
        elementsSelectable={true}
        proOptions={{ hideAttribution: true }}
      >
        <Background color="#334155" gap={12} />
        <Controls />
      </ReactFlow>
    </div>
  );
}
````

## File: src/modules/proceeds/components/Proceeds.tsx
````typescript
'use client'

import { useRouter } from 'next/navigation'
import { TotalProceedsBar } from './TotalProceedsBar'
import { useEffect, useState } from 'react'
import { publicClient } from '@/modules/specific/config'
import ZORA_ERC20_MINTER_ABI from '@/abi/ZoraERC20Minter.json'
import { CONTRACTS } from '@/modules/specific/config'
import { SplitsWrapper } from '@/providers/splits-provider'

interface ProceedsProps {
  payout_recipient: string
  initial_supply?: string
  provenance?: string
  variant?: 'general' | 'specific'
  tokenId?: string
}

export function Proceeds({ 
  payout_recipient, 
  initial_supply,
  provenance, 
  variant = 'general',
  tokenId
}: ProceedsProps) {
  const router = useRouter()
  const [recipientAddress, setRecipientAddress] = useState<string>(payout_recipient)
  const [isLoading, setIsLoading] = useState(false)
  const [recipientCounts, setRecipientCounts] = useState({ direct: 0, indirect: 0 });

  // Fetch funds recipient for specific variant
  useEffect(() => {
    if (variant === 'specific' && tokenId) {
      const fetchFundsRecipient = async () => {
        try {
          setIsLoading(true)
          const salesConfig = await publicClient.readContract({
            address: CONTRACTS.erc20Minter,
            abi: ZORA_ERC20_MINTER_ABI,
            functionName: 'sale',
            args: [CONTRACTS.specific, BigInt(tokenId)]
          }) as any

          console.log('Sales config:', salesConfig)
          const fundsRecipient = salesConfig.fundsRecipient
          console.log('Funds recipient:', fundsRecipient)
          
          if (fundsRecipient && typeof fundsRecipient === 'string') {
            setRecipientAddress(fundsRecipient)
          } else {
            console.warn('Invalid funds recipient from contract:', fundsRecipient)
            setRecipientAddress(payout_recipient)
          }
        } catch (error) {
          console.error('Error fetching funds recipient:', error)
          setRecipientAddress(payout_recipient)
        } finally {
          setIsLoading(false)
        }
      }

      fetchFundsRecipient()
    }
  }, [variant, tokenId, payout_recipient])

  // Validate address before rendering
  const isValidAddress = (address: string) => {
    return address && typeof address === 'string' && address.length === 42 && address.startsWith('0x')
  }

  // Render specific variant
  if (variant === 'specific') {
    if (isLoading) {
      return (
        <div className="space-y-8">
          <div className="space-y-1">
            <h2 className="text-xl font-semibold">ENSURANCE PROCEEDS</h2>
            <p className="text-sm text-gray-400">perpetual funding for what matters</p>
          </div>
          <div className="w-full h-12 rounded-full overflow-hidden bg-gray-800/50 animate-pulse" />
        </div>
      )
    }

    if (!isValidAddress(recipientAddress)) {
      console.warn('Invalid recipient address:', recipientAddress)
      return (
        <div className="space-y-8">
          <div className="space-y-1">
            <h2 className="text-xl font-semibold">ENSURANCE PROCEEDS</h2>
            <p className="text-sm text-gray-400">perpetual funding for what matters</p>
          </div>
          <div className="w-full h-12 rounded-full overflow-hidden bg-gray-800/50">
            <div className="w-full h-full bg-gray-700/70" />
          </div>
        </div>
      )
    }

    return (
      <div className="space-y-8">
        <div className="space-y-1">
          <h2 className="text-xl font-semibold">ENSURANCE PROCEEDS</h2>
          <p className="text-sm text-gray-400">perpetual funding for what matters</p>
        </div>

        {/* Beneficiaries Count Grid */}
        <div className="space-y-2">
          <h4 className="text-sm font-medium text-gray-300">beneficiaries</h4>
          <div className="grid grid-cols-3 gap-4">
            <div>
              <p className="text-sm text-gray-400">direct: {recipientCounts.direct}</p>
            </div>
            <div>
              <p className="text-sm text-gray-400">indirect: {recipientCounts.indirect}</p>
            </div>
            <div>
              <p className="text-sm text-gray-400">total: {recipientCounts.direct + recipientCounts.indirect}</p>
            </div>
          </div>
        </div>
        
        <div className="space-y-6">
          <SplitsWrapper>
            <TotalProceedsBar 
              address={recipientAddress}
              onRecipientsUpdate={setRecipientCounts}
            />
          </SplitsWrapper>
        </div>
      </div>
    )
  }

  // Render general variant
  if (!isValidAddress(recipientAddress)) {
    console.warn('Invalid recipient address:', recipientAddress)
    return null
  }

  return (
    <div className="space-y-8">
      <div className="space-y-1">
        <h2 className="text-xl font-semibold">ENSURANCE PROCEEDS</h2>
        <p className="text-sm text-gray-400">perpetual funding for what matters</p>
      </div>

      {/* Beneficiaries Count Grid */}
      <div className="space-y-2">
        <h4 className="text-sm font-medium text-gray-300">beneficiaries</h4>
        <div className="grid grid-cols-3 gap-4">
          <div>
            <p className="text-sm text-gray-400">direct: {recipientCounts.direct}</p>
          </div>
          <div>
            <p className="text-sm text-gray-400">indirect: {recipientCounts.indirect}</p>
          </div>
          <div>
            <p className="text-sm text-gray-400">total: {recipientCounts.direct + recipientCounts.indirect}</p>
          </div>
        </div>
      </div>
      
      <div className="space-y-6">
        {/* Proceeds Payout Section - Always Full Width */}
        <SplitsWrapper>
          <TotalProceedsBar 
            address={recipientAddress}
            onRecipientsUpdate={setRecipientCounts}
          />
        </SplitsWrapper>

        {/* Grid Container for Initial Supply and Provenance */}
        {(initial_supply || provenance) && (
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            {/* Initial Supply Section */}
            {initial_supply && isValidAddress(initial_supply) && (
              <SplitsWrapper>
                <TotalProceedsBar 
                  address={initial_supply}
                  onRecipientsUpdate={setRecipientCounts}
                />
              </SplitsWrapper>
            )}

            {/* Provenance Section */}
            {provenance && isValidAddress(provenance) && (
              <SplitsWrapper>
                <TotalProceedsBar 
                  address={provenance}
                  onRecipientsUpdate={setRecipientCounts}
                />
              </SplitsWrapper>
            )}
          </div>
        )}
      </div>
    </div>
  )
}
````

## File: src/modules/proceeds/components/TotalProceedsBar.tsx
````typescript
'use client';

import { useEffect, useState, useMemo } from 'react';
import { BarChart, Bar, XAxis, YAxis, Tooltip as RechartsTooltip, ResponsiveContainer } from 'recharts';
import { SplitsClient } from '@0xsplits/splits-sdk';
import { base } from 'viem/chains';
import { useRouter } from 'next/navigation';
import { useQuery } from '@tanstack/react-query';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';
import Link from 'next/link';
import { toast } from 'react-toastify';

interface Recipient {
  address: string;
  type: 'split' | 'stream' | 'swapper' | 'team' | 'account';
  name?: string;
  percentage: number;  // For bar chart
  isDirect: boolean;
  directPercentage?: number;  // For direct list
}

// Add interface for proceeds data
interface ProceedsData {
  name: string | null;
  type: string;
  description: string | null;
}

// Add interface for account data
interface AccountData {
  full_account_name: string | null;
  group_name: string;
}

interface TotalProceedsBarProps {
  address: string;
  onRecipientsUpdate?: (counts: { direct: number; indirect: number }) => void;
}

const MAX_DEPTH = 3; // Maximum depth to traverse split relationships

// Initialize splits client
const splitsClient = new SplitsClient({
  chainId: base.id,
  includeEnsNames: false,
  apiConfig: {
    apiKey: process.env.NEXT_PUBLIC_SPLITS_API_KEY || ''
  }
}).dataClient as any;

// Helper function to get all recipients recursively
const getAllRecipients = async (
  splitAddress: string,
  parentPercentage: number = 100,
  depth: number = 0,
  processedAddresses: Set<string> = new Set(),
  allRecipients: Recipient[] = []
): Promise<Recipient[]> => {
  const normalizedAddress = splitAddress.toLowerCase();
  
  // If we've seen this address before or hit max depth, stop recursion
  if (processedAddresses.has(normalizedAddress) || depth >= MAX_DEPTH) {
    return allRecipients;
  }

  // Track that we've processed this address
  processedAddresses.add(normalizedAddress);
  
  try {
    const splitMetadata = await splitsClient.getSplitMetadata({
      chainId: base.id,
      splitAddress
    });

    // If not a split or no recipients, add as single recipient
    if (!splitMetadata?.recipients?.length) {
      allRecipients.push({
        address: normalizedAddress,
        type: 'account' as const,
        percentage: parentPercentage,
        isDirect: depth === 0,  // Only direct if at root level
        directPercentage: depth === 0 ? 100 : undefined
      });
      return allRecipients;
    }

    // Always add the split address itself (not just leaves)
    allRecipients.push({
      address: normalizedAddress,
      type: 'split' as const,
      percentage: parentPercentage,
      isDirect: depth === 0,  // Only direct if at root level
      directPercentage: depth === 0 ? 100 : undefined
    });

    // Process each recipient sequentially
    for (const recipient of splitMetadata.recipients) {
      const recipientAddress = recipient.recipient.address.toLowerCase();
      const adjustedPercentage = (recipient.percentAllocation * parentPercentage) / 100;

      // Only add as direct recipient if we're at the root level
      if (depth === 0) {
        allRecipients.push({
          address: recipientAddress,
          type: 'account' as const,
          percentage: adjustedPercentage,
          isDirect: true,
          directPercentage: recipient.percentAllocation
        });
      }

      if (!processedAddresses.has(recipientAddress) && depth < MAX_DEPTH) {
        // Recursively process this recipient for indirect recipients
        const indirectRecipients = await getAllRecipients(
          recipientAddress,
          adjustedPercentage,
          depth + 1,
          processedAddresses,
          []
        );
        // Add all indirect recipients
        allRecipients.push(...indirectRecipients);
      }
    }

    return allRecipients;
  } catch (err: any) {
    // If not a split, add as single recipient
    if (err.message?.includes('No split found at address')) {
      allRecipients.push({
        address: normalizedAddress,
        type: 'account' as const,
        percentage: parentPercentage,
        isDirect: depth === 0,  // Only direct if at root level
        directPercentage: depth === 0 ? 100 : undefined
      });
      return allRecipients;
    }
    console.warn(`Error processing split ${splitAddress} at depth ${depth}:`, err);
    return allRecipients;
  }
};

// Helper function to combine recipients
const combineRecipients = (recipients: Recipient[]): Recipient[] => {
  return recipients.reduce((acc: Recipient[], curr) => {
    const existing = acc.find(r => r.address === curr.address);
    if (existing) {
      existing.percentage += curr.percentage;
    } else {
      acc.push({ ...curr });
    }
    return acc;
  }, []);
};

// Add helper function for truncating addresses
const truncateAddress = (address: string) => {
  if (!address) return '';
  return `${address.slice(0, 6)}...${address.slice(-4)}`;
};

export function TotalProceedsBar({ address, onRecipientsUpdate }: TotalProceedsBarProps) {
  const router = useRouter();
  const [loadingAddress, setLoadingAddress] = useState<string | null>(null);

  // Add query for proceeds data
  const { data: proceedsData = {} } = useQuery<Record<string, ProceedsData>>({
    queryKey: ['proceeds-data'],
    queryFn: async () => {
      const response = await fetch('/api/proceeds');
      if (!response.ok) throw new Error('Failed to fetch proceeds data');
      return response.json();
    },
    staleTime: 1000 * 60, // 1 minute
    gcTime: 1000 * 60 * 5, // 5 minutes
  });

  // Add query for account data
  const { data: accountData = {} } = useQuery<Record<string, AccountData>>({
    queryKey: ['account-data'],
    queryFn: async () => {
      const response = await fetch('/api/accounts');
      if (!response.ok) throw new Error('Failed to fetch account data');
      const accounts = await response.json();
      // Convert array to map for easy lookup
      return accounts.reduce((acc: Record<string, AccountData>, account: any) => {
        if (account.tba_address) {
          acc[account.tba_address.toLowerCase()] = {
            full_account_name: account.full_account_name,
            group_name: account.group_name
          };
        }
        return acc;
      }, {});
    },
    staleTime: 1000 * 60, // 1 minute
    gcTime: 1000 * 60 * 5, // 5 minutes
  });

  // Use React Query to fetch and cache split data
  const { data: recipients = [], isLoading, error } = useQuery<Recipient[]>({
    queryKey: ['split-data', address],
    queryFn: async () => {
      if (!splitsClient) {
        throw new Error('Splits client not initialized');
      }

      // Get all recipients recursively with a fresh processedAddresses set
      const allRecipients = await getAllRecipients(address, 100, 0, new Set());

      // Debug logging
      console.log(`[${address}] All recipients before combining:`, allRecipients.map(r => ({
        address: r.address.slice(-4),
        percentage: r.percentage.toFixed(2),
        isDirect: r.isDirect
      })));

      // Combine duplicate recipients, preserving direct/indirect status
      const combinedRecipients = allRecipients.reduce((acc: Recipient[], curr) => {
        const existing = acc.find(r => r.address === curr.address);
        if (existing) {
          existing.percentage += curr.percentage;
          // Keep isDirect true if either is direct
          existing.isDirect = existing.isDirect || curr.isDirect;
          // Keep directPercentage if it exists
          existing.directPercentage = existing.directPercentage || curr.directPercentage;
        } else {
          acc.push({ ...curr });
        }
        return acc;
      }, []);

      // Debug logging
      console.log(`[${address}] Final combined recipients:`, combinedRecipients.map(r => ({
        address: r.address.slice(-4),
        percentage: r.percentage.toFixed(2),
        isDirect: r.isDirect
      })));

      return combinedRecipients.length > 0 ? combinedRecipients : [{
        address,
        type: 'account' as const,
        percentage: 100,
        isDirect: true,
        directPercentage: 100
      }];
    },
    staleTime: 1000 * 60 * 60, // 1 hour
    gcTime: 1000 * 60 * 60 * 24, // 24 hours
    retry: 2,
    refetchOnWindowFocus: false,
    refetchOnMount: false,
    refetchOnReconnect: false,
  });

  // Remove the separate direct recipients query since we now handle it in the main query
  const directRecipients = useMemo(() => 
    recipients.filter(r => (r.isDirect && r.address.toLowerCase() !== address.toLowerCase()) || (r.address.toLowerCase() === address.toLowerCase() && r.type === 'account')),
    [recipients, address]
  );

  const indirectRecipients = useMemo(() => 
    recipients.filter(r => !r.isDirect),
    [recipients]
  );

  // Generate colors based on recipient type and index
  const colors = useMemo(() => 
    recipients.map((_, index: number) => {
      const hue = (index * 137.508) % 360;
      return `hsl(${hue}, 70%, 65%)`;
    }), [recipients]);

  // Format data for the charts
  const data = useMemo(() => [{
    name: "Allocations",
    ...recipients.reduce((acc: Record<string, number>, r) => ({
      ...acc,
      [r.address]: r.percentage / 100
    }), {})
  }], [recipients]);

  const directData = useMemo(() => [{
    name: "Direct Allocations",
    ...directRecipients.reduce((acc: Record<string, number>, r: Recipient) => ({
      ...acc,
      [r.address]: r.directPercentage ? r.directPercentage / 100 : 0
    }), {})
  }], [directRecipients]);

  // Update parent component with recipient counts
  useEffect(() => {
    if (onRecipientsUpdate) {
      onRecipientsUpdate({
        direct: directRecipients.length,
        indirect: indirectRecipients.length
      });
    }
  }, [directRecipients.length, indirectRecipients.length, onRecipientsUpdate]);

  // Helper function to get display name
  const getDisplayName = (address: string) => {
    const normalizedAddress = address.toLowerCase();
    const displayName = proceedsData[normalizedAddress]?.name || 
                       accountData[normalizedAddress]?.full_account_name || 
                       truncateAddress(address);
    
    const handleClick = (e: React.MouseEvent) => {
      e.preventDefault();
      setLoadingAddress(normalizedAddress);
      router.push(proceedsData[normalizedAddress] ? 
        `/proceeds/${normalizedAddress}` : 
        `/${accountData[normalizedAddress]?.full_account_name || normalizedAddress}`
      );
    };
    
    return (
      <Link 
        href={proceedsData[normalizedAddress] ? 
          `/proceeds/${normalizedAddress}` : 
          `/${accountData[normalizedAddress]?.full_account_name || normalizedAddress}`
        }
        onClick={handleClick}
        className={`text-gray-400 hover:text-gray-200 transition-colors ${loadingAddress === normalizedAddress ? 'opacity-50' : ''}`}
      >
        {displayName}
      </Link>
    );
  };

  if (isLoading) {
    return <div className="h-12 bg-gray-800 rounded-full animate-pulse" />;
  }

  if (error) {
    return <div className="text-red-500 text-sm">{error instanceof Error ? error.message : 'Failed to load recipient data'}</div>;
  }

  return (
    <div className="flex flex-col gap-2">
      {/* Recipient Lists */}
      <div className="space-y-4">
        {/* Direct Recipients with Percentages */}
        {directRecipients.length > 0 && (
          <div className="space-y-2 group/main">
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-2">
                <h4 className="text-sm font-medium text-gray-300">direct recipients ({directRecipients.length})</h4>
                <div 
                  className="cursor-pointer text-sm font-mono text-gray-500 opacity-0 group-hover/main:opacity-70 transition-opacity duration-300 delay-300 hover:text-gray-300"
                  onClick={() => {
                    navigator.clipboard.writeText(address)
                      .then(() => toast.success('Split address copied to clipboard!', {
                        autoClose: 2000,
                        hideProgressBar: false,
                        closeOnClick: true,
                        pauseOnHover: true,
                        draggable: true,
                      }))
                      .catch(() => toast.error('Failed to copy address'))
                  }}
                >
                  {address}
                </div>
              </div>
            </div>
            
            {/* Direct Bar Chart */}
            <div 
              className="w-full h-12 rounded-full overflow-hidden bg-transparent hover:ring-1 hover:ring-gray-500 transition-all cursor-[pointer] hover:opacity-90"
              onClick={() => router.push('/proceeds')}
            >
              <ResponsiveContainer width="100%" height="100%">
                <BarChart
                  layout="vertical"
                  data={directData}
                  stackOffset="expand"
                  margin={{ top: 0, right: 0, bottom: 0, left: 0 }}
                  barSize={24}
                >
                  <XAxis type="number" hide domain={[0, 1]} />
                  <YAxis type="category" hide />
                  <RechartsTooltip
                    wrapperStyle={{ 
                      zIndex: 9999,
                      pointerEvents: 'none',
                      cursor: 'pointer'
                    }}
                    cursor={false}
                    content={({ active, payload }) => {
                      if (active && payload?.length) {
                        return (
                          <div className="bg-gray-900 px-3 py-1.5 rounded-lg border border-gray-700 shadow-lg">
                            <span className="text-gray-400 text-sm">
                              view ensurance proceeds
                            </span>
                          </div>
                        );
                      }
                      return null;
                    }}
                  />
                  {directRecipients.map((recipient, index) => (
                    <Bar
                      key={recipient.address}
                      dataKey={recipient.address}
                      stackId="a"
                      fill={colors[index]}
                      radius={0}
                      className="cursor-pointer hover:opacity-90"
                    />
                  ))}
                </BarChart>
              </ResponsiveContainer>
            </div>

            <div className="space-y-1">
              {directRecipients
                .sort((a, b) => (b.directPercentage || 0) - (a.directPercentage || 0))
                .map((r) => (
                <div key={r.address} className="flex justify-between items-center text-sm">
                  <TooltipProvider>
                    <Tooltip>
                      <TooltipTrigger asChild>
                        <span className="font-mono">
                          {getDisplayName(r.address)}
                        </span>
                      </TooltipTrigger>
                      <TooltipContent>
                        <p className="text-xs font-mono">{truncateAddress(r.address)}</p>
                        {proceedsData[r.address]?.description && (
                          <p className="text-xs text-gray-400 mt-1">{proceedsData[r.address].description}</p>
                        )}
                      </TooltipContent>
                    </Tooltip>
                  </TooltipProvider>
                  <span className="text-gray-300">{r.directPercentage?.toFixed(2)}%</span>
                </div>
              ))}
            </div>
          </div>
        )}

        {/* Indirect Recipients Section */}
        {indirectRecipients.length > 0 && (
          <div className="space-y-2">
            <div className="flex items-center justify-between">
              <h4 className="text-sm font-medium text-gray-300">indirect recipients ({indirectRecipients.length})</h4>
            </div>
            
            {/* Bar Chart */}
            <div 
              className="w-full h-12 rounded-full overflow-hidden bg-transparent hover:ring-1 hover:ring-gray-500 transition-all cursor-[pointer] hover:opacity-90"
              onClick={() => router.push('/proceeds')}
            >
              <ResponsiveContainer width="100%" height="100%">
                <BarChart
                  layout="vertical"
                  data={data}
                  stackOffset="expand"
                  margin={{ top: 0, right: 0, bottom: 0, left: 0 }}
                  barSize={24}
                >
                  <XAxis type="number" hide domain={[0, 1]} />
                  <YAxis type="category" hide />
                  <RechartsTooltip
                    wrapperStyle={{ 
                      zIndex: 9999,
                      pointerEvents: 'none',
                      cursor: 'pointer'
                    }}
                    cursor={false}
                    content={({ active, payload }) => {
                      if (active && payload?.length) {
                        return (
                          <div className="bg-gray-900 px-3 py-1.5 rounded-lg border border-gray-700 shadow-lg">
                            <span className="text-gray-400 text-sm">
                              view ensurance proceeds
                            </span>
                          </div>
                        );
                      }
                      return null;
                    }}
                  />
                  {recipients.map((recipient, index) => (
                    <Bar
                      key={recipient.address}
                      dataKey={recipient.address}
                      stackId="a"
                      fill={colors[index]}
                      radius={0}
                      className="cursor-pointer hover:opacity-90"
                    />
                  ))}
                </BarChart>
              </ResponsiveContainer>
            </div>

            <div className="grid grid-cols-2 gap-x-4 gap-y-1">
              {indirectRecipients.map((r) => (
                <div key={r.address} className="text-sm">
                  <TooltipProvider>
                    <Tooltip>
                      <TooltipTrigger asChild>
                        <span className="font-mono">
                          {getDisplayName(r.address)}
                        </span>
                      </TooltipTrigger>
                      <TooltipContent>
                        <p className="text-xs font-mono">{truncateAddress(r.address)}</p>
                        {proceedsData[r.address]?.description && (
                          <p className="text-xs text-gray-400 mt-1">{proceedsData[r.address].description}</p>
                        )}
                      </TooltipContent>
                    </Tooltip>
                  </TooltipProvider>
                </div>
              ))}
            </div>
          </div>
        )}
      </div>
    </div>
  );
}
````

## File: src/modules/proceeds/index.ts
````typescript
export * from '../../providers/splits-provider'
// No need for hooks export since we'll use SDK hooks directly
````

## File: src/modules/rewards/RewardsLink.tsx
````typescript
'use client';

import { useState, useEffect } from 'react';
import { usePrivy } from '@privy-io/react-auth';
import { useSearchParams } from 'next/navigation';
import { toast } from 'react-toastify';
import Link from 'next/link';
import { spaceGrotesk } from '@/app/fonts';

// Local storage utils
function setReferral(address: string) {
  localStorage.setItem('referral', address);
}

function getReferral(): string {
  return localStorage.getItem('referral') || '';
}

function clearReferral() {
  localStorage.removeItem('referral');
}

export function ReferralButton() {
  const { user } = usePrivy();
  const [copying, setCopying] = useState(false);
  const searchParams = useSearchParams();
  const [currentReferral, setCurrentReferral] = useState<string | null>(null);

  useEffect(() => {
    if (searchParams) {
      const ref = searchParams.get('ref');
      if (ref) {
        setReferral(ref);
      }
      setCurrentReferral(getReferral());
    }
  }, [searchParams]);

  const generateReferralLink = () => {
    if (user?.wallet?.address) {
      const link = `${window.location.origin}?ref=${user.wallet.address}`;
      console.log('Generated link:', link);
      return link;
    }
    return null;
  };

  const copyToClipboard = async () => {
    const referralLink = generateReferralLink();
    console.log('Attempting to copy:', referralLink);
    if (referralLink) {
      setCopying(true);
      try {
        await navigator.clipboard.writeText(referralLink);
        const message = 'Get your own onchain ai agent...';
        const encodedMessage = encodeURIComponent(message);
        const encodedLink = encodeURIComponent(referralLink);
        
        toast.success(
          <div>
            Referral link copied to clipboard!
            <div className="mt-2">
              Share on:
              <Link 
                href={`https://x.com/intent/tweet?text=${encodedMessage}&url=${encodedLink}`}
                target="_blank"
                rel="noopener noreferrer"
                className="text-blue-500 hover:text-blue-700 ml-2"
              >
                X
              </Link>
              <button
                onClick={() => {
                  window.open('https://www.linkedin.com/sharing/share-offsite/?url=' + encodedLink, '_blank', 'width=570,height=570');
                  toast.info('Link copied to clipboard. Paste it into your new LinkedIn post.', {
                    autoClose: 5000,
                    closeOnClick: true,
                    closeButton: false
                  });
                }}
                className="text-blue-500 hover:text-blue-700 ml-2"
              >
                LinkedIn
              </button>
            </div>
          </div>,
          {
            autoClose: 60000,
            closeOnClick: true,
            pauseOnHover: true,
            draggable: true,
            closeButton: false
          }
        );
      } catch (err) {
        console.error('Failed to copy: ', err);
        toast.error('Failed to copy referral link', {
          closeButton: false
        });
      } finally {
        setCopying(false);
      }
    } else {
      toast.error('Please connect your wallet to generate a referral link', {
        closeButton: false
      });
    }
  };

  if (!user?.wallet?.address) {
    return null;
  }

  return (
    <div>
      <button
        onClick={copyToClipboard}
        disabled={copying}
        className="text-transparent bg-clip-text bg-gradient-to-r from-amber-300 via-yellow-500 to-amber-600 hover:opacity-80 transition duration-300 lowercase"
      >
        {copying ? 'copying...' : 'protocol rewards'}
      </button>
      {currentReferral && currentReferral !== '0x0000000000000000000000000000000000000000' && (
        <p className="text-xs text-gray-400 mt-1">
          protocol rewards: {`${currentReferral.slice(0, 6)}...${currentReferral.slice(-4)}`}
        </p>
      )}
    </div>
  );
}
````

## File: src/modules/shared/ChainDropdown.tsx
````typescript
import React from 'react';
import Image from 'next/image';
import { getActiveChains, chainOrder } from '@/config/chains';
// TODO: Implement contract functionality when completing assets feature
// import { ensuranceContracts } from '@/modules/specific/contract';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { ChainDropdownProps } from '@/types';

// Exchange-enabled chains
const EXCHANGE_ENABLED_CHAINS = ['base', 'arbitrum', 'optimism'] as const;

function ChainDropdown({ 
  selectedChain, 
  onChange,
  filterEnsurance,
  className = ""
}: ChainDropdownProps) {
  const chains = getActiveChains()
    // Filter for Ensurance contracts if needed
    .filter(chain => !filterEnsurance) // TODO: Add ensurance contract check when implementing assets feature
    // For exchange variant, only show exchange-enabled chains
    .filter(chain => !filterEnsurance || EXCHANGE_ENABLED_CHAINS.includes(chain.viemName as typeof EXCHANGE_ENABLED_CHAINS[number]))
    .sort((a, b) => {
      const aIndex = chainOrder.indexOf(a.viemName);
      const bIndex = chainOrder.indexOf(b.viemName);
      return aIndex - bIndex;
    });

  const chainOptions = filterEnsurance
    ? EXCHANGE_ENABLED_CHAINS
    : chains.map(chain => chain.viemName);

  const getChainIconPath = (chainName: string) => {
    const svgPath = `/assets/icons/${chainName}.svg`;
    const pngPath = `/assets/icons/${chainName}.png`;
    return svgPath;
  };

  const ChainIcon = ({ chainName }: { chainName: string }) => (
    <Image
      src={getChainIconPath(chainName)}
      alt={`${chainName} icon`}
      width={16}
      height={16}
      className="object-contain mr-0 lg:mr-2 flex-shrink-0"
      onError={(e) => {
        const imgElement = e.target as HTMLImageElement;
        if (imgElement.src.endsWith('.svg')) {
          imgElement.src = imgElement.src.replace('.svg', '.png');
        }
      }}
    />
  );

  return (
    <Select onValueChange={onChange} value={selectedChain}>
      <SelectTrigger className={`${className} flex items-center gap-2 min-w-[40px] lg:min-w-[120px]`}>
        <SelectValue 
          placeholder="Select chain"
          className="flex items-center"
        >
          <div className="flex items-center">
            <ChainIcon chainName={selectedChain} />
            <span className="hidden lg:inline">
              {chains.find(c => c.viemName === selectedChain)?.name || selectedChain}
            </span>
          </div>
        </SelectValue>
      </SelectTrigger>
      <SelectContent className="bg-[#111] border-gray-700 text-gray-200">
        {chainOptions.map((chainName) => {
          const chain = chains.find(c => c.viemName === chainName);
          return (
            <SelectItem 
              key={chainName} 
              value={chainName}
              className="flex items-center gap-2 hover:bg-gray-800 focus:bg-gray-800 cursor-pointer py-2"
            >
              <div className="flex items-center">
                <ChainIcon chainName={chainName} />
                <span className="hidden lg:inline">
                  {chain?.name || chainName}
                </span>
              </div>
            </SelectItem>
          );
        })}
      </SelectContent>
    </Select>
  );
}

export default ChainDropdown;
````

## File: src/modules/shared/HomeSwarm.tsx
````typescript
'use client'

import { useEffect, useState } from 'react'
import Image from 'next/image'
import Link from 'next/link'

const SWARM_ORBS = [
    'ai', 'basin', 'bioregion', 'boulder', 'earth', 'higher', 'mumbai',
    'refi', 'sicilia', 'situs', 'tgn', 'tokyo', 'fi', 'la', 'capital', 'solar', 'solarpunk', 'ents'
]

interface SwarmItem {
    x: number
    y: number
    vx: number
    vy: number
    size: number
    angle: number
    orbName: string
    speed: number
}

export function HomeSwarm() {
    const [items, setItems] = useState<SwarmItem[]>([])
    const [dimensions, setDimensions] = useState({ width: 0, height: 0 })
    const [startTime] = useState(Date.now())
    const organizationDelay = 2000    // 2 seconds of pure random movement
    const organizationDuration = 8000 // 8 seconds to organize
    
    useEffect(() => {
        const updateDimensions = () => {
            setDimensions({
                width: window.innerWidth,
                height: window.innerHeight
            })
        }

        updateDimensions()
        window.addEventListener('resize', updateDimensions)

        // Initialize swarm with deterministic speeds and angles
        const swarmItems = SWARM_ORBS.map((orbName, i) => {
            // Distribute initial positions across viewport
            const angle = (i / SWARM_ORBS.length) * Math.PI * 2
            return {
                x: Math.random() * window.innerWidth,
                y: Math.random() * window.innerHeight,
                vx: Math.cos(angle) * 2,
                vy: Math.sin(angle) * 2,
                size: 48,
                angle: angle,
                orbName,
                speed: 0.003 + (i / SWARM_ORBS.length) * 0.004  // Faster base speeds with wider variation
            }
        })

        setItems(swarmItems)
        return () => window.removeEventListener('resize', updateDimensions)
    }, [])

    useEffect(() => {
        const centerX = dimensions.width / 2
        const centerY = dimensions.height / 2 - 120
        const orbitRadius = Math.min(dimensions.width, dimensions.height) * 0.28

        const animationFrame = requestAnimationFrame(function animate() {
            const elapsed = Date.now() - startTime
            const organizationPhase = Math.min(Math.max((elapsed - organizationDelay) / organizationDuration, 0), 1)
            
            // Smooth easing function
            const eased = organizationPhase < 0.5
                ? 4 * organizationPhase * organizationPhase * organizationPhase
                : 1 - Math.pow(-2 * organizationPhase + 2, 3) / 2
            
            setItems(currentItems => 
                currentItems.map((item) => {
                    if (organizationPhase > 0) {
                        // Gradual transition from random to orbital
                        const randomFactor = Math.max(0, 1 - eased * 0.5)
                        const orbitalFactor = eased * 0.15

                        // Random movement component
                        if (randomFactor > 0) {
                            item.x += item.vx * randomFactor
                            item.y += item.vy * randomFactor

                            // Bounce off boundaries
                            if (item.x < 0 || item.x > dimensions.width) {
                                item.vx *= -1
                                item.x = Math.max(0, Math.min(dimensions.width, item.x))
                            }
                            if (item.y < 0 || item.y > dimensions.height) {
                                item.vy *= -1
                                item.y = Math.max(0, Math.min(dimensions.height, item.y))
                            }
                        }

                        // Orbital movement component
                        if (orbitalFactor > 0) {
                            // Speed up in final phase
                            const finalSpeedBoost = organizationPhase > 0.8 ? 5 : 1  // Increased from 3 to 5
                            item.angle += item.speed * orbitalFactor * finalSpeedBoost

                            const targetX = centerX + Math.cos(item.angle) * orbitRadius
                            const targetY = centerY + Math.sin(item.angle) * orbitRadius
                            
                            const dx = targetX - item.x
                            const dy = targetY - item.y
                            
                            // Stronger pull to orbit for more circular path
                            const moveSpeed = 0.01 + (eased * 0.04)  // Doubled pull strength
                            item.x += dx * moveSpeed
                            item.y += dy * moveSpeed
                        }
                    } else {
                        // Pure random movement
                        item.x += item.vx
                        item.y += item.vy

                        if (item.x < 0 || item.x > dimensions.width) {
                            item.vx *= -1
                            item.x = Math.max(0, Math.min(dimensions.width, item.x))
                        }
                        if (item.y < 0 || item.y > dimensions.height) {
                            item.vy *= -1
                            item.y = Math.max(0, Math.min(dimensions.height, item.y))
                        }
                    }

                    return item
                })
            )

            requestAnimationFrame(animate)
        })

        return () => cancelAnimationFrame(animationFrame)
    }, [dimensions, startTime])

    return (
        <div className="relative w-full h-screen flex items-center justify-center">
            {/* Center Orb */}
            <Link 
                href="/general"
                className="absolute cursor-pointer transition-transform hover:scale-105"
                style={{
                    left: `${dimensions.width / 2 - 100}px`,
                    top: `${dimensions.height / 2 - 220}px`, // Reduced offset to move down
                }}
            >
                <Image
                    src="/groups/orbs/ensurance-orb.png"
                    alt="Ensurance Orb"
                    width={200}
                    height={200}
                    className="rounded-full"
                    priority
                />
            </Link>

            {/* Swarm Items */}
            {items.map((item, index) => (
                <div
                    key={index}
                    className="absolute transition-transform duration-100 pointer-events-none"
                    style={{
                        left: `${item.x - item.size / 2}px`,
                        top: `${item.y - item.size / 2}px`,
                        width: `${item.size}px`,
                        height: `${item.size}px`,
                    }}
                >
                    <Image
                        src={`/groups/orbs/${item.orbName}-orb.png`}
                        alt={`${item.orbName} orb`}
                        width={item.size}
                        height={item.size}
                        className="rounded-full opacity-60"
                    />
                </div>
            ))}
        </div>
    )
}
````

## File: src/modules/specific/callSale.ts
````typescript
import { encodeFunctionData } from 'viem'
import { ABIS, CONTRACTS, publicClient } from './config'
import type { SalesConfig } from './types'

/**
 * Convert a date string to a uint64 timestamp (start of day UTC)
 * Returns 0 if no date is provided
 */
export const dateToUint64 = (date: string): bigint => {
  if (!date) return BigInt(0)
  const d = new Date(date)
  d.setUTCHours(0, 0, 0, 0)
  return BigInt(Math.floor(d.getTime() / 1000))
}

/**
 * Fetches the current sales config for a token
 */
export async function getSalesConfig(tokenId: string): Promise<SalesConfig> {
  const config = await publicClient.readContract({
    address: CONTRACTS.erc20Minter,
    abi: ABIS.erc20Minter,
    functionName: 'sale',
    args: [CONTRACTS.specific, BigInt(tokenId)]
  }) as Promise<SalesConfig>

  return config
}

/**
 * Encodes a sales config for use with callSale
 * All fields must be provided - no merging with existing values
 */
export function encodeSalesConfig(config: SalesConfig, tokenId: string): `0x${string}` {
  // Encode the sales config
  return encodeFunctionData({
    abi: ABIS.erc20Minter,
    functionName: 'setSale',
    args: [BigInt(tokenId), config]
  })
}
````

## File: src/modules/specific/callSaleInitial.ts
````typescript
import { CONTRACTS, ABIS } from './config'
import { encodeSalesConfig } from './callSale'
import type { SalesConfig } from './types'

export const getInitialSalesConfig = (tokenId: string, walletAddress: `0x${string}`): SalesConfig => {
  // Get current timestamp in seconds
  const currentTimestamp = BigInt(Math.floor(Date.now() / 1000))
  
  return {
    saleStart: currentTimestamp,
    saleEnd: BigInt(0),
    maxTokensPerAddress: BigInt(0),
    pricePerToken: BigInt(1e6), // 1 USDC (6 decimals)
    fundsRecipient: walletAddress,
    currency: CONTRACTS.usdc
  }
}

export const encodeInitialSalesConfig = (tokenId: string, walletAddress: `0x${string}`) => {
  const config = getInitialSalesConfig(tokenId, walletAddress)
  return encodeSalesConfig(config, tokenId)
}
````

## File: src/modules/specific/collect.ts
````typescript
import { createPublicClient, http, maxUint256 } from 'viem'
import { base } from 'viem/chains'
import { getToken, getTokensOfContract, mint } from '@zoralabs/protocol-sdk'
import { PERMIT2_ADDRESS, CONTRACTS } from '@/modules/specific/config'

// Types
export type TokenDisplayInfo = {
  contract: string
  creator: `0x${string}`
  maxSupply: bigint
  mintType: '1155' | '721' | 'premint'
  tokenURI: string
  totalMinted: bigint
  primaryMintActive: boolean
  salesConfig?: {
    pricePerToken: bigint
    saleEnd: bigint
    saleStart: bigint
    fundsRecipient: string
  }
}

// Check and handle USDC allowance
async function handleAllowance(
  publicClient: any,
  walletClient: any,
  amount: bigint,
  owner: `0x${string}`
) {
  try {
    // Check current allowance
    const allowance = await publicClient.readContract({
      address: CONTRACTS.usdc,
      abi: [
        {
          inputs: [
            { name: 'owner', type: 'address' },
            { name: 'spender', type: 'address' }
          ],
          name: 'allowance',
          outputs: [{ type: 'uint256' }],
          stateMutability: 'view',
          type: 'function'
        }
      ],
      functionName: 'allowance',
      args: [owner, CONTRACTS.erc20Minter]
    })

    console.log('Current allowance:', allowance.toString())
    console.log('Required amount:', amount.toString())

    // If allowance is sufficient, return true
    if (allowance >= amount) {
      return { needsApproval: false }
    }

    // If not, return false to indicate approval is needed
    return { needsApproval: true }
  } catch (error) {
    console.error('Error checking allowance:', error)
    throw error
  }
}

// Separate approval function
async function approveUSDC(
  publicClient: any,
  walletClient: any,
  owner: `0x${string}`
) {
  try {
    const hash = await walletClient.writeContract({
      address: CONTRACTS.usdc,
      abi: [
        {
          inputs: [
            { name: 'spender', type: 'address' },
            { name: 'amount', type: 'uint256' }
          ],
          name: 'approve',
          outputs: [{ type: 'bool' }],
          stateMutability: 'nonpayable',
          type: 'function'
        }
      ],
      functionName: 'approve',
      args: [PERMIT2_ADDRESS, maxUint256],
      account: owner
    })

    // Wait for approval transaction
    await publicClient.waitForTransactionReceipt({ hash })
    return true
  } catch (error) {
    console.error('Error approving USDC:', error)
    throw error
  }
}

// Core minting function - simplified to match Zora docs
export async function mintToken(
  contractAddress: `0x${string}`,
  tokenId: string,
  quantity: number,
  minterAccount: `0x${string}`,
  walletClient: any
) {
  const publicClient = createPublicClient({
    chain: base,
    transport: http()
  })

  // Get mint parameters from Zora SDK
  const { parameters } = await mint({
    tokenContract: contractAddress,
    mintType: '1155',
    tokenId: BigInt(tokenId),
    quantityToMint: quantity,
    minterAccount,
    publicClient,
    preferredSaleType: 'erc20',
    mintReferral: CONTRACTS.mintReferral
  })

  console.log('Zora SDK parameters:', {
    args: parameters.args,
    functionName: parameters.functionName,
    address: parameters.address
  })

  // Get price from the 4th parameter (index 4)
  const pricePerToken = parameters.args[4] as bigint
  // Calculate total price in USDC (6 decimals)
  const totalPrice = pricePerToken * BigInt(quantity)

  console.log('Price per token:', pricePerToken.toString())
  console.log('Quantity:', quantity)
  console.log('Total price:', totalPrice.toString())

  // Check if approval is needed
  const { needsApproval } = await handleAllowance(
    publicClient,
    walletClient,
    totalPrice,
    minterAccount
  )

  // Return both the parameters and approval status
  return {
    parameters: {
      ...parameters,
      args: [
        ...parameters.args.slice(0, 4),
        totalPrice, // Ensure total price is correctly set
        ...parameters.args.slice(5)
      ]
    },
    needsApproval
  }
}

// Token info fetcher - simplified
export async function getTokenInfo(
  contractAddress: `0x${string}`,
  tokenId: string
): Promise<TokenDisplayInfo | null> {
  try {
    const publicClient = createPublicClient({
      chain: base,
      transport: http()
    })

    const { token } = await getToken({
      publicClient,
      tokenContract: contractAddress,
      mintType: '1155',
      tokenId: BigInt(tokenId)
    })

    // Type assertion for the raw token data
    const rawToken = token as unknown as {
      contract: { address: string }
      creator: `0x${string}`
      maxSupply: bigint
      mintType: '1155' | '721' | 'premint'
      tokenURI: string
      totalMinted: bigint
      salesConfig?: {
        pricePerToken: bigint
        saleEnd: bigint
        saleStart: bigint
        fundsRecipient: string
      }
    }

    return {
      contract: rawToken.contract.address,
      creator: rawToken.creator,
      maxSupply: rawToken.maxSupply,
      mintType: rawToken.mintType,
      tokenURI: rawToken.tokenURI,
      totalMinted: rawToken.totalMinted,
      primaryMintActive: true,
      salesConfig: rawToken.salesConfig
    }
  } catch (error) {
    console.error('Error fetching token info:', error)
    return null
  }
}

// Contract tokens fetcher - simplified
export async function getContractTokens(
  contractAddress: `0x${string}`
): Promise<TokenDisplayInfo[]> {
  try {
    const publicClient = createPublicClient({
      chain: base,
      transport: http()
    })

    const response = await getTokensOfContract({
      publicClient,
      tokenContract: contractAddress
    })

    // Fetch complete token data for each token to get salesConfig
    const tokensWithFullData = await Promise.all(
      response.tokens.map(async (token) => {
        try {
          // Extract tokenId from the token data
          const tokenId = (token as any).tokenId?.toString() || 
                         (token as any).token?.tokenId?.toString()
          
          if (!tokenId) {
            console.warn('Could not extract tokenId from token:', token)
            return null
          }

          // Fetch complete token data using getToken
          const fullTokenData = await getToken({
            publicClient,
            tokenContract: contractAddress,
            mintType: '1155',
            tokenId: BigInt(tokenId)
          })

          // Type assertion for the raw token data
          const rawToken = fullTokenData.token as unknown as {
            contract: { address: string }
            creator: `0x${string}`
            maxSupply: bigint
            mintType: '1155' | '721' | 'premint'
            tokenURI: string
            totalMinted: bigint
            salesConfig?: {
              pricePerToken: bigint
              saleEnd: bigint
              saleStart: bigint
              fundsRecipient: string
            }
          }

          return {
            contract: rawToken.contract.address,
            creator: rawToken.creator,
            maxSupply: rawToken.maxSupply,
            mintType: rawToken.mintType,
            tokenURI: rawToken.tokenURI,
            totalMinted: rawToken.totalMinted,
            primaryMintActive: true,
            salesConfig: rawToken.salesConfig
          }
        } catch (error) {
          console.error('Error fetching full token data for token:', token, error)
          return null
        }
      })
    )

    // Filter out any null results
    return tokensWithFullData.filter(token => token !== null) as TokenDisplayInfo[]
  } catch (error) {
    console.error('Error fetching contract tokens:', error)
    return []
  }
}
````

## File: src/modules/specific/config.ts
````typescript
import { base } from 'viem/chains'
import type { Address } from 'viem'
import { createPublicClient, http } from 'viem'
import zora1155ProxyAbi from '@/abi/Zora1155proxy.json'
import zoraErc20MinterAbi from '@/abi/ZoraERC20Minter.json'

// Network config
export const NETWORK = {
  id: base.id,
  name: base.name,
  rpcUrl: `https://base-mainnet.g.alchemy.com/v2/${process.env.NEXT_PUBLIC_ALCHEMY_API_KEY}`
} as const

// Contract addresses
export const CONTRACTS = {
  specific: '0x7DFaa8f8E2aA32b6C2112213B395b4C9889580dd' as `0x${string}`,
  usdc: '0x833589fcd6edb6e08f4c7c32d4f71b54bda02913' as `0x${string}`,
  erc20Minter: '0x777777e8850d8d6d98de2b5f64fae401f96eff31' as `0x${string}`,
  mintReferral: '0x3CeDe7eae1feA81b4AEFf1f348f7497e6794ff96' as `0x${string}`
} as const

// Public client
export const publicClient = createPublicClient({
  chain: base,
  transport: http(NETWORK.rpcUrl)
})

// Constants
export const MAX_SUPPLY_OPEN_EDITION = BigInt(2 ** 64 - 1)
export const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000' as `0x${string}`

// Types
export interface TokenMetadata {
  name: string
  description?: string
  maxSupply?: bigint
  createReferral?: `0x${string}`
}

export interface ERC20MintConfig {
  currency: Address
  pricePerToken: bigint
}

export interface SupportedERC20Token {
  address: Address
  symbol: string
  decimals: number
  priceFeed?: Address
}

// Supported tokens
export const SUPPORTED_TOKENS: Record<string, SupportedERC20Token> = {
  USDC: {
    address: CONTRACTS.usdc,
    symbol: 'USDC',
    decimals: 6
  }
} as const

// Contract ABIs
export const ABIS = {
  specific: zora1155ProxyAbi,
  erc20Minter: zoraErc20MinterAbi
} as const

// Helper functions
export function isSpecificContract(address: Address): boolean {
  return address.toLowerCase() === CONTRACTS.specific.toLowerCase()
}

// Contract function selectors (for direct contract calls)
export const CONTRACT_FUNCTIONS = {} as const

// ===== Formatting Utilities =====

/**
 * Convert a date string to a uint64 timestamp (start of day UTC)
 * Returns 0 if no date is provided or if date is invalid
 */
export const dateToUint64 = (date: string): bigint => {
  if (!date) return BigInt(0)
  // Parse the date in UTC
  const [year, month, day] = date.split('-').map(Number)
  const d = new Date(Date.UTC(year, month - 1, day))
  if (isNaN(d.getTime())) return BigInt(0) // Return 0 if invalid date
  return BigInt(Math.floor(d.getTime() / 1000))
}

/**
 * Format a timestamp for display in the UI
 */
export const formatTimestamp = (timestamp: string | undefined): string => {
  if (!timestamp || timestamp === '0') return 'Not set'
  const date = new Date(Number(timestamp) * 1000)
  return date.toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    timeZone: 'UTC'
  })
}

/**
 * Format a date for input field (UTC)
 */
export const formatDateForInput = (timestamp: string | undefined): string => {
  if (!timestamp || timestamp === '0') return ''
  const date = new Date(Number(timestamp) * 1000)
  return date.toISOString().split('T')[0] // YYYY-MM-DD format in UTC
}

/**
 * Check if a sale is currently active
 */
export const isSaleActive = (
  startTimestamp: string | undefined,
  endTimestamp: string | undefined
): boolean => {
  if (!startTimestamp || startTimestamp === '0') return false
  const now = BigInt(Math.floor(Date.now() / 1000))
  const start = BigInt(startTimestamp)
  const end = endTimestamp ? BigInt(endTimestamp) : BigInt(0)
  
  // If end is 0, sale is infinite
  if (end === BigInt(0)) {
    return start <= now
  }
  
  return start <= now && now < end
}

/**
 * Convert a USDC amount (6 decimals) to a display amount
 * Example: 1000000 -> "1.00"
 */
export const formatUsdcAmount = (amount: string | bigint): string => {
  if (!amount) return '0.00'
  const amountBigInt = typeof amount === 'string' ? BigInt(amount) : amount
  const amountFloat = Number(amountBigInt) / 1_000_000
  return amountFloat.toLocaleString('en-US', {
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  })
}

/**
 * Convert a display amount to USDC amount (6 decimals)
 * Example: "1.00" -> 1000000, "10" -> 10000000
 */
export const parseUsdcAmount = (amount: string): bigint => {
  if (!amount) return BigInt(0)
  // Handle both "10" and "10.00" formats
  const amountFloat = parseFloat(amount)
  if (isNaN(amountFloat)) return BigInt(0)
  return BigInt(Math.floor(amountFloat * 1_000_000))
}

/**
 * Format a USDC amount with currency symbol
 * Example: 1000000 -> "$1.00 USDC"
 */
export const formatUsdcWithSymbol = (amount: string | bigint): string => {
  return `$${formatUsdcAmount(amount)} USDC`
}

/**
 * Validate a USDC amount
 * Returns error message if invalid, null if valid
 */
export const validateUsdcAmount = (amount: string): string | null => {
  if (!amount) return 'Amount is required'
  
  const amountFloat = parseFloat(amount)
  if (isNaN(amountFloat)) return 'Invalid amount'
  if (amountFloat < 0) return 'Amount must be positive'
  
  // Check if amount has more than 6 decimal places
  const decimals = amount.split('.')[1]?.length || 0
  if (decimals > 6) return 'Amount cannot have more than 6 decimal places'
  
  return null
}

/**
 * Validate a sale configuration
 * Returns error message if invalid, null if valid
 */
export const validateSaleConfig = (
  startDate: string,
  endDate: string,
  price: string
): string | null => {
  // Validate dates
  if (startDate && endDate) {
    const start = dateToUint64(startDate)
    const end = dateToUint64(endDate)
    if (end <= start) {
      return 'End date must be after start date'
    }
  }
  
  // Validate price
  const priceError = validateUsdcAmount(price)
  if (priceError) return priceError
  
  return null
}

// Add SalesConfig type
export type SalesConfig = {
  saleStart: bigint
  saleEnd: bigint
  maxTokensPerAddress: bigint
  pricePerToken: bigint
  fundsRecipient: `0x${string}`
  currency: `0x${string}`
}

/**
 * Format a sales config for contract submission
 * Converts all display values to contract format
 */
export const formatSalesConfigForContract = (config: {
  saleStart?: string
  saleEnd?: string
  price?: string
  fundsRecipient?: string
  maxTokensPerAddress?: string
  currency?: `0x${string}`
}): SalesConfig => {
  return {
    saleStart: dateToUint64(config.saleStart || ''),
    saleEnd: dateToUint64(config.saleEnd || ''),
    maxTokensPerAddress: BigInt(config.maxTokensPerAddress || '0'),
    pricePerToken: parseUsdcAmount(config.price || ''),
    fundsRecipient: (config.fundsRecipient || ZERO_ADDRESS) as `0x${string}`,
    currency: config.currency || ZERO_ADDRESS
  }
}

/**
 * Format a sale end timestamp for display
 * Returns 'No end date' if the sale end is zero or falsy, otherwise formats the timestamp
 */
export const formatSaleEnd = (saleEnd: bigint | string | undefined): string => {
  if (!saleEnd || saleEnd === '0' || saleEnd === BigInt(0)) return 'No end date'
  return formatTimestamp(saleEnd.toString())
}

// Permit2 on Base
export const PERMIT2_ADDRESS = '0x000000000022D473030F116dDEE9F6B43aC78BA3' as `0x${string}`
````

## File: src/modules/specific/create.ts
````typescript
import { createPublicClient, createWalletClient, custom, http, encodeFunctionData } from 'viem'
import { base } from 'viem/chains'
import { 
  CONTRACTS, 
  CONTRACT_FUNCTIONS, 
  ABIS, 
  type TokenMetadata, 
  type ERC20MintConfig,
  MAX_SUPPLY_OPEN_EDITION,
  ZERO_ADDRESS,
  publicClient
} from './config'
import type { Address } from 'viem'
import { isAppAdmin } from '@/config/admin'
import { sql } from '@vercel/postgres'
import { type Hash } from 'viem'
import type { TokenMetadata as TokenMetadataType, SpecificMetadata } from './types'
import { encodeSalesConfig, dateToUint64 } from './callSale'

// URL generation helper
const getMetadataUrl = (tokenId: string) => 
  `https://ensurance.app/api/metadata/${CONTRACTS.specific}/${tokenId}`;

/**
 * Get the next token ID that will be minted
 */
export async function getNextTokenId(): Promise<string> {
  const nextTokenId = await publicClient.readContract({
    address: CONTRACTS.specific,
    abi: ABIS.specific,
    functionName: 'nextTokenId'
  }) as bigint
  
  return nextTokenId.toString()
}

export type CreateTokenStatus = {
  step: 'creating-token' | 'uploading-media' | 'storing-metadata' | 'complete' | 'error'
  error?: string
  tokenId?: string
  txHash?: `0x${string}`
  mediaUrl?: string
  redirectUrl?: string
}

export type CreateTokenParams = {
  metadata: TokenMetadata
  mediaFile: File
  creatorAccount: `0x${string}`
  onStatus: (status: CreateTokenStatus) => void
}

/**
 * Creates a new token on our specific contract using direct contract calls
 */
export async function createToken({
  metadata,
  mediaFile,
  creatorAccount,
  onStatus
}: CreateTokenParams): Promise<{
  tokenId: bigint
  parameters: {
    abi: any
    functionName: string
    args: any[]
    address: `0x${string}`
  }
}> {
  try {
    onStatus({
      step: 'creating-token'
    })

    // Get next token ID
    const nextTokenId = await getNextTokenId()
    const metadataUrl = getMetadataUrl(nextTokenId)

    // Prepare token setup parameters
    const maxSupply = metadata.maxSupply ?? BigInt(2 ** 64 - 1)
    const createReferral = '0x3CeDe7eae1feA81b4AEFf1f348f7497e6794ff96' as `0x${string}`

    // Create token on-chain using direct contract call
    const parameters = {
      abi: ABIS.specific,
      functionName: 'setupNewTokenWithCreateReferral',
      args: [metadataUrl, maxSupply, createReferral],
      address: CONTRACTS.specific
    }

    // Update status: Token created
    onStatus?.({
      step: 'creating-token',
      tokenId: nextTokenId
    })

    // Return the result for transaction submission
    return {
      tokenId: BigInt(nextTokenId),
      parameters
    }
  } catch (error) {
    onStatus?.({
      step: 'error',
      error: error instanceof Error ? error.message : 'Failed to create token'
    })
    throw error
  }
}

/**
 * Uploads media files and returns the URLs
 */
export async function uploadTokenMedia({
  mediaFile,
  thumbnailFile,
  tokenId,
  onStatus
}: {
  mediaFile: File
  thumbnailFile?: File
  tokenId: string
  onStatus?: (status: CreateTokenStatus) => void
}) {
  try {
    // Update status: Uploading media
    onStatus?.({
      step: 'uploading-media',
      tokenId
    })

    // Create form data
    const formData = new FormData()
    formData.append('file', mediaFile)
    formData.append('tokenId', tokenId)
    formData.append('metadata', JSON.stringify({
      contract_address: CONTRACTS.specific,
      name: '',  // These will be updated later in finalizeToken
      description: ''
    }))

    // Upload media and store initial metadata
    const response = await fetch('/api/specific', {
      method: 'POST',
      body: formData
    })

    if (!response.ok) {
      const error = await response.json()
      throw new Error(error.error || 'Failed to upload file')
    }

    const { mediaUrl } = await response.json()
    return { mediaUrl }
  } catch (error) {
    onStatus?.({
      step: 'uploading-media',
      tokenId,
      error: error instanceof Error ? error.message : 'Failed to upload media'
    })
    throw error
  }
}

/**
 * Uploads media and stores metadata for a token after it has been created on-chain
 */
export async function finalizeToken({
  tokenId,
  metadata,
  mediaFile,
  onStatus
}: {
  tokenId: bigint
  metadata: TokenMetadata
  mediaFile: File
  onStatus?: (status: CreateTokenStatus) => void
}): Promise<void> {
  try {
    // Update status: Uploading media and storing metadata
    onStatus?.({
      step: 'storing-metadata',
      tokenId: tokenId.toString()
    });

    // Create form data
    const formData = new FormData();
    formData.append('file', mediaFile);
    formData.append('tokenId', tokenId.toString());
    formData.append('metadata', JSON.stringify({
      contract_address: CONTRACTS.specific,
      name: metadata.name,
      description: metadata.description
    }));

    // Upload media and store metadata
    const response = await fetch('/api/specific', {
      method: 'POST',
      body: formData
    });

    if (!response.ok) {
      throw new Error('Failed to store metadata');
    }

    const { mediaUrl } = await response.json();

    // Update status: Complete
    onStatus?.({
      step: 'complete',
      tokenId: tokenId.toString(),
      mediaUrl,
      redirectUrl: `/specific/${CONTRACTS.specific}/${tokenId.toString()}/manage`
    });
  } catch (error) {
    onStatus?.({
      step: 'error',
      error: error instanceof Error ? error.message : 'Failed to finalize token'
    })
    throw error
  }
}
````

## File: src/modules/specific/manage.ts
````typescript
import { createPublicClient, createWalletClient, custom, http, encodeFunctionData } from 'viem'
import { base } from 'viem/chains'
import { 
  CONTRACTS, 
  ABIS, 
  publicClient,
  type TokenMetadata 
} from './config'
import type { Address } from 'viem'
import { type Hash } from 'viem'
import { toast } from 'react-toastify'
import { encodeSalesConfig, getSalesConfig } from './callSale'
import type { TokenData, SalesConfig } from './types'

// Helper to convert IPFS URLs if needed
const convertIpfsUrl = (url: string) => {
  if (url?.startsWith('ipfs://')) {
    return url.replace('ipfs://', 'https://magic.decentralized-content.com/ipfs/')
  }
  return url
}

/**
 * Fetch token information including metadata and sales configuration
 */
export async function getTokenInfo(
  contractAddress: `0x${string}`,
  tokenId: string
): Promise<{ token: TokenData; salesConfig: SalesConfig }> {
  try {
    console.log('Fetching token info for:', { contractAddress, tokenId })
    
    // Get token data from 1155 contract
    const [tokenData, tokenUri] = await Promise.all([
      publicClient.readContract({
        address: CONTRACTS.specific,
        abi: ABIS.specific,
        functionName: 'getTokenInfo',
        args: [BigInt(tokenId)]
      }) as Promise<TokenData>,
      publicClient.readContract({
        address: CONTRACTS.specific,
        abi: ABIS.specific,
        functionName: 'uri',
        args: [BigInt(tokenId)]
      }) as Promise<string>
    ])

    console.log('Token data from 1155:', tokenData)
    console.log('Token URI:', tokenUri)

    // Fetch metadata from tokenURI
    let metadata = { name: '' }
    try {
      const metadataResponse = await fetch(convertIpfsUrl(tokenUri))
      if (metadataResponse.ok) {
        metadata = await metadataResponse.json()
      }
    } catch (error) {
      console.warn('Failed to fetch metadata, using defaults:', error)
    }
    console.log('Metadata:', metadata)

    // Get sales config from ERC20 minter
    let salesConfig: SalesConfig
    try {
      const config = await publicClient.readContract({
        address: CONTRACTS.erc20Minter,
        abi: ABIS.erc20Minter,
        functionName: 'sale',
        args: [CONTRACTS.specific, BigInt(tokenId)]
      })
      salesConfig = config as SalesConfig
    } catch (error) {
      console.warn('Failed to fetch sales config, using defaults:', error)
      // Default sales config
      salesConfig = {
        saleStart: BigInt(0),
        saleEnd: BigInt(0),
        maxTokensPerAddress: BigInt(0),
        pricePerToken: BigInt(0),
        fundsRecipient: CONTRACTS.specific,
        currency: CONTRACTS.usdc
      }
    }

    console.log('Sales config:', salesConfig)

    return {
      token: {
        ...tokenData,
        name: metadata.name || ''
      },
      salesConfig
    }
  } catch (error) {
    console.error('Error in getTokenInfo:', error)
    throw new Error('Failed to fetch token information')
  }
}

/**
 * Update token URI
 */
export async function updateTokenURI({
  tokenId,
  newUri,
  walletClient
}: {
  tokenId: string
  newUri: string
  walletClient: any
}): Promise<void> {
  try {
    const tx = await walletClient.writeContract({
      address: CONTRACTS.specific,
      abi: ABIS.specific,
      functionName: 'updateTokenURI',
      args: [BigInt(tokenId), newUri]
    })

    await publicClient.waitForTransactionReceipt({ hash: tx })
  } catch (error) {
    console.error('Error updating token URI:', error)
    throw new Error('Failed to update token URI')
  }
}

/**
 * Reduce token supply
 */
export async function reduceSupply({
  tokenId,
  newMaxSupply,
  walletClient
}: {
  tokenId: string
  newMaxSupply: bigint
  walletClient: any
}): Promise<void> {
  try {
    const tx = await walletClient.writeContract({
      address: CONTRACTS.specific,
      abi: ABIS.specific,
      functionName: 'reduceSupply',
      args: [BigInt(tokenId), newMaxSupply]
    })

    await publicClient.waitForTransactionReceipt({ hash: tx })
  } catch (error) {
    console.error('Error reducing supply:', error)
    throw new Error('Failed to reduce supply')
  }
}

/**
 * Admin mint tokens
 */
export async function adminMint({
  tokenId,
  to,
  quantity,
  walletClient
}: {
  tokenId: string
  to: `0x${string}`
  quantity: bigint
  walletClient: any
}): Promise<void> {
  try {
    const tx = await walletClient.writeContract({
      address: CONTRACTS.specific,
      abi: ABIS.specific,
      functionName: 'adminMint',
      args: [BigInt(tokenId), to, quantity]
    })

    await publicClient.waitForTransactionReceipt({ hash: tx })
  } catch (error) {
    console.error('Error admin minting:', error)
    throw new Error('Failed to admin mint')
  }
}

/**
 * Set contract-level funds recipient
 */
export async function setFundsRecipient({
  fundsRecipient,
  walletClient
}: {
  fundsRecipient: `0x${string}`
  walletClient: any
}): Promise<void> {
  try {
    const tx = await walletClient.writeContract({
      address: CONTRACTS.specific,
      abi: ABIS.specific,
      functionName: 'setFundsRecipient',
      args: [fundsRecipient]
    })

    await publicClient.waitForTransactionReceipt({ hash: tx })
  } catch (error) {
    console.error('Error setting funds recipient:', error)
    throw new Error('Failed to set funds recipient')
  }
}
````

## File: src/modules/specific/SpecificAsset.tsx
````typescript
'use client'

import { PlusCircle } from 'lucide-react'
import Link from 'next/link'
import { CONTRACTS } from './config'

interface SpecificAssetProps {
  tokenId: number
}

export function SpecificAsset({ tokenId }: SpecificAssetProps) {
  return (
    <Link
      href={`/specific/${CONTRACTS.specific}/${tokenId}`}
      className="flex items-center gap-2 text-gray-300 hover:text-gray-100 transition-colors"
    >
      <PlusCircle className="w-6 h-6 stroke-[1.5] stroke-green-500 hover:stroke-green-400 transition-colors" />
    </Link>
  )
}
````

## File: src/modules/specific/SpecificGrid.tsx
````typescript
'use client'

import { useEffect, useState, useMemo } from 'react'
import Image from 'next/image'
import Link from 'next/link'
import { Card, CardContent } from '@/components/ui/card'
import { formatUnits } from 'viem'
import { getContractTokens, type TokenDisplayInfo } from './collect'
import { CONTRACTS, MAX_SUPPLY_OPEN_EDITION } from './config'
import { Skeleton } from '@/components/ui/skeleton'
import { Grid, List } from 'lucide-react'
import SpecificList from './SpecificList'
import { cn } from '@/lib/utils'
import { toast } from 'react-toastify'
import { EnsureButtonsLite } from '@/modules/ensure/buttons'


interface SpecificGridProps {
  searchQuery?: string
  onDataChange?: (data: any[]) => void
}

const FALLBACK_IMAGE = '/assets/no-image-found.png'

type ViewMode = 'grid' | 'list'

// Convert IPFS URL to use a gateway
const convertIpfsUrl = (url: string) => {
  if (!url) return FALLBACK_IMAGE
  if (url.startsWith('ipfs://')) {
    return url.replace('ipfs://', 'https://magic.decentralized-content.com/ipfs/')
  }
  return url
}



export default function SpecificGrid({ 
  searchQuery = '',
  onDataChange
}: SpecificGridProps) {
  const [tokens, setTokens] = useState<TokenDisplayInfo[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string>()
  const [tokenMetadata, setTokenMetadata] = useState<Record<string, any>>({})
  const [viewMode, setViewMode] = useState<ViewMode>('grid')

  useEffect(() => {
    let mounted = true

    const fetchTokens = async () => {
      try {
        setLoading(true)
        const tokenList = await getContractTokens(CONTRACTS.specific)
        
        // Helper function to convert BigInts to strings for logging
        const convertBigIntsToStrings = (obj: any): any => {
          if (typeof obj === 'bigint') {
            return obj.toString()
          }
          if (Array.isArray(obj)) {
            return obj.map(convertBigIntsToStrings)
          }
          if (obj && typeof obj === 'object') {
            const newObj: any = {}
            for (const key in obj) {
              newObj[key] = convertBigIntsToStrings(obj[key])
            }
            return newObj
          }
          return obj
        }

        console.log('Raw Zora SDK Token Data:', JSON.stringify(convertBigIntsToStrings(tokenList), null, 2))
        console.log('Sample token structure:', convertBigIntsToStrings({
          tokenURI: tokenList[0]?.tokenURI,
          totalMinted: tokenList[0]?.totalMinted,
          maxSupply: tokenList[0]?.maxSupply,
          salesConfig: tokenList[0]?.salesConfig,
          primaryMintActive: tokenList[0]?.primaryMintActive
        }))
        
        if (mounted) {
          setTokens(tokenList)
          
          // Fetch metadata for each token
          const metadata: Record<string, any> = {}
          for (const token of tokenList) {
            try {
              if (token.tokenURI.startsWith('http')) {
                const response = await fetch(token.tokenURI)
                metadata[token.tokenURI] = await response.json()
              } else {
                metadata[token.tokenURI] = JSON.parse(token.tokenURI)
              }
            } catch (err) {
              console.error('Error fetching metadata for token:', err)
              metadata[token.tokenURI] = { error: true }
            }
          }
          if (mounted) {
            setTokenMetadata(metadata)
          }
        }
      } catch (err) {
        console.error('Error loading data:', err)
        if (mounted) {
          setError(err instanceof Error ? err.message : 'Failed to load data')
        }
      } finally {
        if (mounted) {
          setLoading(false)
        }
      }
    }

    fetchTokens()

    return () => {
      mounted = false
    }
  }, [])

  // Filter tokens based on search query
  const filteredTokens = useMemo(() => {
    if (!searchQuery) return tokens

    const searchLower = searchQuery.toLowerCase()
    return tokens.filter(token => {
      const metadata = tokenMetadata[token.tokenURI]
      if (!metadata || metadata.error) return false

      return (
        metadata.name?.toLowerCase().includes(searchLower) ||
        metadata.description?.toLowerCase().includes(searchLower)
      )
    })
  }, [tokens, tokenMetadata, searchQuery])

  if (loading) {
    return (
      <div className="space-y-4">
        <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6 mt-6">
          {[...Array(6)].map((_, index) => (
            <Card key={`skeleton-${index}`} className="bg-primary-dark border-gray-800">
              <CardContent className="p-4">
                <Skeleton className="h-48 w-full mb-4 bg-gray-800" />
                <Skeleton className="h-4 w-3/4 mb-2 bg-gray-800" />
              </CardContent>
            </Card>
          ))}
        </div>
      </div>
    )
  }

  if (error) {
    return (
      <div className="space-y-4">
        <div className="bg-red-50 border border-red-200 rounded-lg p-4">
          <h2 className="text-red-800 font-medium">Error</h2>
          <p className="text-red-600">{error}</p>
        </div>
      </div>
    )
  }

  if (filteredTokens.length === 0) {
    return (
      <div className="space-y-4">
        <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-4">
          <h2 className="text-yellow-800 font-medium">None Found</h2>
          <p className="text-yellow-600">No matches found</p>
        </div>
      </div>
    )
  }

  return (
    <div className="space-y-4">
      {/* View Mode Toggle */}
      <div className="flex items-center justify-end gap-2">
        <div className="bg-gray-900/30 rounded-lg p-1 flex gap-1">
          <button
            onClick={() => setViewMode('grid')}
            className={`p-1.5 rounded-md transition-colors ${
              viewMode === 'grid'
                ? 'bg-gray-800 text-white'
                : 'text-gray-400 hover:text-white'
            }`}
            aria-label="Grid view"
          >
            <Grid className="w-5 h-5" />
          </button>
          <button
            onClick={() => setViewMode('list')}
            className={`p-1.5 rounded-md transition-colors ${
              viewMode === 'list'
                ? 'bg-gray-800 text-white'
                : 'text-gray-400 hover:text-white'
            }`}
            aria-label="List view"
          >
            <List className="w-5 h-5" />
          </button>
        </div>
      </div>

      {/* Content */}
      {viewMode === 'grid' ? (
        <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
          {filteredTokens.map((token) => {
            const metadata = tokenMetadata[token.tokenURI]
            const metadataError = metadata?.error
            let imageUrl = FALLBACK_IMAGE

            if (metadata && !metadataError && metadata.image) {
              imageUrl = metadata.image.startsWith('ipfs://') 
                ? metadata.image.replace('ipfs://', 'https://magic.decentralized-content.com/ipfs/') + `?t=${Date.now()}`
                : metadata.image + `?t=${Date.now()}`
            }

            return (
              <Card key={token.tokenURI} className="bg-primary-dark border-gray-800 hover:border-gray-700 transition-colors group">
                {token.primaryMintActive ? (
                  <Link href={`/specific/${CONTRACTS.specific}/${token.tokenURI.split('/').pop()}`}>
                    <CardContent className="p-4">
                      <div className="flex flex-col gap-4">
                        <div className="relative w-full aspect-square rounded-lg overflow-hidden bg-black/20">
                          <Image
                            src={imageUrl}
                            alt={metadata?.name || 'Token'}
                            fill
                            sizes="(max-width: 640px) 100vw, (max-width: 768px) 50vw, (max-width: 1024px) 33vw, 25vw"
                            className="object-cover"
                            unoptimized={true}
                            onError={(e: any) => {
                              e.target.src = FALLBACK_IMAGE
                            }}
                          />
                        </div>
                        <div className="flex flex-col gap-1">
                          <div className="text-lg font-semibold text-white text-center truncate">
                            {metadata && !metadataError ? metadata.name.split('|')[0].trim() || 'Unnamed Token' : 'Unnamed Token'}
                          </div>
                          {metadata && !metadataError && metadata.name.includes('|') && (
                            <div className="text-sm text-gray-400 text-center">
                              {metadata.name.split('|')[1].trim()}
                            </div>
                          )}
                        </div>
                        {metadataError && (
                          <div className="text-yellow-500 text-sm text-center">
                            Metadata not available
                          </div>
                        )}
                        <div className="flex items-center justify-between text-sm text-gray-400 px-2">
                          <div className="flex gap-4 items-center">
                            <div>issued: {token.totalMinted.toString()} / {String(token.maxSupply >= MAX_SUPPLY_OPEN_EDITION - BigInt(1) ? '∞' : token.maxSupply.toString())}</div>
                            {token.salesConfig?.pricePerToken && (
                              <div className="flex items-center gap-2">
                                <span>${formatUnits(token.salesConfig.pricePerToken, 6)} ea</span>
                              </div>
                            )}
                          </div>
                          {/* Buy button - only show on hover */}
                          <div className="opacity-0 group-hover:opacity-100 transition-opacity duration-200">
                            <EnsureButtonsLite
                              tokenSymbol={metadata && !metadataError ? metadata.name?.split('|')[0].trim() || 'Certificate' : 'Certificate'}
                              tokenName={metadata && !metadataError ? metadata.name : undefined}
                              imageUrl={imageUrl}
                              contractAddress={CONTRACTS.specific}
                              tokenId={token.tokenURI.split('/').pop()}
                              tokenType="erc1155"
                              context="specific"
                              variant="grid"
                              pricePerToken={token.salesConfig?.pricePerToken}
                              primaryMintActive={token.primaryMintActive}
                              showBuy={true}
                              showSwap={false}
                              showSend={false}
                              showBurn={false}
                            />
                          </div>
                        </div>
                      </div>
                    </CardContent>
                  </Link>
                ) : (
                  <CardContent 
                    className="p-4 cursor-pointer" 
                    onClick={() => {
                      toast.error('This policy is no longer issuing certificates', {
                        position: "top-right",
                        autoClose: 3000,
                        hideProgressBar: false,
                        closeOnClick: true,
                        pauseOnHover: true,
                        draggable: true,
                      })
                    }}
                  >
                    <div className="flex flex-col gap-4">
                      <div className="relative w-full aspect-square rounded-lg overflow-hidden bg-black/20">
                        <Image
                          src={imageUrl}
                          alt={metadata?.name || 'Token'}
                          fill
                          sizes="(max-width: 640px) 100vw, (max-width: 768px) 50vw, (max-width: 1024px) 33vw, 25vw"
                          className="object-cover"
                          unoptimized={true}
                          onError={(e: any) => {
                            e.target.src = FALLBACK_IMAGE
                          }}
                        />
                      </div>
                      <div className="flex flex-col gap-1">
                        <div className="text-lg font-semibold text-white text-center truncate">
                          {metadata && !metadataError ? metadata.name.split('|')[0].trim() || 'Unnamed Token' : 'Unnamed Token'}
                        </div>
                        {metadata && !metadataError && metadata.name.includes('|') && (
                          <div className="text-sm text-gray-400 text-center">
                            {metadata.name.split('|')[1].trim()}
                          </div>
                        )}
                      </div>
                      {metadataError && (
                        <div className="text-yellow-500 text-sm text-center">
                          Metadata not available
                        </div>
                      )}
                      <div className="flex items-center justify-between text-sm text-gray-400 px-2">
                        <div className="flex gap-4 items-center">
                          <div>issued: {token.totalMinted.toString()} / {String(token.maxSupply >= MAX_SUPPLY_OPEN_EDITION - BigInt(1) ? '∞' : token.maxSupply.toString())}</div>
                          {token.salesConfig?.pricePerToken && (
                            <div>${formatUnits(token.salesConfig.pricePerToken, 6)} ea</div>
                          )}
                        </div>
                        {/* Buy button - only show on hover */}
                        <div className="opacity-0 group-hover:opacity-100 transition-opacity duration-200">
                          <EnsureButtonsLite
                            tokenSymbol={metadata && !metadataError ? metadata.name?.split('|')[0].trim() || 'Certificate' : 'Certificate'}
                            tokenName={metadata && !metadataError ? metadata.name : undefined}
                            imageUrl={imageUrl}
                            contractAddress={CONTRACTS.specific}
                            tokenId={token.tokenURI.split('/').pop()}
                            tokenType="erc1155"
                            context="specific"
                            variant="grid"
                            pricePerToken={token.salesConfig?.pricePerToken}
                            primaryMintActive={token.primaryMintActive}
                            showBuy={true}
                            showSwap={false}
                            showSend={false}
                            showBurn={false}
                          />
                        </div>
                      </div>
                    </div>
                  </CardContent>
                )}
              </Card>
            )
          })}
        </div>
      ) : (
        <SpecificList 
          tokens={filteredTokens}
          tokenMetadata={tokenMetadata}
        />
      )}
    </div>
  )
}
````

## File: src/modules/specific/SpecificList.tsx
````typescript
import { TokenDisplayInfo } from './collect'
import Image from 'next/image'
import Link from 'next/link'
import { formatUnits } from 'viem'
import { CONTRACTS, MAX_SUPPLY_OPEN_EDITION } from './config'
import { cn } from '@/lib/utils'
import { EnsureButtonsLite } from '@/modules/ensure/buttons'




interface SpecificListProps {
  tokens: TokenDisplayInfo[]
  tokenMetadata: Record<string, any>
}

const FALLBACK_IMAGE = '/assets/no-image-found.png'

export default function SpecificList({ tokens, tokenMetadata }: SpecificListProps) {
  if (!tokens.length) {
    return (
      <div className="text-center py-8">
        <p className="text-gray-500">None found</p>
      </div>
    )
  }

  return (
    <div className="overflow-x-auto">
      <table className="w-full">
        <thead>
          <tr className="text-left text-sm text-gray-400">
            <th className="pb-4 font-medium w-[40%]">token</th>
            <th className="pb-4 font-medium w-[20%]">issued</th>
            <th className="pb-4 font-medium text-right w-[20%]">price</th>
            <th className="pb-4 font-medium text-right w-[20%]">actions</th>
          </tr>
        </thead>
        <tbody className="divide-y divide-gray-800">
          {tokens.map((token) => {
            const metadata = tokenMetadata[token.tokenURI]
            const metadataError = metadata?.error
            let imageUrl = FALLBACK_IMAGE

            if (metadata && !metadataError && metadata.image) {
              imageUrl = metadata.image.startsWith('ipfs://') 
                ? metadata.image.replace('ipfs://', 'https://magic.decentralized-content.com/ipfs/') + `?t=${Date.now()}`
                : metadata.image + `?t=${Date.now()}`
            }

            return (
              <tr key={token.tokenURI} className="hover:bg-gray-900/30 transition-colors group">
                <td className="py-4">
                  <Link href={`/specific/${CONTRACTS.specific}/${token.tokenURI.split('/').pop()}`}>
                    <div className="flex items-center gap-3">
                      <div className="w-12 h-12 bg-gray-800 rounded-lg overflow-hidden flex items-center justify-center">
                        <Image
                          src={imageUrl}
                          alt={metadata?.name || 'Token'}
                          width={48}
                          height={48}
                          className="object-cover"
                          unoptimized={true}
                          onError={(e) => {
                            const img = e.target as HTMLImageElement
                            img.src = FALLBACK_IMAGE
                          }}
                        />
                      </div>
                      <div className="font-medium text-white">
                        {metadata && !metadataError ? (
                          <>
                            {metadata.name.split('|')[0].trim()}
                            {metadata.name.includes('|') && (
                              <div className="text-sm text-gray-400">
                                {metadata.name.split('|')[1].trim()}
                              </div>
                            )}
                          </>
                        ) : 'Unnamed Token'}
                      </div>
                    </div>
                  </Link>
                </td>
                <td className="py-4">
                  <div className="font-medium text-white">
                    {token.totalMinted.toString()} / {token.maxSupply >= MAX_SUPPLY_OPEN_EDITION - BigInt(1) ? '∞' : token.maxSupply.toString()}
                  </div>
                </td>
                <td className="py-4 text-right">
                  <div className="font-medium text-white">
                    {token.salesConfig?.pricePerToken 
                      ? `$${formatUnits(token.salesConfig.pricePerToken, 6)} ea`
                      : 'N/A'}
                  </div>
                </td>
                <td className="py-4 text-right">
                  <div className="opacity-0 group-hover:opacity-100 transition-opacity duration-200">
                    <EnsureButtonsLite
                      tokenSymbol={metadata && !metadataError ? metadata.name?.split('|')[0].trim() || 'Certificate' : 'Certificate'}
                      tokenName={metadata && !metadataError ? metadata.name : undefined}
                      imageUrl={imageUrl}
                      contractAddress={CONTRACTS.specific}
                      tokenId={token.tokenURI.split('/').pop()}
                      tokenType="erc1155"
                      context="specific"
                      variant="list"
                      pricePerToken={token.salesConfig?.pricePerToken}
                      primaryMintActive={token.primaryMintActive}
                      showBuy={true}
                      showSwap={false}
                      showSend={false}
                      showBurn={false}
                    />
                  </div>
                </td>
              </tr>
            )
          })}
        </tbody>
      </table>
    </div>
  )
}
````

## File: src/modules/specific/SpecificMarketSummary.tsx
````typescript
'use client'

import { useEffect, useState } from 'react'
import { formatUnits } from 'viem'
import { getContractTokens, type TokenDisplayInfo } from './collect'
import { CONTRACTS } from './config'
import { cn } from "@/lib/utils"

interface SpecificMarketSummaryProps {
  variant?: 'default' | 'subtle'
  className?: string
}

export default function SpecificMarketSummary({ 
  variant = 'default',
  className = ""
}: SpecificMarketSummaryProps) {
  const [marketData, setMarketData] = useState<{
    policiesIssued: number
    certificatesIssued: bigint
    totalValueEnsured: bigint
  }>({
    policiesIssued: 0,
    certificatesIssued: BigInt(0),
    totalValueEnsured: BigInt(0)
  })

  useEffect(() => {
    const fetchMarketData = async () => {
      try {
        const tokens = await getContractTokens(CONTRACTS.specific)
        
        // Calculate metrics
        const policiesIssued = tokens.length
        const certificatesIssued = tokens.reduce((sum, token) => sum + token.totalMinted, BigInt(0))
        const totalValueEnsured = tokens.reduce((sum, token) => {
          if (token.salesConfig?.pricePerToken) {
            return sum + (token.totalMinted * token.salesConfig.pricePerToken)
          }
          return sum
        }, BigInt(0))

        setMarketData({
          policiesIssued,
          certificatesIssued,
          totalValueEnsured
        })
      } catch (error) {
        console.error('Error fetching market data:', error)
      }
    }

    fetchMarketData()
  }, [])

  if (variant === 'subtle') {
    return (
      <div className={cn("text-right", className)}>
        <div className="flex flex-col gap-1">
          <div className="flex justify-end gap-6">
            <div>
              <div className="text-sm text-gray-400">policies issued</div>
              <div className="text-xl font-semibold text-white">{marketData.policiesIssued}</div>
            </div>
            <div>
              <div className="text-sm text-gray-400">certificates issued</div>
              <div className="text-xl font-semibold text-white">{marketData.certificatesIssued.toString()}</div>
            </div>
            <div>
              <div className="text-sm text-gray-400">total value ensured</div>
              <div className="text-xl font-semibold text-white">${formatUnits(marketData.totalValueEnsured, 6)}</div>
            </div>
          </div>
        </div>
      </div>
    )
  }

  return (
    <div className={className}>
      <div className="space-y-1">
        <div className="flex justify-between items-center">
          <span className="text-gray-400">policies issued</span>
          <span className="font-medium text-white">{marketData.policiesIssued}</span>
        </div>
        <div className="flex justify-between items-center">
          <span className="text-gray-400">certificates issued</span>
          <span className="font-medium text-white">{marketData.certificatesIssued.toString()}</span>
        </div>
        <div className="flex justify-between items-center">
          <span className="text-gray-400">total value ensured</span>
          <span className="font-medium text-white">${formatUnits(marketData.totalValueEnsured, 6)}</span>
        </div>
      </div>
    </div>
  )
}
````

## File: src/modules/specific/types.ts
````typescript
// Contract return value types
export type TokenData = {
  totalMinted: bigint
  maxSupply: bigint
  image: string
  name: string
  description: string
}

export type SalesConfig = {
  saleStart: bigint
  saleEnd: bigint
  maxTokensPerAddress: bigint
  pricePerToken: bigint
  fundsRecipient: `0x${string}`
  currency: `0x${string}`
}

// Status types
export type CreateTokenStatus = {
  step: 'creating-token' | 'uploading-media' | 'storing-metadata' | 'complete' | 'error'
  tokenId?: string
  error?: string
  txHash?: `0x${string}`
  mediaUrl?: string
}

// Metadata types
export type TokenMetadata = {
  name: string
  description: string
  image: string
  thumbnail?: string
  attributes?: Record<string, any>
  maxSupply?: bigint
  createReferral?: `0x${string}`
}

export interface SpecificMetadata {
  name: string
  description?: string
  image: string
  animation_url?: string
  content?: {
    mime: string
    uri: string
  }
  attributes?: Record<string, any>
}

// Function parameter types
export type CreateTokenParams = {
  metadata: TokenMetadata
  mediaFile: File
  erc20Config?: {
    currency: `0x${string}`
    pricePerToken: bigint
  }
  creatorAccount: `0x${string}`
  onStatus: (status: CreateTokenStatus) => void
}
````

## File: src/modules/syndicates/SyndicateGrid.tsx
````typescript
'use client'

import { useState, useEffect, useMemo, useCallback } from 'react'
import Link from 'next/link'
import Image from 'next/image'
import { Card, CardContent } from "@/components/ui/card"
import { Skeleton } from "@/components/ui/skeleton"

interface Syndicate {
    name: string;
    tagline: string;
    description: string | null;
    currency: string;
    media: Record<string, any>;
    image_url: string;
    natural_capital_stocks: string[];
    natural_capital_flows: string[];
    nat_cap_rate: string | number;
}

interface SyndicateGridProps {
    searchQuery?: string;
}

const FALLBACK_IMAGE = '/assets/ensurance-example.png'
const ITEMS_PER_PAGE = 12

export default function SyndicateGrid({ searchQuery = '' }: SyndicateGridProps) {
    const [syndicates, setSyndicates] = useState<Syndicate[]>([])
    const [loading, setLoading] = useState(true)
    const [error, setError] = useState<string | null>(null)
    const [page, setPage] = useState(1)

    // Reset page when search changes
    useEffect(() => {
        setPage(1)
    }, [searchQuery])

    const fetchSyndicates = useCallback(async () => {
        try {
            const response = await fetch('/api/syndicates')
            if (!response.ok) throw new Error('Failed to fetch syndicates')
            const data = await response.json()
            setSyndicates(data)
        } catch (err) {
            console.error('Error fetching syndicates:', err)
            setError('Failed to load syndicates')
        } finally {
            setLoading(false)
        }
    }, [])

    useEffect(() => {
        let mounted = true
        setLoading(true)

        const load = async () => {
            try {
                await fetchSyndicates()
            } catch (err) {
                if (mounted) {
                    setError('Failed to load syndicates')
                }
            }
        }

        load()
        return () => { mounted = false }
    }, [fetchSyndicates])

    const getSyndicateUrl = (name: string) => {
        return `/syndicates/${name.toLowerCase().replace(/\s+/g, '-')}`
    }

    const formatCurrency = (currency: string) => {
        if (currency.startsWith('0x')) {
            return `${currency.slice(0, 6)}...${currency.slice(-4)}`
        }
        return currency
    }

    // Memoized filtered syndicates
    const filteredSyndicates = useMemo(() => {
        if (!searchQuery) return syndicates

        const searchLower = searchQuery.toLowerCase()
        return syndicates.filter(syndicate => {
            const nameMatch = syndicate.name.toLowerCase().includes(searchLower)
            const taglineMatch = syndicate.tagline.toLowerCase().includes(searchLower)
            const descriptionMatch = syndicate.description?.toLowerCase().includes(searchLower) || false
            const stocksMatch = syndicate.natural_capital_stocks.some(stock => 
                stock.toLowerCase().includes(searchLower)
            )
            const flowsMatch = syndicate.natural_capital_flows.some(flow => 
                flow.toLowerCase().includes(searchLower)
            )

            return nameMatch || taglineMatch || descriptionMatch || stocksMatch || flowsMatch
        })
    }, [syndicates, searchQuery])

    // Memoized paginated syndicates
    const displayedSyndicates = useMemo(() => {
        return filteredSyndicates.slice(0, page * ITEMS_PER_PAGE)
    }, [filteredSyndicates, page])

    const loadMore = useCallback(() => {
        if (displayedSyndicates.length < filteredSyndicates.length) {
            setPage(p => p + 1)
        }
    }, [displayedSyndicates.length, filteredSyndicates.length])

    // Handle scroll-based loading
    useEffect(() => {
        const handleScroll = () => {
            if (loading || displayedSyndicates.length >= filteredSyndicates.length) return;
            
            const scrolledToBottom = 
                window.innerHeight + window.scrollY >= 
                document.documentElement.scrollHeight - 1000;

            if (scrolledToBottom) {
                loadMore();
            }
        };

        window.addEventListener('scroll', handleScroll);
        return () => window.removeEventListener('scroll', handleScroll);
    }, [loading, loadMore, displayedSyndicates.length, filteredSyndicates.length]);

    if (error) {
        return (
            <div className="text-center py-8">
                <p className="text-red-500">{error}</p>
            </div>
        )
    }

    if (loading) {
        return (
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-8">
                {[...Array(6)].map((_, index) => (
                    <Card key={`skeleton-${index}`} className="bg-primary-dark border-gray-800">
                        <CardContent className="p-6">
                            <Skeleton className="w-full mb-4 bg-gray-800" style={{ aspectRatio: '16/9' }} />
                            <Skeleton className="h-6 w-3/4 mx-auto mb-2 bg-gray-800" />
                            <Skeleton className="h-4 w-full mb-4 bg-gray-800" />
                            <div className="flex justify-between mb-4">
                                <Skeleton className="h-4 w-1/3 bg-gray-800" />
                                <Skeleton className="h-4 w-1/3 bg-gray-800" />
                            </div>
                            <Skeleton className="h-10 w-32 mx-auto bg-gray-800" />
                        </CardContent>
                    </Card>
                ))}
            </div>
        )
    }

    if (filteredSyndicates.length === 0) {
        return (
            <div className="text-center py-8">
                <p className="text-lg text-gray-600 dark:text-gray-400">
                    No syndicates found{searchQuery ? ' matching your search' : ''}.
                </p>
            </div>
        )
    }

    return (
        <div className="space-y-6">
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-8">
                {displayedSyndicates.map((syndicate) => (
                    <Card 
                        key={syndicate.name} 
                        className="group relative bg-black/20 backdrop-blur-sm border-0 overflow-hidden rounded-xl transition-all duration-300 hover:bg-black/30"
                    >
                        <Link href={getSyndicateUrl(syndicate.name)}>
                            <CardContent className="p-0">
                                <div className="relative w-full" style={{ aspectRatio: '16/9' }}>
                                    <Image
                                        src={syndicate.media?.banner || syndicate.image_url || FALLBACK_IMAGE}
                                        alt={syndicate.name}
                                        fill
                                        sizes="(max-width: 640px) 100vw, (max-width: 768px) 50vw, (max-width: 1024px) 33vw, 25vw"
                                        priority={false}
                                        loading="lazy"
                                        className="object-cover transition-all duration-500 group-hover:scale-105"
                                        onError={(e) => {
                                            const img = e.target as HTMLImageElement;
                                            img.src = FALLBACK_IMAGE;
                                        }}
                                    />
                                    <div className="absolute inset-0 bg-gradient-to-t from-black/80 via-black/20 to-transparent" />
                                </div>
                                
                                <div className="absolute inset-0 p-6 flex flex-col justify-between">
                                    <div className="flex items-center justify-between gap-2">
                                        <span className="px-3.5 py-1.5 bg-black/40 backdrop-blur-md rounded-full text-xs text-white/90 font-medium tracking-wide">
                                            yield: {syndicate.nat_cap_rate}%
                                        </span>
                                        <a 
                                            href={`mailto:tmo@basin.global?subject=Join Waitlist: ${syndicate.name}&body=Hi, I'm interested in joining the waitlist for the ${syndicate.name} syndicate.%0D%0A%0D%0ASyndicate: ${syndicate.name}`}
                                            className="px-3.5 py-1.5 bg-black/40 hover:bg-black/60 backdrop-blur-md rounded-full text-xs text-white font-medium tracking-wide transition-all duration-300"
                                            onClick={(e) => e.stopPropagation()}
                                        >
                                            Join Waitlist
                                        </a>
                                    </div>

                                    <div className="space-y-3">
                                        <div className="space-y-2.5">
                                            <h3 className="text-xl font-semibold text-white tracking-tight">
                                                {syndicate.name}
                                            </h3>
                                            
                                            <p className="text-[15px] leading-relaxed text-white/85 line-clamp-2 font-normal">
                                                {syndicate.tagline}
                                            </p>

                                            <div className="flex flex-wrap gap-2">
                                                {syndicate.natural_capital_stocks.slice(0, 2).map((stock, index) => (
                                                    <span 
                                                        key={index}
                                                        className="px-3 py-1 text-xs bg-white/15 backdrop-blur-md rounded-full text-white/90 font-medium tracking-wide"
                                                    >
                                                        {stock}
                                                    </span>
                                                ))}
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </CardContent>
                        </Link>
                    </Card>
                ))}
            </div>
        </div>
    )
}
````

## File: src/providers/privy-provider.tsx
````typescript
'use client'

import { PrivyProvider } from '@privy-io/react-auth';
import { supportedChains, getActiveChains } from '@/config/chains';
import { useEffect, useState } from 'react';

export function PrivyProviderWrapper({ children }: { children: React.ReactNode }) {
  const [mounted, setMounted] = useState(false);
  const activeChains = getActiveChains();
  const baseChain = supportedChains.find(chain => chain.id === 8453); // Base

  // Environment-based wallet configuration
  const getWalletList = (): ('metamask' | 'coinbase_wallet' | 'wallet_connect')[] => {
    const isDev = process.env.NODE_ENV === 'development';
    if (isDev) {
      // In development, show all wallets for testing
      return ['metamask', 'coinbase_wallet', 'wallet_connect'];
    } else {
      // In production, only show MetaMask
      return ['metamask'];
    }
  };

  useEffect(() => {
    setMounted(true);
  }, []);

  if (!mounted) {
    return null;
  }

  return (
    <PrivyProvider
      appId={process.env.NEXT_PUBLIC_PRIVY_APP_ID!}
      config={{
        loginMethods: ['wallet'],
        defaultChain: baseChain,
        supportedChains: activeChains,
        appearance: {
          theme: 'dark',
          accentColor: '#22c55e', // Green-500 to match your UI
          showWalletLoginFirst: true,
          walletList: getWalletList(),
          logo: '/groups/orbs/ensurance-orb.png',
          landingHeader: 'connect',
          loginMessage: 'ensurance.app'
        }
      }}
    >
      {children}
    </PrivyProvider>
  )
}
````

## File: src/providers/splits-provider.tsx
````typescript
'use client';

import { createPublicClient, http } from 'viem'
import { base } from 'viem/chains'
import { SplitsProvider } from '@0xsplits/splits-sdk-react'
import { type SplitsClientConfig } from '@0xsplits/splits-sdk'
import { ReactNode } from 'react'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'

// Create public client for Base
const publicClient = createPublicClient({
  chain: base,
  transport: http()
}) as any

// Create React Query client with aggressive caching
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 60, // 1 hour
      gcTime: 1000 * 60 * 60 * 24, // 24 hours
      retry: 2,
      refetchOnWindowFocus: false,
      refetchOnMount: false, // Don't refetch on mount
      refetchOnReconnect: false, // Don't refetch on reconnect
    },
  },
})

// Config using their recommended structure
const splitsConfig: SplitsClientConfig = {
  chainId: base.id,
  publicClient,
  includeEnsNames: false,
  apiConfig: {
    apiKey: process.env.NEXT_PUBLIC_SPLITS_API_KEY || ''
  }
}

interface SplitsWrapperProps {
  children: ReactNode
}

export function SplitsWrapper({ children }: SplitsWrapperProps) {
  return (
    <QueryClientProvider client={queryClient}>
      <SplitsProvider config={splitsConfig}>
        {children}
      </SplitsProvider>
    </QueryClientProvider>
  )
}
````

## File: src/types/index.ts
````typescript
// =============================================================================
// Situs Types
// This file defines TypeScript interfaces and types specific to the Situs project.
// These types are used throughout the application to ensure type safety and provide
// better developer experience with autocompletion and error checking.
// =============================================================================

// -----------------------------------------------------------------------------
// Group & Account Core Types
// -----------------------------------------------------------------------------
export interface Group {
    contract_address: string;
    group_name: string; // Expected to always start with a dot (e.g., ".example")
    name: string;    // Group Name
    email: string;   // Group Email
    name_front?: string;
    tagline?: string;
    description?: string;
    chat?: string;
    total_supply: number;
    website?: string;
    group_ensurance?: string | boolean;
}

export type GroupConfig = Group;

export interface GroupAccount {
    token_id: number;           // Primary key, NOT NULL
    account_name: string;       // NOT NULL
    full_account_name?: string; // Can be NULL
    tba_address?: string;       // Can be NULL
    is_agent: boolean;          // NOT NULL
    group_name: string;         // The group this account belongs to (with dot)
    description?: string;       // Can be NULL
    created_at?: string;        // Optional timestamp
    owner_of?: string;          // Optional owner address
    specific_asset_id?: number; // Optional specific asset ID
}

export interface GroupAccountsProps {
    group: string;
    accounts: GroupAccount[];
    searchQuery: string;
    hideGroupSuffix?: boolean;
    showCreateOption?: boolean;
    getAccountUrl?: (account: GroupAccount) => string;
}

// -----------------------------------------------------------------------------
// Asset Types
// -----------------------------------------------------------------------------
interface BaseAsset {
    chain: string;
    contract_address: string;
    token_id: string;
    queried_wallet_balances?: Array<{
        quantity_string: string;
        value_usd_string?: string;
        address?: string;
        first_acquired_date?: string;
        last_acquired_date?: string;
        quantity?: number;
    }>;
}

// -----------------------------------------------------------------------------
// Ensurance Asset Types
// -----------------------------------------------------------------------------

/**
 * These types identify if an asset is an Ensurance asset based on its contract.
 * This is different from the database-level isEnsurance check (in accounts.ts) which
 * is used to identify if a group is the ensurance group and include additional fields
 * like stock_or_flow and display_name in database queries.
 */
export interface EnsuranceFlags {
    isEnsuranceGeneral?: boolean;  // For ERC20 certificates from certificates.general
    isEnsuranceSpecific?: boolean; // For ERC1155 certificates from specific contract
    isEnsuranceGroup?: boolean;    // For ERC721 accounts from members.groups
}

export interface Asset extends BaseAsset {
    name?: string;
    image_url?: string;
    video_url?: string;
    audio_url?: string;
    animation_url?: string;
    description?: string;
    nft_id?: string;
    isTokenbound?: boolean;
    isNative?: boolean;
    mime_type?: string;
    collection?: {
        name?: string;
    };
    contract?: {
        type?: string;
    };
    owners?: Array<{
        owner_address: string;
        quantity: number;
    }>;
    extra_metadata?: {
        animation_original_url?: string;
    };
    symbol?: string;
    ensurance?: EnsuranceFlags;
}

export interface TokenBalance {
    chain: string;
    symbol: string;
    fungible_id?: string;
    decimals: number;
    name?: string;
    queried_wallet_balances: Array<{
        quantity_string: string;
        value_usd_string: string;
    }>;
    prices?: Array<{
        value_usd_string: string;
        marketplace_name: string;
    }>;
}

// -----------------------------------------------------------------------------
// Ensure & Ensurance Types
// -----------------------------------------------------------------------------
export type EnsureOperation = 
    | 'send' 
    | 'buy' 
    | 'sell' 
    | 'convert' 
    | 'ensure' 
    | 'hide' 
    | 'burn' 
    | 'swap' 
    | 'profile';

export interface EnsureModalProps {
    isOpen: boolean;
    onClose: () => void;
    operation: EnsureOperation;
    asset: Asset;
    address: string;
    isTokenbound: boolean;
    onAction: () => Promise<{ hash: string }>;
}

export interface EnsurancePreviewProps {
    contractAddress: string;
    group: string;
}

export interface EnsuranceForm {
    name: string;
    description: string;
}

// -----------------------------------------------------------------------------
// Validation Types
// -----------------------------------------------------------------------------
export interface ValidationReport {
    groups: {
        total: number;
        missing: string[];
        invalid: string[];
        totalSupplyMismatch: string[];
    };
    accounts: {
        total: number;
        missing: string[];
        invalid: string[];
        missingTBA: string[];
    };
    chains: {
        [key: string]: {
            total?: number;
            valid?: number;
            invalid?: number;
        };
    };
    summary: string;
}

// -----------------------------------------------------------------------------
// Tokenbound Types
// -----------------------------------------------------------------------------
import type { TokenboundClient } from "@tokenbound/sdk";

export interface TokenboundActions {
    isAccountDeployed: (params: { accountAddress: string }) => Promise<boolean>;
    createAccount?: (params: { tokenContract: string; tokenId: string }) => Promise<string>;
    executeCall?: (params: { account: string; to: string; value: string; data: string }) => Promise<{ hash: string }>;
}

// -----------------------------------------------------------------------------
// Metadata Types
// -----------------------------------------------------------------------------
export interface MetadataResponse {
    name: string;
    description: string;
    animation_url: string;
    image: string;
    tba_address: string;
    group_name: string;
    full_account_name: string;
    error?: string;
}

// -----------------------------------------------------------------------------
// Chain Types
// -----------------------------------------------------------------------------
export interface ChainDropdownProps {
    selectedChain: string;
    onChange: (chain: string) => void;
    className?: string;
    filterEnsurance?: boolean;
}

// -----------------------------------------------------------------------------
// Module Types
// -----------------------------------------------------------------------------
export interface BaseModuleProps {
  address: string;
  selectedChain: string;
  isEnsuranceTab?: boolean;
  isTokenbound: boolean;
  isOwner: boolean;
}

export interface AssetsModuleProps extends BaseModuleProps {
  searchQuery?: string;
  setSearchQuery?: (query: string) => void;
  currentGroup?: string;
}

export interface BaseTabData {
  value: string;
  label: string;
  component?: React.ComponentType<BaseModuleProps>;
  showChainDropdown?: boolean;
  isEnsuranceTab?: boolean;
}

export interface TabData extends BaseTabData {
  component: React.ComponentType<BaseModuleProps>;
  showChainDropdown?: boolean;
  isEnsuranceTab?: boolean;
}
````

## File: src/mdx-components.tsx
````typescript
import type { MDXComponents } from 'mdx/types'
import Link from 'next/link'
import Image from 'next/image'

// Custom components for MDX
export function useMDXComponents(components: MDXComponents): MDXComponents {
  // Helper function for consistent ID generation
  const generateId = (text: string) => {
    if (typeof text !== 'string') return ''
    return text.toLowerCase()
      .replace(/[^a-z0-9\s-]/g, '')
      .replace(/\s+/g, '-')
  }

  return {
    // Override default components
    h1: ({ children }) => {
      const id = generateId(children as string)
      return (
        <h1 id={id} className="text-4xl font-bold mt-8 mb-4 font-grotesk text-[rgb(var(--foreground-rgb))]">
          {children}
        </h1>
      )
    },
    h2: ({ children }) => {
      const id = generateId(children as string)
      return (
        <h2 id={id} className="text-3xl font-bold mt-8 mb-4 font-grotesk text-[rgb(var(--foreground-rgb))]">
          {children}
        </h2>
      )
    },
    h3: ({ children }) => {
      const id = generateId(children as string)
      return (
        <h3 id={id} className="text-2xl font-bold mt-6 mb-3 font-grotesk text-[rgb(var(--foreground-rgb))]">
          {children}
        </h3>
      )
    },
    h4: ({ children }) => {
      const id = generateId(children as string)
      return (
        <h4 id={id} className="text-xl font-bold mt-4 mb-2 font-grotesk text-[rgb(var(--foreground-rgb))]">
          {children}
        </h4>
      )
    },
    p: ({ children }) => (
      <p className="my-4 leading-7 font-grotesk text-[rgba(var(--foreground-rgb),0.9)]">
        {children}
      </p>
    ),
    a: ({ href = '', children }) => {
      const isInternal = href.startsWith('/')
      if (isInternal) {
        return (
          <Link 
            href={href} 
            className="text-[rgb(var(--foreground-rgb))] hover:opacity-80 underline font-grotesk"
          >
            {children}
          </Link>
        )
      }
      return (
        <a 
          href={href} 
          target="_blank" 
          rel="noopener noreferrer" 
          className="text-[rgb(var(--foreground-rgb))] hover:opacity-80 underline font-grotesk"
        >
          {children}
        </a>
      )
    },
    img: ({ src = '', alt = '' }) => (
      <div className="my-8">
        <Image
          src={src}
          alt={alt}
          width={800}
          height={400}
          className="rounded-lg"
        />
      </div>
    ),
    ul: ({ children }) => (
      <ul className="list-disc list-inside my-4 space-y-2 font-grotesk text-[rgba(var(--foreground-rgb),0.9)]">
        {children}
      </ul>
    ),
    ol: ({ children }) => (
      <ol className="list-decimal list-inside my-4 space-y-2 font-grotesk text-[rgba(var(--foreground-rgb),0.9)]">
        {children}
      </ol>
    ),
    li: ({ children }) => (
      <li className="ml-4 text-[rgba(var(--foreground-rgb),0.9)]">
        {children}
      </li>
    ),
    blockquote: ({ children }) => (
      <blockquote className="border-l-4 border-[rgba(var(--foreground-rgb),0.2)] pl-4 my-4 italic font-grotesk text-[rgba(var(--foreground-rgb),0.7)]">
        {children}
      </blockquote>
    ),
    code: ({ children }) => (
      <code className="bg-[rgba(var(--foreground-rgb),0.1)] rounded px-1 py-0.5 text-sm font-mono text-[rgb(var(--foreground-rgb))]">
        {children}
      </code>
    ),
    pre: ({ children }) => (
      <pre className="bg-[rgba(var(--foreground-rgb),0.1)] p-4 rounded-lg my-4 overflow-x-auto font-mono text-[rgb(var(--foreground-rgb))]">
        {children}
      </pre>
    ),
    // Merge with any custom components passed in
    ...components,
  }
}
````

## File: src/middleware.ts
````typescript
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export function middleware(request: NextRequest) {
  const pathname = request.nextUrl.pathname
  
  // Add pathname to headers for metadata generation
  const requestHeaders = new Headers(request.headers)
  requestHeaders.set('x-pathname', pathname)

  // Handle favicon
  if (pathname === '/favicon.ico') {
    return NextResponse.rewrite(new URL('/ensurance/favicon.ico', request.url), {
      request: { headers: requestHeaders }
    })
  }

  // Update: Redirect /groups/ensurance/all to /natural-capital instead of /pools
  if (pathname === '/groups/ensurance/all') {
    return NextResponse.redirect(new URL('/natural-capital', request.url))
  }

  // Skip for static files and API routes
  if (pathname.startsWith('/_next') || pathname.startsWith('/api/')) {
    return NextResponse.next({
      request: { headers: requestHeaders }
    })
  }

  return NextResponse.next({
    request: {
      headers: requestHeaders,
    },
  })
}

export const config = {
  matcher: [
    '/((?!_next/static|_next/image).*)',
  ],
}
````

## File: .cursorrules
````
# user preferences
- in chat: i like to understand why things are the way they are or are not working but prefer concise reponses.
- i like practical solutions that don't bloat code base
- i prefer speed of iteration and getting things working then moving on to next step
- i want ui ux to be clean, fast and modern
- always double check proposed edits when doing blockchain interaction and transaction construction

# Ensurance App - Domain Setup History

## Historical Setup (Deprecated)
This app was originally built to serve two domains from a single codebase:
- ensurance.app (primary)
- onchain-agents.ai (secondary)

The multi-domain setup used:
- Shared `/app` directory for common components
- `/app/onchain-agents` as entry point for onchain-agents.ai
- Middleware for domain-specific routing
- Conditional rendering with `isSite` helper

## Current Setup
The app now serves only ensurance.app, with onchain-agents.ai redirecting to it via DNS:

### URLs
- Production: `https://ensurance.app`
- Development: `localhost:3000`

### Legacy Code Notice
Some multi-domain code may still exist in the codebase:
- `isSite` checks in components
- Site context providers
- Domain-specific routing logic

These remnants are gradually being cleaned up but don't affect functionality as all traffic now routes to ensurance.app.

### Development Rules
- Do not open a new terminal tab if `npm run dev` is already running
- Never expose PostgreSQL connection strings or passwords in chat/composer - use `.env` for current credentials

### UPDATE (March 25, 2024)
The app is evolving towards a "markets for what matters" approach:

#### Development Strategy
1. Build and test core components independently:
   - Certificates (General ERC20, Specific ERC1155)
   - Syndicates (ERC4626)
   - Natural Assets (Property/Binder)
   - Groups, Accounts, etc.

2. Each component maintains:
   - Its own API routes
   - Business logic
   - Basic display/grid

3. Once core components are solid, unify through ensure module:
   - Powers the "markets for what matters" interface
   - Single interface for discovering all natural capital opportunities
   - Users search by what matters (water, soil, air) not by token type
   - Technical implementation becomes invisible to users
   - Primary integration point will be `/markets`

This approach ensures robust functionality while simplifying the user experience around natural capital markets.
````

## File: .gitignore
````
# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem
/notes

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env
.env*.local
.env.development
.env.test
.env.production

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

# crypto & keys
**/private-key*
**/private_key*
**/*.key
**/*.pem
wallet.json
**/secrets.json
**/credentials.json

# IDE
.idea
.vscode
*.swp
*.swo

# logs
*.log
logs/
````

## File: CONTRIBUTING.md
````markdown
# Contributing to ensurance.app

We love your input! We want to make contributing to ensurance.app as easy and transparent as possible, whether it's:

- Reporting a bug
- Discussing the current state of the code
- Submitting a fix
- Proposing new features
- Becoming a maintainer

## Development Process

We use GitHub to host code, to track issues and feature requests, as well as accept pull requests.

1. Fork the repo and create your branch from `main`
2. If you've added code that should be tested, add tests
3. If you've changed APIs, update the documentation
4. Ensure the test suite passes
5. Make sure your code lints
6. Issue that pull request!

## Pull Request Process

1. Update the README.md with details of changes to the interface, if applicable
2. Update any relevant documentation
3. The PR will be merged once you have the sign-off of at least one maintainer

## Licensing of Contributions

This project incorporates multiple licenses:

- BASIN Natural Capital Frameworks and Ensurance components are under CC BY-NC-SA 4.0
- SITUS components are under GNU GPL v3.0
- ElizaOS components are under MIT License

When you submit code changes, your submissions must comply with the appropriate license based on the component you're modifying. Please clearly indicate in your pull request which component(s) you're modifying to ensure proper license compliance.

See the [LICENSE](LICENSE) file for complete details of each license. Contact the maintainers if you have any licensing concerns.

## Report Bugs Using GitHub's [Issue Tracker](https://github.com/your-org/ensurance-app/issues)

We use GitHub issues to track public bugs. Report a bug by [opening a new issue](https://github.com/your-org/ensurance-app/issues/new); it's that easy!

## Write Bug Reports With Detail, Background, and Sample Code

**Great Bug Reports** tend to have:

- A quick summary and/or background
- Steps to reproduce
  - Be specific!
  - Give sample code if you can
- What you expected would happen
- What actually happens
- Notes (possibly including why you think this might be happening, or stuff you tried that didn't work)

## License

By contributing, you agree that your contributions will be licensed under its MIT License.
````

## File: LICENSE
````
# Multiple Licenses

This project incorporates work under multiple licenses:

## BASIN Natural Capital Frameworks and Ensurance
Used with permission under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License (CC BY-NC-SA 4.0)
See: https://docs.basin.global/dossier/formalities/license

## SITUS
GNU General Public License v3.0 (GNU GPL v3.0)

The complete text of the GNU GPL v3.0 can be found at: https://www.gnu.org/licenses/gpl-3.0.en.html

## ElizaOS
MIT License

The complete text of the MIT License can be found at: https://opensource.org/licenses/MIT

---

For specific licensing requirements and permissions:
- BASIN Framework usage: Refer to BASIN's licensing terms
- SITUS components: Comply with GNU GPL v3.0
- ElizaOS components: Comply with MIT License

Please contact the respective license holders for any usage outside these terms.

## Disclaimer

The information provided in this application is believed to be accurate and reliable; however, we provide no guarantees or warranties. This content is informational and educational and should not be considered financial or investment advice. Use of this application, including any transactions or operations performed through it, is at your own risk.
````

## File: next.config.mjs
````
import createMDX from '@next/mdx'
import remarkGfm from 'remark-gfm'
import rehypeSlug from 'rehype-slug'
import rehypeAutolinkHeadings from 'rehype-autolink-headings'

/** @type {import('next').NextConfig} */
const nextConfig = {
  // Enable MDX
  pageExtensions: ['js', 'jsx', 'mdx', 'ts', 'tsx'],
  
  // Configure image domains and patterns
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: '2rhcowhl4b5wwjk8.public.blob.vercel-storage.com',
        port: '',
        pathname: '/**',
      },
      {
        protocol: 'https',
        hostname: 'ensurance.app',
        port: '',
        pathname: '/**',
      },
    ],
    domains: [
      'openseauserdata.com',
      'i.seadn.io',
      'ipfs.io',
      'nft-cdn.alchemy.com',
      'metadata.ens.domains',
      'storage.googleapis.com',
      'arweave.net',
      'cloudflare-ipfs.com',
      '2rhcowhl4b5wwjk8.public.blob.vercel-storage.com',
      'magic.decentralized-content.com',
      'raw.githubusercontent.com',
      'ensurance.app'
    ]
  }
}

const withMDX = createMDX({
  options: {
    remarkPlugins: [remarkGfm],
    rehypePlugins: [rehypeSlug, rehypeAutolinkHeadings],
  },
})

// Merge MDX config with Next.js config
export default withMDX(nextConfig)
````

## File: package.json
````json
{
  "name": "ensurance-agents",
  "version": "0.1.0",
  "private": true,
  "engines": {
    "node": ">=20.11.1"
  },
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@0x/swap-ts-sdk": "^2.1.1",
    "@0xsplits/splits-sdk": "^4.1.0",
    "@0xsplits/splits-sdk-react": "^2.1.0",
    "@farcaster/frame-sdk": "^0.0.32",
    "@headlessui/react": "^1.7.18",
    "@mdx-js/loader": "^3.1.0",
    "@mdx-js/react": "^3.1.0",
    "@next/mdx": "^15.1.5",
    "@octokit/rest": "^21.1.0",
    "@privy-io/react-auth": "^2.8.0",
    "@privy-io/server-auth": "^1.19.0",
    "@radix-ui/react-dialog": "^1.1.4",
    "@radix-ui/react-dropdown-menu": "^2.1.4",
    "@radix-ui/react-select": "^2.1.4",
    "@radix-ui/react-slot": "^1.1.1",
    "@radix-ui/react-tooltip": "^1.1.8",
    "@shadcn/ui": "^0.0.4",
    "@tailwindcss/typography": "^0.5.16",
    "@tanstack/react-query": "^5.69.0",
    "@tokenbound/sdk": "^0.5.5",
    "@vercel/blob": "^0.27.1",
    "@vercel/postgres": "^0.10.0",
    "@zoralabs/coins": "^0.6.0",
    "@zoralabs/coins-sdk": "0.0.4",
    "@zoralabs/protocol-deployments": "^0.5.1",
    "@zoralabs/protocol-sdk": "^0.13.4",
    "alchemy-sdk": "^3.5.8",
    "axios": "^1.7.9",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.0.0",
    "d3": "^7.9.0",
    "d3-sankey": "^0.12.3",
    "dotenv": "^16.4.7",
    "flexsearch": "^0.7.43",
    "framer-motion": "^12.0.1",
    "lucide-react": "^0.303.0",
    "next": "14.1.0",
    "react": "18.2.0",
    "react-dom": "18.2.0",
    "react-infinite-scroll-component": "^6.1.0",
    "react-markdown": "^9.0.1",
    "react-spring": "^9.7.5",
    "react-toastify": "^11.0.2",
    "reactflow": "^11.11.4",
    "recharts": "^2.15.0",
    "rehype-autolink-headings": "^7.1.0",
    "rehype-slug": "^6.0.0",
    "remark-gfm": "^4.0.0",
    "swr": "^2.3.0",
    "tailwind-merge": "^2.2.0",
    "tailwindcss-animate": "^1.0.7",
    "viem": "^2.23.15"
  },
  "devDependencies": {
    "@types/d3": "^7.4.3",
    "@types/d3-sankey": "^0.12.4",
    "@types/mdx": "^2.0.11",
    "@types/node": "^20.17.16",
    "@types/react": "^18.3.17",
    "@types/react-dom": "^18.3.5",
    "autoprefixer": "^10.4.16",
    "postcss": "^8.4.32",
    "tailwindcss": "^3.4.0",
    "tsx": "^4.20.3",
    "typescript": "^5.7.2"
  }
}
````

## File: postcss.config.js
````javascript
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
````

## File: README.md
````markdown
# ensurance.app

The official frontend application for Natural Capital Ensurance, a protocol that reduces systemic risk and ensures resilience through the protection of natural capital.

## Overview

Natural Capital Ensurance safeguards 14 stocks and 19 flows of natural capital, ensuring ecosystem function across:
- Stocks: forests, wetlands, grasslands, urban and coastal ecosystems
- Flows: clean air, water, food, energy, climate stability, risk resilience, and additional cultural and ecological benefits

The application integrates with:
- elizaOS for agent operations
- Ethereum and L2 networks (Base, Zora, Arbitrum, Optimism)
- BASIN SITUS Protocol

### Flexible Implementation

This application is designed to be:
- A comprehensive client that anyone can connect to using their own elizaOS instance (with Ensurance plugin and SITUS Accounts)
- A forkable and customizable foundation where users can:
  - Enable specific groups or a subset of groups
  - Customize the interface for particular use cases
  - Build specialized versions for specific natural capital applications

## Features

- **Certificates of Ensurance**: Issue and manage certificates that fund natural assets and ecosystem services
- **Agent Integration**: Semi-autonomous actions via elizaOS
- **Multi-Chain Support**: Deploy and manage assets across multiple networks
- **$ENSURE Integration**: Nature-based currency mechanisms
- **Ensurance Pools**: Manage and participate in collaborative funding structures
- **Real-time Analytics**: Track and analyze natural capital metrics

## Getting Started

### Prerequisites

- Node.js (v18 or higher)
- Yarn or npm
- A modern web browser
- MetaMask or other Web3 wallet

### Installation

1. Clone the repository:
```bash
git clone https://github.com/basin-global/ensurance-app.git
cd ensurance-app
```

2. Install dependencies:
```bash
yarn install
```

3. Create a `.env.local` file with required environment variables:
```bash
NEXT_PUBLIC_PRIVY_APP_ID=your_privy_app_id
NEXT_PUBLIC_SPLITS_API_KEY=your_splits_api_key
```

4. Start the development server:
```bash
yarn dev
```

The app will be available at `http://localhost:3000`

## Environment Variables

Required environment variables:

- `NEXT_PUBLIC_PRIVY_APP_ID`: Privy authentication app ID
- `PRIVY_APP_SECRET`: Privy app secret for server operations
- `NEXT_PUBLIC_SPLITS_API_KEY`: API key for Splits integration

## Architecture

The application is built with:
- Next.js 13+ (App Router)
- TypeScript
- Tailwind CSS
- Privy for authentication
- IPFS for decentralized storage
- Vercel Postgres for data persistence

## Contributing

We welcome contributions! Please see our [Contributing Guidelines](CONTRIBUTING.md) for details.

## Security

If you discover a security vulnerability, please follow our [Security Policy](SECURITY.md) for responsible disclosure.

## License

This project incorporates work under multiple licenses:

- **BASIN Natural Capital Frameworks and Ensurance**: CC BY-NC-SA 4.0 - Used with permission
  (See: https://docs.basin.global/dossier/formalities/license)
- **SITUS**: GNU General Public License v3.0
- **ElizaOS**: MIT License

See the [LICENSE](LICENSE) file for complete details.

## Links

- [Website](https://ensurance.app)
- [Documentation](https://ensurance.app/docs)
- [Twitter](https://twitter.com/ensurance_app)

## Support

For support, please:
1. Check our [Documentation](https://ensurance.app/docs)
2. Open an issue in this repository
3. Contact us through our [support channels](https://ensurance.app/support)
````

## File: SECURITY.md
````markdown
# Security Policy for ensurance.app

## Important Notice

This is a Web3 application that interacts with blockchain networks and smart contracts. Please be aware that:

- **Financial Risk**: Any transactions involving cryptocurrencies, tokens, or digital assets carry inherent risks
- **Smart Contract Risk**: While we strive for security, smart contracts may contain vulnerabilities
- **Transaction Finality**: Blockchain transactions are irreversible
- **Wallet Security**: Your wallet and private keys are your responsibility
- **Network Conditions**: Transaction success depends on network conditions and gas prices

## Use At Your Own Risk

- Always verify transaction details before signing
- Never share your private keys or seed phrases
- Be cautious of phishing attempts
- Test with small amounts first
- Keep your software and wallets updated

## Reporting a Vulnerability

If you discover a security vulnerability, please:

1. **DO NOT** disclose it publicly
2. Send a detailed report to tmo @ basin.global
3. Include:
   - Description of the vulnerability
   - Steps to reproduce
   - Potential impact
   - Any suggested fixes (if available)

## Smart Contract Security

For issues related to:
- BASIN smart contracts: Contact BASIN directly
- SITUS contracts: Report through the SITUS security process
- ElizaOS: Follow ElizaOS security procedures

## Frontend Security

For frontend-specific security issues:
1. Check if the issue is already reported
2. Submit a confidential security report
3. Allow us reasonable time to respond and fix

We take security seriously and will respond as quickly as possible to all legitimate reports.
````

## File: tailwind.config.js
````javascript
/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: ["class"],
  content: [
    './src/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      fontFamily: {
        grotesk: ['var(--font-space-grotesk)', 'sans-serif'],
        mono: ['var(--font-space-mono)', 'Space Mono', 'monospace'],
      },
    },
  },
  plugins: [
    require('@tailwindcss/typography'),
    require('tailwindcss-animate')
  ],
}
````

## File: tsconfig.json
````json
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "incremental": true,
    "module": "esnext",
    "esModuleInterop": true,
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    },
    "baseUrl": "."
  },
  "include": [
    "next-env.d.ts",
    ".next/types/**/*.ts",
    "**/*.ts",
    "**/*.tsx"
  ],
  "exclude": [
    "node_modules"
  ]
}
````
